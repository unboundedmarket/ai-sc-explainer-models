{"instruction": "Explain the following smart contract code:", "input": "import datetime\n\nimport fire\nimport pycardano\n\nfrom uada.onchain import uada\nfrom uada.utils.network import show_tx, context\nfrom uada.utils.to_script_context import to_address\nfrom opshin.prelude import Token\nfrom pycardano import (\n    OgmiosChainContext,\n    TransactionBuilder,\n    Redeemer,\n    AuxiliaryData,\n    AlonzoMetadata,\n    Metadata,\n    TransactionOutput,\n    Value,\n)\n\nfrom .util import (\n    token_from_string,\n    asset_from_token,\n    module_name,\n    with_min_lovelace,\n    sorted_utxos,\n    amount_of_token_in_value,\n    SAMPLE_STAKE_KEY,\n    combine_with_stake_key,\n)\nfrom ..utils import get_signing_info, ogmios_url, network, kupo_url\nfrom ..utils.contracts import get_contract\n\n\ndef main(\n    wallet: str = \"minter\",\n    stake_key: str = SAMPLE_STAKE_KEY,\n):\n    # Get payment address\n    payment_vkey, payment_skey, payment_address = get_signing_info(\n        wallet, network=network\n    )\n    combined_address = combine_with_stake_key(payment_address, stake_key)\n\n    # Build the transaction\n    builder = TransactionBuilder(context)\n    for u in context.utxos(payment_address):\n        builder.add_input(u)\n\n    # Sign the transaction\n    signed_tx = builder.build_and_sign(\n        signing_keys=[payment_skey],\n        change_address=combined_address,\n    )\n\n    # Submit the transaction\n    context.submit_tx(signed_tx)\n\n    show_tx(signed_tx)\n\n\nif __name__ == \"__main__\":\n    fire.Fire(main)\n", "output": "This Cardano smart contract code is a Python script designed to interact with the Cardano blockchain. It is part of a larger project, likely related to a decentralized application (dApp) or a specific use case involving token management or staking. The script is intended to move funds to a staked address. Let's break down the code in detail:\n\n### Imports\n\n1. **Standard Libraries:**\n   - `datetime`: Not used in the provided code, but typically used for handling date and time operations.\n   - `fire`: A library for automatically generating command-line interfaces (CLIs) from Python functions.\n\n2. **Cardano Libraries:**\n   - `pycardano`: A library for interacting with the Cardano blockchain, providing tools for building and submitting transactions.\n   - `opshin.prelude`: Contains utility functions and types for working with Cardano smart contracts.\n\n3. **Project-Specific Imports:**\n   - `uada.onchain.uada`: Likely contains on-chain logic or contract definitions specific to the project.\n   - `uada.utils.network`: Contains utility functions for network interactions, such as displaying transactions and getting context.\n   - `uada.utils.to_script_context`: Provides functions for converting data to a script context, such as addresses.\n   - `uada.utils`: Contains various utility functions and constants used throughout the project.\n   - `uada.utils.contracts`: Functions related to contract management.\n\n### Utility Functions and Constants\n\n- **`token_from_string`, `asset_from_token`, `module_name`, `with_min_lovelace`, `sorted_utxos`, `amount_of_token_in_value`, `SAMPLE_STAKE_KEY`, `combine_with_stake_key`:** These are utility functions and constants imported from the project's utility module. They likely handle token parsing, asset management, and address manipulation.\n\n### Main Function\n\nThe `main` function is the core of the script, performing the following steps:\n\n1. **Get Payment Address:**\n   - `get_signing_info`: Retrieves the signing information for a given wallet, including the verification key (`vkey`), signing key (`skey`), and payment address. The `network` parameter specifies which Cardano network to use (e.g., mainnet or testnet).\n\n2. **Combine with Stake Key:**\n   - `combine_with_stake_key`: Combines the payment address with a stake key to create a staked address. This is useful for delegating funds to a stake pool.\n\n3. **Build the Transaction:**\n   - `TransactionBuilder`: Initializes a transaction builder with the current blockchain context.\n   - `context.utxos(payment_address)`: Retrieves unspent transaction outputs (UTxOs) associated with the payment address.\n   - `builder.add_input(u)`: Adds each UTxO as an input to the transaction.\n\n4. **Sign the Transaction:**\n   - `builder.build_and_sign`: Builds the transaction and signs it using the provided signing key. The `change_address` is set to the combined address, ensuring any leftover funds are returned to the staked address.\n\n5. **Submit the Transaction:**\n   - `context.submit_tx(signed_tx)`: Submits the signed transaction to the Cardano network.\n   - `show_tx(signed_tx)`: Displays the transaction details, likely for logging or debugging purposes.\n\n### Command-Line Interface\n\n- `fire.Fire(main)`: Uses the `fire` library to create a command-line interface for the `main` function, allowing users to run the script with different parameters from the command line.\n\n### Summary\n\nThis script is designed to automate the process of moving funds from a wallet to a staked address on the Cardano blockchain. It retrieves necessary signing information, constructs a transaction using available UTxOs, signs the transaction, and submits it to the network. The use of utility functions and libraries like `pycardano` simplifies interaction with the blockchain, while `fire` provides an easy way to run the script with different configurations.", "file_path": "uada-contracts/uada/offchain/move_to_staked.py", "file": "move_to_staked.py"}
{"instruction": "Explain the following smart contract code:", "input": "from pathlib import Path\n\nimport click\nfrom pycardano import Address, Network, PaymentSigningKey, PaymentVerificationKey\n\nkeys_dir = Path(__file__).parent.parent.joinpath(\"keys\")\n\n\n@click.command()\n@click.argument(\"name\")\ndef main(name):\n    \"\"\"\n    Creates a testnet signing key, verification key, and address.\n    \"\"\"\n    keys_dir.mkdir(exist_ok=True)\n    skey_path = keys_dir.joinpath(f\"{name}.skey\")\n    vkey_path = keys_dir.joinpath(f\"{name}.vkey\")\n    addr_path = keys_dir.joinpath(f\"{name}.addr\")\n    testnet_addr_path = keys_dir.joinpath(f\"{name}.test_addr\")\n\n    if skey_path.exists():\n        raise FileExistsError(f\"signing key file ${skey_path} already exists\")\n    if vkey_path.exists():\n        raise FileExistsError(f\"verification key file ${vkey_path} already exists\")\n    if addr_path.exists():\n        raise FileExistsError(f\"address file ${addr_path} already exists\")\n\n    signing_key = PaymentSigningKey.generate()\n    signing_key.save(str(skey_path))\n\n    verification_key = PaymentVerificationKey.from_signing_key(signing_key)\n    verification_key.save(str(vkey_path))\n\n    address = Address(payment_part=verification_key.hash(), network=Network.MAINNET)\n    with open(addr_path, mode=\"w\") as f:\n        f.write(str(address))\n\n    testnet_address = Address(\n        payment_part=verification_key.hash(), network=Network.TESTNET\n    )\n    with open(testnet_addr_path, mode=\"w\") as f:\n        f.write(str(testnet_address))\n\n    print(f\"wrote signing key to: {skey_path}\")\n    print(f\"wrote verification key to: {vkey_path}\")\n    print(f\"wrote address to: {addr_path}\")\n    print(f\"wrote testnet address to: {testnet_addr_path}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "output": "This Python script is a command-line tool designed to generate a pair of cryptographic keys and corresponding addresses for the Cardano blockchain. It uses the `pycardano` library to handle key generation and address creation. Here's a detailed breakdown of the code:\n\n### Imports\n\n- **`Path` from `pathlib`**: Used for handling filesystem paths in a way that is compatible across different operating systems.\n- **`click`**: A package for creating command-line interfaces. It simplifies argument parsing and command execution.\n- **`pycardano`**: A library for interacting with the Cardano blockchain. It provides classes for creating addresses and handling keys.\n\n### Key Directory\n\n- **`keys_dir`**: This is a `Path` object pointing to a directory named `keys` located two levels up from the current file's directory. This is where the generated keys and addresses will be stored.\n\n### Main Function\n\nThe `main` function is decorated with `@click.command()` and `@click.argument(\"name\")`, which means it can be executed from the command line with a single argument, `name`. This argument is used to name the generated files.\n\n#### Functionality\n\n1. **Directory Creation**: \n   - `keys_dir.mkdir(exist_ok=True)`: Ensures that the `keys` directory exists. If it doesn't, it creates it. The `exist_ok=True` parameter prevents an error if the directory already exists.\n\n2. **File Paths**:\n   - Constructs paths for the signing key (`.skey`), verification key (`.vkey`), mainnet address (`.addr`), and testnet address (`.test_addr`) using the provided `name`.\n\n3. **File Existence Check**:\n   - Checks if any of the files already exist. If they do, it raises a `FileExistsError` to prevent overwriting existing keys or addresses.\n\n4. **Key Generation**:\n   - **Signing Key**: `PaymentSigningKey.generate()` creates a new signing key.\n   - **Save Signing Key**: `signing_key.save(str(skey_path))` saves the signing key to a file.\n\n5. **Verification Key**:\n   - **Derive Verification Key**: `PaymentVerificationKey.from_signing_key(signing_key)` derives the verification key from the signing key.\n   - **Save Verification Key**: `verification_key.save(str(vkey_path))` saves the verification key to a file.\n\n6. **Address Creation**:\n   - **Mainnet Address**: `Address(payment_part=verification_key.hash(), network=Network.MAINNET)` creates a mainnet address using the hash of the verification key.\n   - **Save Mainnet Address**: Writes the mainnet address to a file.\n\n7. **Testnet Address**:\n   - **Testnet Address**: `Address(payment_part=verification_key.hash(), network=Network.TESTNET)` creates a testnet address.\n   - **Save Testnet Address**: Writes the testnet address to a file.\n\n8. **Output**:\n   - Prints the paths of the generated files to the console, confirming their creation.\n\n### Execution\n\n- The script is designed to be run as a standalone program. The `if __name__ == \"__main__\":` block ensures that `main()` is called when the script is executed directly.\n\n### Summary\n\nThis script is a utility for generating cryptographic keys and addresses for the Cardano blockchain. It ensures that files are not overwritten and provides both mainnet and testnet addresses, which are essential for testing and deployment in different network environments. The use of `click` makes it user-friendly for command-line execution.", "file_path": "muesliswap-onchain-governance/muesliswap_onchain_governance/create_key_pair.py", "file": "create_key_pair.py"}
{"instruction": "Explain the following smart contract code:", "input": "import re\nfrom copy import copy\nfrom typing import Optional\nfrom enum import Enum\n\nfrom ..util import CompilingNodeTransformer\nfrom ..typed_ast import *\n\n\"\"\"\nReplaces empty dicts with UPLC constants of empty data pairs\n\"\"\"\n\n\nclass RewriteEmptyDicts(CompilingNodeTransformer):\n    step = \"Rewrite empty lists to uplc empty lists\"\n\n    def visit_Dict(self, node: TypedDict):\n        if node.keys or node.values:\n            return node\n        return RawPlutoExpr(typ=node.typ, expr=plt.MkNilPairData(plt.Unit()))\n\n    def visit_Constant(self, node: TypedConstant):\n        if node.value != {}:\n            return node\n        return RawPlutoExpr(typ=node.typ, expr=plt.MkNilPairData(plt.Unit()))\n", "output": "The provided code is a Python script that is part of a larger system for transforming and compiling smart contracts written in a high-level language into a lower-level representation suitable for execution on the Cardano blockchain. Specifically, this script is designed to handle the transformation of empty dictionary constructs into a form that can be understood by the Cardano blockchain's execution environment, known as UPLC (Untyped Plutus Core).\n\nHere's a detailed breakdown of the code:\n\n### Imports\n\n- **re**: Regular expressions module, though not used in the provided code snippet.\n- **copy**: Provides the `copy` function, which is also not used in this snippet.\n- **Optional**: A type hint from the `typing` module, not used here.\n- **Enum**: A base class for creating enumerations, not used in this snippet.\n- **CompilingNodeTransformer**: A custom class likely defined elsewhere in the project, used as a base class for transforming nodes in an abstract syntax tree (AST).\n- **Typed AST components**: These are imported from `..typed_ast`, which suggests a custom implementation of an abstract syntax tree with type annotations.\n\n### Class: `RewriteEmptyDicts`\n\nThis class inherits from `CompilingNodeTransformer`, indicating that it is designed to traverse and transform nodes in an AST.\n\n- **Purpose**: The class is specifically designed to replace empty dictionary constructs in the AST with a UPLC representation of empty data pairs. This is necessary because the execution environment on Cardano (UPLC) does not natively understand high-level constructs like Python dictionaries.\n\n- **`step` attribute**: This is a descriptive string that likely serves as a label or identifier for this transformation step in a larger compilation process.\n\n### Methods\n\n#### `visit_Dict(self, node: TypedDict)`\n\n- **Purpose**: This method is called when the transformer encounters a dictionary node in the AST.\n- **Logic**:\n  - It checks if the dictionary (`node`) has any keys or values.\n  - If the dictionary is not empty (i.e., it has keys or values), it returns the node unchanged.\n  - If the dictionary is empty, it transforms the node into a `RawPlutoExpr` with a UPLC expression representing an empty pair of data (`plt.MkNilPairData(plt.Unit())`).\n\n#### `visit_Constant(self, node: TypedConstant)`\n\n- **Purpose**: This method is called when the transformer encounters a constant node in the AST.\n- **Logic**:\n  - It checks if the constant value is an empty dictionary (`{}`).\n  - If the constant is not an empty dictionary, it returns the node unchanged.\n  - If the constant is an empty dictionary, it transforms the node into a `RawPlutoExpr` with the same UPLC expression for an empty pair of data.\n\n### UPLC Representation\n\n- **`RawPlutoExpr`**: This is likely a class that wraps a UPLC expression, allowing it to be used in the transformed AST.\n- **`plt.MkNilPairData(plt.Unit())`**: This is a UPLC expression that represents an empty pair of data. `plt` is presumably a module or namespace that provides functions and constants for constructing UPLC expressions.\n\n### Summary\n\nThe `RewriteEmptyDicts` class is a transformation utility that ensures empty dictionaries in the high-level smart contract code are correctly represented in the UPLC format. This transformation is crucial for the correct execution of smart contracts on the Cardano blockchain, as it bridges the gap between high-level constructs and the low-level execution environment.", "file_path": "opshin/opshin/rewrite/rewrite_empty_dicts.py", "file": "rewrite_empty_dicts.py"}
{"instruction": "Explain the following smart contract code:", "input": "from typing import Optional\n\nimport pycardano\n\nfrom muesliswap_onchain_governance.api.db_models import sqlite_db\nfrom opshin.prelude import Token\n\n\ndef parse_merged_tally_votes(\n    weights: str, indices: str, proposals: str, proposal_indices: str\n):\n    weights = weights.split(\";\")\n    indices = indices.split(\";\")\n    proposals = proposals.split(\";\")\n    proposal_indices = proposal_indices.split(\";\")\n    votes = [{} for _ in range(len(weights))]\n    for weight, index in zip(weights, indices):\n        votes[int(index)][\"weight\"] = int(weight)\n    for proposal, proposal_index in zip(proposals, proposal_indices):\n        votes[int(proposal_index)][\"proposal\"] = pycardano.RawPlutusData.from_cbor(\n            proposal\n        ).to_dict()\n    return votes\n\n\ndef query_tallies(closed: bool = True, open: bool = True):\n    \"\"\"\n    Query tallies from the database.\n    :param closed: Show closed tallies.\n    :param open: Show open tallies.\n    :return:\n    \"\"\"\n    if open and closed:\n        dateconstraint = \"\"\n    elif open:\n        dateconstraint = (\n            \"and (tp.end_time is NULL or DATETIME(tp.end_time) > DATETIME('now'))\"\n        )\n    elif closed:\n        dateconstraint = \"and DATETIME(tp.end_time) <= DATETIME('now')\"\n    else:\n        return []\n    cursor = sqlite_db.execute_sql(\n        \"\"\"\n        with merged_tally_votes as (\n          select\n          sum(tw.weight) as total_weight,\n          group_concat(tw.weight, ';') as weights,\n          group_concat(tw.\"index\", ';') as indices,\n          tw.tally_state_id\n          from tallyweights tw\n          group by tw.tally_state_id\n        ),\n        merged_tally_proposals as (\n            select\n            tp.tally_params_id,\n            group_concat(hex(d.data), ';') as proposals,\n            group_concat(tp.\"index\", ';') as indices\n            from tallyproposals tp\n            join datum d on tp.proposal_id = d.id\n            group by tp.tally_params_id\n        )\n        \n        SELECT \n        tp.quorum,\n        tp.end_time,\n        tp.proposal_id,\n        tally_auth_nft.policy_id,\n        tally_auth_nft.asset_name,\n        tp.staking_vote_nft_policy,\n        staking_address.address_raw,\n        gov_token.policy_id,\n        gov_token.asset_name,\n        tp.vault_ft_policy,\n        mtv.total_weight,\n        mtv.weights,\n        mtv.indices,\n        mtp.proposals,\n        mtp.indices,\n        tx_out.transaction_hash,\n        tx_out.output_index\n        FROM tallystate ts\n        join tallyparams tp on ts.tally_params_id = tp.id\n        join merged_tally_votes mtv on ts.id = mtv.tally_state_id\n        join merged_tally_proposals mtp on tp.id = mtp.tally_params_id\n        join transactionoutput tx_out on ts.transaction_output_id = tx_out.id\n        join token tally_auth_nft on tp.tally_auth_nft_id = tally_auth_nft.id\n        join address staking_address on tp.staking_address_id = staking_address.id\n        join token gov_token on tp.governance_token_id = gov_token.id\n        where tx_out.spent_in_block_id is NULL\n        \"\"\"\n        + dateconstraint\n        + \"\"\"\n        order by tp.end_time asc nulls first \n        \"\"\"\n    )\n    results = []\n    for row in cursor.fetchall():\n        results.append(\n            {\n                \"quorum\": row[0],\n                \"end_time\": row[1],\n                \"proposal_id\": row[2],\n                \"tally_auth_nft\": {\n                    \"policy_id\": row[3],\n                    \"asset_name\": row[4],\n                },\n                \"staking_vote_nft_policy_id\": row[5],\n                \"staking_address\": row[6],\n                \"gov_token\": {\n                    \"policy_id\": row[7],\n                    \"asset_name\": row[8],\n                },\n                \"vault_ft_policy_id\": row[9],\n                \"total_weight\": row[10],\n                \"votes\": parse_merged_tally_votes(row[11], row[12], row[13], row[14]),\n                \"transaction_output\": {\n                    \"transaction_hash\": row[15],\n                    \"output_index\": row[16],\n                },\n            }\n        )\n    return results\n\n\ndef query_tally_details_by_auth_nft_proposal_id(auth_nft: str, proposal_id: int):\n    cursor = sqlite_db.execute_sql(\n        \"\"\"\n    with merged_tally_votes as (\n        select\n        sum(tw.weight) as total_weight,\n        group_concat(tw.weight, ';') as weights,\n        group_concat(tw.\"index\", ';') as indices,\n        tw.tally_state_id\n        from tallyweights tw\n        group by tw.tally_state_id\n    ),\n    merged_tally_proposals as (\n        select\n        tp.tally_params_id,\n        group_concat(hex(d.data), ';') as proposals,\n        group_concat(tp.\"index\", ';') as indices\n        from tallyproposals tp\n        join datum d on tp.proposal_id = d.id\n        group by tp.tally_params_id\n    ),\n    merged_tally_creation_participants as (\n        select\n        tc.next_tally_state_id,\n        group_concat(address.address_raw, ';') as addresses\n        from tallycreation tc\n        join tallycreationparticipants tcp on tc.id = tcp.tally_creation_id\n        join address on tcp.address_id = address.id\n        group by tc.next_tally_state_id\n    )\n    \n\n    SELECT\n    tp.quorum,\n    tp.end_time,\n    tp.proposal_id,\n    tally_auth_nft.policy_id,\n    tally_auth_nft.asset_name,\n    tp.staking_vote_nft_policy,\n    staking_address.address_raw,\n    gov_token.policy_id,\n    gov_token.asset_name,\n    tp.vault_ft_policy,\n    mtv.total_weight,\n    mtv.weights,\n    mtv.indices,\n    mtp.proposals,\n    mtp.indices,\n    tcblk.slot,\n    mtcps.addresses,\n    tx_out.transaction_hash,\n    tx_out.output_index\n    FROM tallystate ts\n    join tallyparams tp on ts.tally_params_id = tp.id\n    join merged_tally_votes mtv on ts.id = mtv.tally_state_id\n    join merged_tally_proposals mtp on tp.id = mtp.tally_params_id\n    join transactionoutput tx_out on ts.transaction_output_id = tx_out.id\n    join token tally_auth_nft on tp.tally_auth_nft_id = tally_auth_nft.id\n    join address staking_address on tp.staking_address_id = staking_address.id\n    join token gov_token on tp.governance_token_id = gov_token.id\n    join tallystate tcts on tcts.tally_params_id = tp.id\n    join tallycreation tc on tc.next_tally_state_id = tcts.id\n    join \"transaction\" tctx on tc.transaction_id = tctx.id\n    join \"block\" tcblk on tcblk.id = tctx.block_id\n    join merged_tally_creation_participants mtcps on tc.next_tally_state_id = mtcps.next_tally_state_id\n    where tx_out.spent_in_block_id is NULL\n    and tally_auth_nft.policy_id = ?\n    and tally_auth_nft.asset_name = ?\n    and tp.proposal_id = ?\n    \"\"\",\n        (*auth_nft.split(\".\"), proposal_id),\n    )\n    results = []\n    for row in cursor.fetchall():\n        results.append(\n            {\n                \"quorum\": row[0],\n                \"end_time\": row[1],\n                \"proposal_id\": row[2],\n                \"tally_auth_nft\": {\n                    \"policy_id\": row[3],\n                    \"asset_name\": row[4],\n                },\n                \"staking_vote_nft_policy_id\": row[5],\n                \"staking_address\": row[6],\n                \"gov_token\": {\n                    \"policy_id\": row[7],\n                    \"asset_name\": row[8],\n                },\n                \"vault_ft_policy_id\": row[9],\n                \"total_weight\": row[10],\n                \"votes\": parse_merged_tally_votes(row[11], row[12], row[13], row[14]),\n                \"creation_slot\": row[15],\n                \"creators\": row[16].split(\";\"),\n                \"transaction_output\": {\n                    \"transaction_hash\": row[17],\n                    \"output_index\": row[18],\n                },\n            }\n        )\n    return results\n\n\ndef query_tally_auth_nft_proposal_id(transaction_hash: str, transaction_index: int):\n    \"\"\"\n    Obtain the auth nft and proposal id for a tally that once had a given transaction output\n    :param transaction_hash:\n    :param transaction_index:\n    :return: (auth_nft, proposal_id) or None if the transaction output is not part of a tally\n    \"\"\"\n    cursor = sqlite_db.execute_sql(\n        \"\"\"\n    SELECT\n    tk.policy_id,\n    tk.asset_name,\n    tp.proposal_id\n    FROM tallystate ts\n    join tallyparams tp on ts.tally_params_id = tp.id\n    join transactionoutput tx_out on ts.transaction_output_id = tx_out.id\n    join token tk on tp.tally_auth_nft_id = tk.id\n    where tx_out.transaction_hash = ?\n    and tx_out.output_index = ?\n    \"\"\",\n        (transaction_hash, transaction_index),\n    )\n    for row in cursor.fetchall():\n        return (Token(bytes.fromhex(row[0]), bytes.fromhex(row[1])), row[2])\n    return None\n\n\ndef query_tally_details_by_tx_out(transaction_hash: str, transaction_index: int):\n    \"\"\"\n    Returns the latest tally details for a tally that has at some point had a transaction output with the given hash and index.\n    :param transaction_hash:\n    :param transaction_index:\n    :return:\n    \"\"\"\n    auth_nft_proposal_id = query_tally_auth_nft_proposal_id(\n        transaction_hash, transaction_index\n    )\n    if auth_nft_proposal_id is None:\n        return []\n    return query_tally_details_by_auth_nft_proposal_id(*auth_nft_proposal_id)\n\n\ndef query_tally_details_by_auth_nft_proposal_id_with_user_vote(\n    auth_nft: str, proposal_id: int, user_address: str\n):\n    cursor = sqlite_db.execute_sql(\n        \"\"\"\n    with merged_tally_votes as (\n        select\n        sum(tw.weight) as total_weight,\n        group_concat(tw.weight, ';') as weights,\n        group_concat(tw.\"index\", ';') as indices,\n        tw.tally_state_id\n        from tallyweights tw\n        group by tw.tally_state_id\n    ),\n    merged_tally_proposals as (\n        select\n        tp.tally_params_id,\n        group_concat(hex(d.data), ';') as proposals,\n        group_concat(tp.\"index\", ';') as indices\n        from tallyproposals tp\n        join datum d on tp.proposal_id = d.id\n        group by tp.tally_params_id\n    ),\n    merged_tally_creation_participants as (\n        select\n        tc.next_tally_state_id,\n        group_concat(address.address_raw, ';') as addresses\n        from tallycreation tc\n        join tallycreationparticipants tcp on tc.id = tcp.tally_creation_id\n        join address on tcp.address_id = address.id\n        group by tc.next_tally_state_id\n    ),\n    user_staking_participation as (\n        select\n        sp.tally_auth_nft_id,\n        sp.proposal_id,\n        sp.weight,\n        sp.proposal_index,\n        staking_blk.slot\n        from stakingparticipation sp\n        join stakingparticipationinstaking spis on sp.id = spis.participation_id\n        join stakingstate ss on spis.staking_state_id = ss.id\n        join stakingparams sparams on ss.staking_params_id = sparams.id\n        join address sa on sa.id = sparams.owner_id\n        join transactionoutput staking_tx_out on ss.transaction_output_id = staking_tx_out.id\n        join \"transaction\" staking_tx on staking_tx.id = staking_tx_out.transaction_id\n        join \"block\" staking_blk on staking_blk.id = staking_tx.block_id\n        where sa.address_raw = ?\n    )\n\n\n    SELECT\n    tp.quorum,\n    tp.end_time,\n    tp.proposal_id,\n    tally_auth_nft.policy_id,\n    tally_auth_nft.asset_name,\n    tp.staking_vote_nft_policy,\n    staking_address.address_raw,\n    gov_token.policy_id,\n    gov_token.asset_name,\n    tp.vault_ft_policy,\n    mtv.total_weight,\n    mtv.weights,\n    mtv.indices,\n    mtp.proposals,\n    mtp.indices,\n    tcblk.slot,\n    mtcps.addresses,\n    tx_out.transaction_hash,\n    tx_out.output_index,\n    spart.weight,\n    spart.proposal_index\n    -- get the tally details\n    FROM tallystate ts\n    join tallyparams tp on ts.tally_params_id = tp.id\n    join merged_tally_votes mtv on ts.id = mtv.tally_state_id\n    join merged_tally_proposals mtp on tp.id = mtp.tally_params_id\n    join transactionoutput tx_out on ts.transaction_output_id = tx_out.id\n    join token tally_auth_nft on tp.tally_auth_nft_id = tally_auth_nft.id\n    join address staking_address on tp.staking_address_id = staking_address.id\n    join token gov_token on tp.governance_token_id = gov_token.id\n    join tallystate tcts on tcts.tally_params_id = tp.id\n    join tallycreation tc on tc.next_tally_state_id = tcts.id\n    join \"transaction\" tctx on tc.transaction_id = tctx.id\n    join \"block\" tcblk on tcblk.id = tctx.block_id\n    join merged_tally_creation_participants mtcps on tc.next_tally_state_id = mtcps.next_tally_state_id\n    left outer join user_staking_participation spart on tp.tally_auth_nft_id = spart.tally_auth_nft_id and tp.proposal_id = spart.proposal_id\n    -- get last vote on this tally\n    join tallyvote tv on tv.next_tally_state_id = ts.id\n    join \"transaction\" last_vote_tx on tv.transaction_id = last_vote_tx.id\n    join \"block\" last_vote_blk on last_vote_blk.id = last_vote_tx.block_id\n    where tx_out.spent_in_block_id is NULL\n    and tally_auth_nft.policy_id = ?\n    and tally_auth_nft.asset_name = ?\n    and tp.proposal_id = ?\n    and spart.slot <= last_vote_blk.slot\n    order by spart.slot desc\n    limit 1\n    \"\"\",\n        (\n            user_address,\n            *auth_nft.split(\".\"),\n            proposal_id,\n        ),\n    )\n    results = []\n    for row in cursor.fetchall():\n        results.append(\n            {\n                \"quorum\": row[0],\n                \"end_time\": row[1],\n                \"proposal_id\": row[2],\n                \"tally_auth_nft\": {\n                    \"policy_id\": row[3],\n                    \"asset_name\": row[4],\n                },\n                \"staking_vote_nft_policy_id\": row[5],\n                \"staking_address\": row[6],\n                \"gov_token\": {\n                    \"policy_id\": row[7],\n                    \"asset_name\": row[8],\n                },\n                \"vault_ft_policy_id\": row[9],\n                \"total_weight\": row[10],\n                \"votes\": parse_merged_tally_votes(row[11], row[12], row[13], row[14]),\n                \"creation_slot\": row[15],\n                \"creators\": row[16].split(\";\"),\n                \"transaction_output\": {\n                    \"transaction_hash\": row[17],\n                    \"output_index\": row[18],\n                },\n                \"user_vote\": {\"weight\": row[19], \"proposal_index\": row[20]},\n            }\n        )\n    return results\n\n\ndef query_tally_details_by_tx_out_with_user_vote(\n    transaction_hash: str, transaction_index: int, user_address: str\n):\n    \"\"\"\n    Returns the latest tally details for a tally that has at some point had a transaction output with the given hash and index.\n    :param transaction_hash:\n    :param transaction_index:\n    :return:\n    \"\"\"\n    auth_nft_proposal_id = query_tally_auth_nft_proposal_id(\n        transaction_hash, transaction_index\n    )\n    if auth_nft_proposal_id is None:\n        return []\n    return query_tally_details_by_auth_nft_proposal_id_with_user_vote(\n        *auth_nft_proposal_id, user_address\n    )\n\n\ndef query_all_user_votes_for_tally(auth_nft: str, proposal_id: int):\n    last_vote_slot, tally_state_id = sqlite_db.execute_sql(\n        \"\"\"\n    SELECT\n    last_vote_blk.slot,\n    ts.id\n    -- get the tally details\n    FROM tallystate ts\n    join tallyparams tp on ts.tally_params_id = tp.id\n    join transactionoutput tx_out on ts.transaction_output_id = tx_out.id\n    join token tally_auth_nft on tp.tally_auth_nft_id = tally_auth_nft.id\n    join tallystate tcts on tcts.tally_params_id = tp.id\n    -- get last vote on this tally\n    join tallyvote tv on tv.next_tally_state_id = ts.id\n    join \"transaction\" last_vote_tx on tv.transaction_id = last_vote_tx.id\n    join \"block\" last_vote_blk on last_vote_blk.id = last_vote_tx.block_id\n    where tx_out.spent_in_block_id is NULL\n    and tally_auth_nft.policy_id = ?\n    and tally_auth_nft.asset_name = ?\n    and tp.proposal_id = ?\n    \"\"\",\n        (\n            *auth_nft.split(\".\"),\n            proposal_id,\n        ),\n    ).fetchall()[0]\n    cursor = sqlite_db.execute_sql(\n        \"\"\"\n    with latest_staking_state_before_vote_per_user as (\n        select\n        max(blk.slot) as slot,\n        sp.owner_id\n        from stakingstate ss\n        join stakingparams sp on ss.staking_params_id = sp.id\n        join transactionoutput tx_out on ss.transaction_output_id = tx_out.id\n        join \"transaction\" tx on tx_out.transaction_id = tx.id\n        join \"block\" blk on tx.block_id = blk.id\n        where blk.slot <= ?\n        group by sp.owner_id\n    )\n\n\n    SELECT\n    sa.address_raw,\n    sp.proposal_index,\n    sp.weight\n    FROM tallystate ts\n    join tallyparams tp on ts.tally_params_id = tp.id\n    join stakingparticipation sp on sp.tally_auth_nft_id = tp.tally_auth_nft_id and sp.proposal_id = tp.proposal_id\n    join stakingparticipationinstaking spis on sp.id = spis.participation_id\n    join stakingstate ss on spis.staking_state_id = ss.id\n    join stakingparams sparams on ss.staking_params_id = sparams.id\n    join address sa on sa.id = sparams.owner_id\n    join transactionoutput tx_out on ss.transaction_output_id = tx_out.id\n    join \"transaction\" tx on tx_out.transaction_id = tx.id\n    join \"block\" blk on tx.block_id = blk.id\n    join latest_staking_state_before_vote_per_user ls on ls.owner_id = sa.id\n    where ts.id = ?\n    and blk.slot = ls.slot\n    \"\"\",\n        (\n            last_vote_slot,\n            tally_state_id,\n        ),\n    )\n    results = []\n    for row in cursor.fetchall():\n        results.append(\n            {\n                \"address\": row[0],\n                \"proposal_index\": row[1],\n                \"weight\": row[2],\n            }\n        )\n    return results\n\n\nif __name__ == \"__main__\":\n    print(query_tallies(True, False))\n    print(query_tallies(False, True))\n    print(query_tallies(True, True))\n    print(query_tallies(False, False))\n    print(\n        query_tally_details_by_auth_nft_proposal_id(\n            \"471b0b6f3fab69f9c6e8c1c1389782a410a8689d97e22a22ac24b30f.bc0a47f8459162152c33913f9d4e50d2340459ce4b6197761967d64368e0e50c\",\n            3,\n        )\n    )\n    print(\n        query_tally_details_by_tx_out(\n            \"03b0238d4418cba3dde0f6d2f92495f16ee641fd154d1b93bdb4155a7afdd93d\", 0\n        )\n    )\n    print(\n        query_tally_details_by_auth_nft_proposal_id_with_user_vote(\n            \"471b0b6f3fab69f9c6e8c1c1389782a410a8689d97e22a22ac24b30f.bc0a47f8459162152c33913f9d4e50d2340459ce4b6197761967d64368e0e50c\",\n            1,\n            \"607195078bd15707f7a74581a317c41c14be16ffe7ce7dc0f22b039713\",\n        )\n    )\n    print(\n        query_all_user_votes_for_tally(\n            \"471b0b6f3fab69f9c6e8c1c1389782a410a8689d97e22a22ac24b30f.bc0a47f8459162152c33913f9d4e50d2340459ce4b6197761967d64368e0e50c\",\n            2,\n        )\n    )\n", "output": "This Cardano smart contract code is part of the MuesliSwap on-chain governance system. It is written in Python and interacts with a SQLite database to manage and query governance tallies. The code provides several functions to query and process tally data, which is essential for on-chain governance mechanisms. Let's break down the key components and functions:\n\n### Key Components\n\n1. **Imports**:\n   - `pycardano`: A library for handling Cardano-specific data types.\n   - `sqlite_db`: A database connection object for executing SQL queries.\n   - `Token`: A data type from the `opshin.prelude` module, likely representing a Cardano token.\n\n2. **Data Parsing**:\n   - `parse_merged_tally_votes`: This function takes strings representing weights, indices, proposals, and proposal indices, splits them into lists, and constructs a list of dictionaries representing votes. Each vote dictionary contains a weight and a proposal, which is parsed from CBOR (Concise Binary Object Representation) format using `pycardano`.\n\n### Functions\n\n1. **`query_tallies`**:\n   - This function queries the database for tallies, with options to filter by open or closed status.\n   - It constructs a SQL query with optional date constraints to filter tallies based on their end time.\n   - The query retrieves various details about each tally, including quorum, end time, proposal ID, associated tokens, and voting data.\n   - The results are processed into a list of dictionaries, each representing a tally with its details and parsed votes.\n\n2. **`query_tally_details_by_auth_nft_proposal_id`**:\n   - This function retrieves detailed information about a specific tally identified by an authorization NFT and proposal ID.\n   - It uses SQL queries to gather data about the tally, including its creation participants and the slot in which it was created.\n   - The results are returned as a list of dictionaries with detailed tally information.\n\n3. **`query_tally_auth_nft_proposal_id`**:\n   - This function retrieves the authorization NFT and proposal ID for a tally associated with a specific transaction output.\n   - It executes a SQL query to find the relevant tally state and returns the NFT and proposal ID if found.\n\n4. **`query_tally_details_by_tx_out`**:\n   - This function retrieves the latest tally details for a tally associated with a specific transaction output.\n   - It first calls `query_tally_auth_nft_proposal_id` to get the auth NFT and proposal ID, then uses `query_tally_details_by_auth_nft_proposal_id` to get the details.\n\n5. **`query_tally_details_by_auth_nft_proposal_id_with_user_vote`**:\n   - This function extends `query_tally_details_by_auth_nft_proposal_id` by including the user's vote details.\n   - It uses a SQL query to join user staking participation data, allowing it to return the user's vote weight and proposal index.\n\n6. **`query_tally_details_by_tx_out_with_user_vote`**:\n   - Similar to `query_tally_details_by_tx_out`, but includes user vote details by calling `query_tally_details_by_auth_nft_proposal_id_with_user_vote`.\n\n7. **`query_all_user_votes_for_tally`**:\n   - This function retrieves all user votes for a specific tally identified by an auth NFT and proposal ID.\n   - It uses SQL queries to find the latest staking state before the last vote and returns a list of user votes with their addresses, proposal indices, and weights.\n\n### Main Execution\n\nThe `__main__` block demonstrates how to use these functions to query various tally details. It includes examples of querying tallies with different open/closed statuses, retrieving details by auth NFT and proposal ID, and getting user votes.\n\n### Summary\n\nThis code is a comprehensive implementation for querying and managing on-chain governance tallies in a Cardano-based system. It leverages SQL queries to interact with a database, processes data into Python dictionaries, and provides functions to retrieve detailed information about tallies and user votes. This setup is crucial for enabling decentralized governance mechanisms on the Cardano blockchain.", "file_path": "muesliswap-onchain-governance/muesliswap_onchain_governance/api/db_queries/tally.py", "file": "tally.py"}
{"instruction": "Explain the following smart contract code:", "input": "-- SPDX-License-Identifier: BUSL-1.1\n\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Indigo.Contracts.Governance.Poll.Common\n  ( VoteOption (Yes, No),\n    PollStatus (VoteCount, nYes, nNo),\n    PollShard (PollShard, psId, psStatus, psEndTime, psManagerAddress),\n    PollManager\n      ( PollManager,\n        pId,\n        pOwner,\n        pContent,\n        pStatus,\n        pEndTime,\n        pCreatedShards,\n        pTalliedShards,\n        pTotalShards,\n        pProposeEndTime,\n        pExpirationTime,\n        pProtocolVersion\n      ),\n    DistributionSchedule\n      ( MkDistributionSchedule,\n        \u03bbM_spd,\n        z_spd,\n        \u03bbM_lpd,\n        z_lpd,\n        \u03bbM_ipd,\n        z_ipd,\n        \u03bbM_tv,\n        z_tv\n      ),\n    PollParams (..),\n    PollManagerParams (..),\n    PollRedeemer (Vote, MergeShards),\n    PollManagerRedeemer (EndPoll, CreateShards, MergeShardsManager),\n    PollScript,\n    PollManagerScript,\n    vote,\n    pollPassQuorum,\n    q,\n    electorate,\n    ve,\n    vm,\n    pollTokenName,\n  )\nwhere\n\nimport Data.Aeson (FromJSON, ToJSON)\nimport Data.OpenApi qualified as OpenApi\nimport GHC.Generics (Generic)\nimport Indigo.Contracts.Governance.Gov.Common (ProposalContent)\nimport Indigo.Data.Decimal qualified as OCD\nimport Indigo.Utils.Helpers qualified as Helpers\nimport Indigo.Utils.Spooky qualified as Spooky\nimport Ledger qualified\nimport Ledger.Typed.Scripts qualified as TScripts\nimport Ledger.Value qualified as Value\nimport PlutusTx qualified\nimport PlutusTx.Builtins (divideInteger)\nimport PlutusTx.Prelude\nimport PlutusTx.Sqrt (Sqrt (Approximately, Exactly, Imaginary), isqrt)\nimport Prelude qualified as P\n\npollTokenName :: Value.TokenName\npollTokenName = Value.TokenName \"poll_token\"\n\ndata VoteOption = Yes | No\n  deriving (P.Show, Generic, ToJSON, FromJSON, P.Eq)\n\nPlutusTx.makeLift ''VoteOption\nPlutusTx.makeIsDataIndexed ''VoteOption [('Yes, 0), ('No, 1)]\n\ndata PollStatus = VoteCount {nYes :: Integer, nNo :: Integer}\n  deriving (P.Show, Generic, ToJSON, FromJSON, P.Eq)\n\nPlutusTx.makeLift ''PollStatus\nPlutusTx.makeIsDataIndexed ''PollStatus [('VoteCount, 0)]\n\ninstance Eq PollStatus where\n  {-# INLINEABLE (==) #-}\n  (VoteCount y1 n1) == (VoteCount y2 n2) =\n    y1 == y2 && n1 == n2\n\ninstance Semigroup PollStatus where\n  {-# INLINEABLE (<>) #-}\n  ps1 <> ps2 =\n    VoteCount\n      { nYes = nYes ps1 + nYes ps2,\n        nNo = nNo ps1 + nNo ps2\n      }\n\ninstance Monoid PollStatus where\n  {-# INLINEABLE mempty #-}\n  mempty = VoteCount {nYes = 0, nNo = 0}\n\ndata PollManager = PollManager\n  { pId :: Integer,\n    pOwner :: Ledger.PaymentPubKeyHash,\n    pContent :: ProposalContent,\n    pStatus :: PollStatus,\n    pEndTime :: Ledger.POSIXTime,\n    -- number of shards already created\n    pCreatedShards :: Integer,\n    -- number of shards merged into PollManager\n    pTalliedShards :: Integer,\n    -- total number of shards\n    pTotalShards :: Integer,\n    pProposeEndTime :: Ledger.POSIXTime,\n    pExpirationTime :: Ledger.POSIXTime,\n    pProtocolVersion :: Integer\n  }\n\nPlutusTx.makeLift ''PollManager\nPlutusTx.makeIsDataIndexed ''PollManager [('PollManager, 0)]\n\ndata PollShard = PollShard\n  { psId :: Integer,\n    psStatus :: PollStatus,\n    psEndTime :: Ledger.POSIXTime,\n    -- | poll manager validator address\n    psManagerAddress :: Spooky.Address\n  }\n\nPlutusTx.makeLift ''PollShard\nPlutusTx.makeIsDataIndexed ''PollShard [('PollShard, 1)]\n\n-- |  `\u03bbM` is the distribution map of the vesting schedule\n--    `z` is the delay of a distribution schedule.\n--    `\u03bbM` values are representing a map using the list since\n--    all the values in the map have the same spaces.\ndata DistributionSchedule = MkDistributionSchedule\n  { \u03bbM_spd :: [OCD.OnChainDecimal],\n    z_spd :: Integer,\n    \u03bbM_lpd :: [OCD.OnChainDecimal],\n    z_lpd :: Integer,\n    \u03bbM_ipd :: [OCD.OnChainDecimal],\n    z_ipd :: Integer,\n    \u03bbM_tv :: OCD.OnChainDecimal,\n    z_tv :: Integer\n  }\n  deriving (Generic, P.Show, ToJSON, FromJSON, P.Eq, P.Ord, OpenApi.ToSchema)\n\nPlutusTx.makeLift ''DistributionSchedule\nPlutusTx.makeIsDataIndexed ''DistributionSchedule [('MkDistributionSchedule, 0)]\n\ndata PollParams = PollParams\n  { pollToken :: Spooky.AssetClass,\n    stakingToken :: Spooky.AssetClass,\n    indyAsset :: Spooky.AssetClass,\n    stakingValHash :: Spooky.ValidatorHash\n  }\n  deriving (Generic, P.Show, ToJSON, FromJSON, P.Eq, P.Ord, OpenApi.ToSchema)\n\nPlutusTx.makeLift ''PollParams\nPlutusTx.makeIsDataIndexed ''PollParams [('PollParams, 0)]\n\ndata PollManagerParams = PollManagerParams\n  { govNFT :: Value.AssetClass,\n    pollToken :: Value.AssetClass,\n    upgradeToken :: Value.AssetClass,\n    stakingToken :: Value.AssetClass,\n    indyAsset :: Value.AssetClass,\n    govExecuteValHash :: Ledger.ValidatorHash,\n    stakingValHash :: Ledger.ValidatorHash,\n    pBiasTime :: Ledger.POSIXTime,\n    -- | poll shards validator hash\n    shardsValHash :: Ledger.ValidatorHash,\n    treasuryValHash :: Ledger.ValidatorHash,\n    -- | This is the ITD for the electorate calculation.\n    initialIndyDistribution :: Integer,\n    -- | This is the t parameter in the electorate calculation.\n    totalINDYSupply :: Integer,\n    -- | distribution maps for each vesting schedule\n    distributionSchedule :: DistributionSchedule\n  }\n  deriving (Generic, P.Show, ToJSON, FromJSON, P.Eq, P.Ord, OpenApi.ToSchema)\n\nPlutusTx.makeLift ''PollManagerParams\nPlutusTx.makeIsDataIndexed ''PollManagerParams [('PollManagerParams, 0)]\n\ndata PollRedeemer\n  = Vote VoteOption\n  | MergeShards Ledger.POSIXTime Spooky.TxOutRef\n\nPlutusTx.makeLift ''PollRedeemer\nPlutusTx.makeIsDataIndexed ''PollRedeemer [('Vote, 0), ('MergeShards, 1)]\n\ndata PollManagerRedeemer\n  = EndPoll Ledger.POSIXTime\n  | CreateShards Ledger.POSIXTime\n  | MergeShardsManager Ledger.POSIXTime\n\nPlutusTx.makeLift ''PollManagerRedeemer\nPlutusTx.makeIsDataIndexed\n  ''PollManagerRedeemer\n  [('EndPoll, 0), ('CreateShards, 1), ('MergeShardsManager, 2)]\n\n{-# INLINEABLE vote #-}\nvote :: PollShard -> VoteOption -> Integer -> PollShard\nvote poll@PollShard {psStatus} Yes amt =\n  poll {psStatus = psStatus {nYes = nYes psStatus + amt}}\nvote poll@PollShard {psStatus} No amt =\n  poll {psStatus = psStatus {nNo = nNo psStatus + amt}}\n\n-- | Check for the quorum pass/fail.\n--   The 'q' calculation is not accurate since it uses fixed number of decimals.\n--   There can be multiple discrepancies.\n--   One of them happens when the `q` is around 0.\n--   This happens when the votes are the same or nearly the same.\n--   In these cases the quorum nondeterministically passes/fails.\n--   Because of this, the threshold for the quorum to pass\n--   is set to be slightly greater than 0.\n--\n--   The semantics of this value are that the `q` is biased towards the failing\n--   in case of yes/no similarities in voting.\n--   Additionaly, this tells that a higher significance of yes votes is expected\n--   to pass the quorum.\n{-# INLINEABLE pollPassQuorum #-}\npollPassQuorum ::\n  PollStatus ->\n  Ledger.POSIXTime ->\n  Integer ->\n  Integer ->\n  Ledger.POSIXTime ->\n  DistributionSchedule ->\n  Bool\npollPassQuorum\n  pStatus\n  protocolStartTime\n  indyAtLaunch\n  indyTotalSupply\n  currentTime\n  distributionSchedule =\n    q\n      pStatus\n      protocolStartTime\n      indyAtLaunch\n      indyTotalSupply\n      currentTime\n      distributionSchedule\n      > OCD.OnChainDecimal 50_000 -- 0.05\n\n-- |  Calculates the core equation for the adaptive quorum.\n--    Ref: https://drive.google.com/uc?id=12K0tzNAy0Ef1OQBRE6unofAH-szIVB1a\n{-# INLINEABLE q #-}\nq ::\n  PollStatus ->\n  Ledger.POSIXTime ->\n  Integer ->\n  Integer ->\n  Ledger.POSIXTime ->\n  DistributionSchedule ->\n  OCD.OnChainDecimal\nq\n  VoteCount {nYes, nNo}\n  protocolStartTime\n  indyAtLaunch\n  indyTotalSupply\n  currentTime\n  distributionSchedule =\n    if nYes + nNo == 0\n      then 0\n      else\n        let e =\n              electorate\n                indyAtLaunch\n                indyTotalSupply\n                protocolStartTime\n                currentTime\n                distributionSchedule\n         in ( OCD.OnChainDecimal (nYes * OCD.decimalUnit)\n                `OCD.divide` sqrtRes (OCD.OnChainDecimal (e * OCD.decimalUnit))\n            )\n              - ( OCD.OnChainDecimal (nNo * OCD.decimalUnit)\n                    `OCD.divide` sqrtRes\n                      (OCD.OnChainDecimal ((nYes + nNo) * OCD.decimalUnit))\n                )\n    where\n      sqrtRes :: OCD.OnChainDecimal -> OCD.OnChainDecimal\n      sqrtRes (OCD.OnChainDecimal a) = case isqrt a of\n        Imaginary -> error ()\n        Exactly n -> OCD.OnChainDecimal (n * 1_000)\n        Approximately n -> OCD.OnChainDecimal (n * 1_000)\n\n-- |  The electorate calculation.\n--    Ref: https://drive.google.com/uc?id=12K0tzNAy0Ef1OQBRE6unofAH-szIVB1a\n{-# INLINEABLE electorate #-}\nelectorate ::\n  -- | amount of INDY distributed at protocol launch\n  Integer ->\n  -- | INDY total supply\n  Integer ->\n  -- | Date of the first epoch after protocol launch\n  Ledger.POSIXTime ->\n  -- | The date to determine the circulating for\n  Ledger.POSIXTime ->\n  DistributionSchedule ->\n  Integer\nelectorate itd t p d distributionSchedule =\n  let ve' = ve t p d\n      vm' = vm t p d\n   in divideInteger itd OCD.decimalUnit\n        + ve' (z_spd distributionSchedule) (\u03bbM_spd distributionSchedule)\n        + ve' (z_lpd distributionSchedule) (\u03bbM_lpd distributionSchedule)\n        + ve' (z_ipd distributionSchedule) (\u03bbM_ipd distributionSchedule)\n        + vm' (z_tv distributionSchedule) (\u03bbM_tv distributionSchedule)\n\n-- | This is used in the v_e and v_m calculations as the part of\n--   the electorate calculation.\n--   Ref: https://drive.google.com/uc?id=12K0tzNAy0Ef1OQBRE6unofAH-szIVB1a\n{-# INLINEABLE l #-}\nl :: Integer -> [OCD.OnChainDecimal] -> Integer -> Integer\nl t \u03bbM x =\n  OCD.decimal2Integer\n    ( (OCD.OnChainDecimal t * sum \u03bbM)\n        - OCD.OnChainDecimal\n          ( OCD.decimalUnit\n              * ( x\n                    * foldl\n                      ( \\ !acc a ->\n                          acc\n                            + OCD.decimal2Integer\n                              ( (OCD.OnChainDecimal t * a)\n                                  `OCD.divide` OCD.OnChainDecimal\n                                    (OCD.decimalUnit * x)\n                              )\n                      )\n                      0\n                      \u03bbM\n                )\n          ) -- necessary rational calculation\n    )\n\n-- | This is used to calculate electorate.\n--   The original equation for this calculation includes\n--   a sum that can go maximally 365 iterations based on\n--   the number of days from protocol launch.\n{-# INLINEABLE ve #-}\nve ::\n  Integer ->\n  Ledger.POSIXTime ->\n  Ledger.POSIXTime ->\n  Integer ->\n  [OCD.OnChainDecimal] ->\n  Integer\nve t p d z \u03bbM =\n  let lRes :: Integer\n      lRes = l t \u03bbM 73\n      \u03bbe :: Integer\n      \u03bbe = min ((Helpers.daysDifference d p `divide` 5) - z + 1) 365\n      -- Group ie calculation replaces the need to iteratively sum\n      -- all the ie calculations individually in the ve calculation.\n      --\n      -- Since iterations differ in the lookup to \u03bbM, there can be 5 groups\n      -- that can be simply grouped together and calculated at once\n      -- without the need to iterate.\n      groupIeCalculation :: OCD.OnChainDecimal -> Integer -> Integer -> Integer\n      groupIeCalculation (OCD.OnChainDecimal lookupRes) count minN =\n        let -- necessary rational calculation\n            v =\n              OCD.decimal2Integer\n                ( OCD.OnChainDecimal t\n                    * ( OCD.OnChainDecimal (lookupRes * OCD.decimalUnit)\n                          `OCD.divide` 73\n                      )\n                )\n                `divideInteger` OCD.decimalUnit\n            rangeIncludesL = lRes >= minN && minN + count - 1 >= lRes\n         in if rangeIncludesL\n              then\n                let lowerCount = lRes - minN\n                 in -- chunks range and calculates separately for those that are\n                    -- under the l and those that are above and equal\n                    lowerCount * (v + 1) + (count - lowerCount) * v\n              else\n                if minN >= lRes\n                  then count * v\n                  else count * (v + 1)\n      -- Whole group is 73 iterations.\n      -- These can be calculated in one go using the same lookup,\n      -- without the need to iterate 73 times for the group.\n      groupsSumCalc :: Integer -> Integer\n      groupsSumCalc count\n        | count <= 0 = 0\n        | otherwise =\n            groupIeCalculation\n              (\u03bbM !! (count - 1))\n              73\n              ((count - 1) * 73)\n              + groupsSumCalc (count - 1)\n   in if \u03bbe < 0\n        then 0\n        else\n          let (x, rest) = \u03bbe `divMod` 73\n           in groupsSumCalc x\n                + if rest > 0\n                  then groupIeCalculation (\u03bbM !! x) rest (x * 73)\n                  else 0\n\n-- | This is used to calculate electorate.\n--   The original equation for this calculation includes a sum that can go\n--   maximally 24 iterations based on number of days from protocol launch.\n{-# INLINEABLE vm #-}\nvm ::\n  Integer ->\n  Ledger.POSIXTime ->\n  Ledger.POSIXTime ->\n  Integer ->\n  OCD.OnChainDecimal ->\n  Integer\nvm t p d z (OCD.OnChainDecimal \u03bbM) =\n  let monthLength :: OCD.OnChainDecimal\n      monthLength = OCD.OnChainDecimal 30_417_000 -- 365 / 12\n      dpDiff :: Integer\n      dpDiff = Helpers.daysDifference d p\n      \u03bbm :: Integer\n      \u03bbm =\n        min\n          ( OCD.decimal2Integer\n              ( OCD.OnChainDecimal (OCD.decimalUnit * (dpDiff - z))\n                  `OCD.divide` monthLength\n              )\n              + 1\n          )\n          24 -- necessary rational calculation\n   in if \u03bbm < 0\n        then 0\n        else\n          let -- necessary rational calculation\n              qX :: OCD.OnChainDecimal\n              qX =\n                OCD.OnChainDecimal t\n                  * (OCD.OnChainDecimal (\u03bbM * OCD.decimalUnit) `OCD.divide` 24)\n           in if \u03bbm == 0 && dpDiff >= 0\n                then OCD.decimal2Integer qX `divideInteger` OCD.decimalUnit\n                else\n                  OCD.decimal2Integer\n                    (OCD.OnChainDecimal (\u03bbm * OCD.decimalUnit) * qX)\n                    `divideInteger` OCD.decimalUnit\n\ndata PollScript\n\ndata PollManagerScript\n\ninstance TScripts.ValidatorTypes PollScript where\n  type DatumType PollScript = PollShard\n  type RedeemerType PollScript = PollRedeemer\n\ninstance TScripts.ValidatorTypes PollManagerScript where\n  type DatumType PollManagerScript = PollManager\n  type RedeemerType PollManagerScript = PollManagerRedeemer\n", "output": "This Cardano smart contract code is part of the Indigo protocol's governance system, specifically dealing with polls. It is written in Haskell and uses the Plutus framework for smart contracts on the Cardano blockchain. Let's break down the key components and functionality of this code:\n\n### Modules and Imports\n\n- **Module Declaration**: The module is named `Indigo.Contracts.Governance.Poll.Common`, indicating it contains common definitions and functions related to governance polls.\n- **Imports**: The code imports several modules, including JSON handling (`Data.Aeson`), OpenAPI support, and various Indigo-specific modules for governance and utilities. It also imports Plutus libraries for blockchain interactions.\n\n### Data Types\n\n1. **VoteOption**: Represents voting options in a poll, either `Yes` or `No`. It derives standard Haskell type classes for JSON conversion and equality checks.\n\n2. **PollStatus**: Holds the count of `Yes` and `No` votes in a poll. It implements `Eq`, `Semigroup`, and `Monoid` to allow for comparison and aggregation of vote counts.\n\n3. **PollManager**: Represents the manager of a poll, containing fields like poll ID, owner, content, status, end time, and shard information. It is a complex data structure that manages the lifecycle and state of a poll.\n\n4. **PollShard**: Represents a shard of a poll, which is a part of the poll's distributed state. It includes fields for ID, status, end time, and the manager's address.\n\n5. **DistributionSchedule**: Defines a schedule for distributing tokens, with fields for different types of distributions and their delays. This is used in calculating the electorate for quorum checks.\n\n6. **PollParams**: Contains parameters for a poll, such as token classes and validator hashes.\n\n7. **PollManagerParams**: Similar to `PollParams`, but with additional fields for governance NFTs, upgrade tokens, and distribution schedules.\n\n8. **PollRedeemer**: Represents actions that can be taken on a poll, such as voting or merging shards.\n\n9. **PollManagerRedeemer**: Represents actions that can be taken by the poll manager, like ending a poll or creating shards.\n\n### Functions\n\n- **vote**: Updates the `PollShard` status by incrementing the `Yes` or `No` vote count based on the `VoteOption` and the amount of votes.\n\n- **pollPassQuorum**: Determines if a poll passes the quorum threshold. It uses a complex calculation involving the current poll status, protocol start time, and distribution schedule.\n\n- **q**: Calculates the core equation for the adaptive quorum, which is a measure of whether the poll has enough support to pass. It uses the number of `Yes` and `No` votes, along with the electorate size.\n\n- **electorate**: Computes the electorate size based on the initial distribution of tokens, total supply, and a distribution schedule. This is used in the quorum calculation.\n\n- **ve** and **vm**: Helper functions used in the electorate calculation. They compute parts of the electorate based on vesting schedules and time since protocol launch.\n\n### Validator Scripts\n\n- **PollScript** and **PollManagerScript**: These are types representing the validator scripts for polls and poll managers, respectively. They define the types of data (datum) and actions (redeemer) that the scripts can handle.\n\n### Summary\n\nThis code is a sophisticated implementation of a governance poll system on the Cardano blockchain. It defines the data structures and logic needed to manage polls, including voting, quorum checking, and shard management. The use of Plutus and Haskell allows for precise and secure smart contract execution, ensuring that governance decisions are made transparently and fairly.", "file_path": "indigo-smart-contracts/src/Indigo/Contracts/Governance/Poll/Common.hs", "file": "Common.hs"}
{"instruction": "Explain the following smart contract code:", "input": "import fire\n\nimport pycardano\nfrom muesliswap_onchain_governance.utils.network import show_tx, context\nfrom opshin.ledger.api_v2 import (\n    POSIXTime,\n)\nfrom opshin.prelude import Token\nfrom pycardano import (\n    OgmiosChainContext,\n    TransactionBuilder,\n    Redeemer,\n    AuxiliaryData,\n    AlonzoMetadata,\n    Metadata,\n    TransactionOutput,\n    Value,\n)\n\nfrom ..util import (\n    token_from_string,\n    asset_from_token,\n    with_min_lovelace,\n    sorted_utxos,\n    amount_of_token_in_value,\n)\nfrom muesliswap_onchain_governance.onchain.staking import staking\nfrom muesliswap_onchain_governance.onchain.tally import tally_auth_nft\nfrom ...utils import get_signing_info, ogmios_url, network, kupo_url\nfrom ...utils.contracts import get_contract, get_ref_utxo, module_name\nfrom ...utils.to_script_context import to_address, to_tx_out_ref\n\n\ndef main(\n    wallet: str = \"creator\",\n):\n    # Load script info\n    (\n        staking_script,\n        _,\n        staking_address,\n    ) = get_contract(module_name(staking), True)\n\n    # Get payment address\n    payment_vkey, payment_skey, payment_address = get_signing_info(\n        wallet, network=network\n    )\n\n    # Make the datum of the GovState\n    staking_utxo = None\n    for utxo in context.utxos(staking_address):\n        staking_datum = staking.StakingState.from_cbor(utxo.output.datum.cbor)\n        if staking_datum.params.owner != to_address(payment_address):\n            continue\n        if not amount_of_token_in_value(\n            staking_datum.params.governance_token, utxo.output.amount\n        ):\n            continue\n        staking_utxo = utxo\n        break\n    assert staking_utxo is not None, \"No staking state found\"\n\n    payment_utxos = context.utxos(payment_address)\n    all_utxos = sorted_utxos(payment_utxos + [staking_utxo])\n\n    redeemer = Redeemer(\n        staking.WithdrawFunds(\n            state_input_index=all_utxos.index(staking_utxo),\n            state_output_index=0,\n        )\n    )\n\n    # Build the transaction\n    builder = TransactionBuilder(context)\n    for u in payment_utxos:\n        builder.add_input(u)\n    builder.add_script_input(\n        staking_utxo,\n        staking_script,\n        None,\n        redeemer,\n    )\n    builder.auxiliary_data = AuxiliaryData(\n        data=AlonzoMetadata(\n            metadata=Metadata({674: {\"msg\": [\"Close Staking Position\"]}})\n        )\n    )\n    output = TransactionOutput(\n        address=staking_address,\n        amount=Value(\n            coin=2000000,\n        ),\n        datum=staking_datum,\n    )\n    builder.add_output(with_min_lovelace(output, context))\n\n    # Sign the transaction\n    signed_tx = builder.build_and_sign(\n        signing_keys=[payment_skey],\n        change_address=payment_address,\n    )\n\n    # Submit the transaction\n    context.submit_tx(signed_tx)\n\n    show_tx(signed_tx)\n\n\nif __name__ == \"__main__\":\n    fire.Fire(main)\n", "output": "This Cardano smart contract code is part of the MuesliSwap on-chain governance system, specifically for closing a staking position. The code is written in Python and uses several libraries, including `pycardano` for interacting with the Cardano blockchain, and `fire` for creating command-line interfaces. Let's break down the code step by step:\n\n### Imports\n\n- **fire**: A library for creating command-line interfaces.\n- **pycardano**: A library for interacting with the Cardano blockchain.\n- **muesliswap_onchain_governance.utils.network**: Contains utility functions for network interactions.\n- **opshin.ledger.api_v2**: Provides types like `POSIXTime`.\n- **opshin.prelude**: Provides utility types like `Token`.\n- **pycardano**: Provides classes for building transactions, such as `TransactionBuilder`, `Redeemer`, `AuxiliaryData`, etc.\n- **muesliswap_onchain_governance.onchain.staking**: Contains staking-related on-chain logic.\n- **muesliswap_onchain_governance.onchain.tally**: Contains tally-related logic.\n- **muesliswap_onchain_governance.utils**: Provides utility functions for signing, network configuration, and contract management.\n\n### Main Function\n\nThe `main` function is the entry point of the script. It performs the following tasks:\n\n1. **Load Script Info**: \n   - Retrieves the staking contract script, its address, and other related information using `get_contract`.\n\n2. **Get Payment Address**:\n   - Retrieves the payment verification key, signing key, and address for the specified wallet using `get_signing_info`.\n\n3. **Find Staking UTXO**:\n   - Iterates over UTXOs at the staking address to find one that matches the user's address and contains the governance token.\n   - Uses `staking.StakingState.from_cbor` to deserialize the datum from CBOR format.\n   - Checks if the UTXO belongs to the user and contains the governance token using `amount_of_token_in_value`.\n\n4. **Prepare Transaction Inputs**:\n   - Collects all UTXOs from the user's payment address and the identified staking UTXO.\n   - Sorts these UTXOs using `sorted_utxos`.\n\n5. **Create Redeemer**:\n   - Constructs a `Redeemer` object for withdrawing funds from the staking contract.\n   - Specifies the index of the staking UTXO in the list of all UTXOs.\n\n6. **Build the Transaction**:\n   - Initializes a `TransactionBuilder` with the current blockchain context.\n   - Adds inputs from the user's payment UTXOs.\n   - Adds the staking UTXO as a script input with the staking script and redeemer.\n   - Sets auxiliary data with metadata indicating the transaction's purpose (\"Close Staking Position\").\n   - Creates a transaction output to return funds to the staking address with a minimum amount of Lovelace.\n\n7. **Sign the Transaction**:\n   - Builds and signs the transaction using the user's signing key.\n   - Specifies the change address to return any leftover funds.\n\n8. **Submit the Transaction**:\n   - Submits the signed transaction to the blockchain using `context.submit_tx`.\n   - Displays the transaction details using `show_tx`.\n\n### Command-Line Interface\n\nThe script uses `fire.Fire(main)` to create a command-line interface, allowing users to execute the `main` function with different parameters, such as specifying a different wallet.\n\n### Summary\n\nThis script is designed to close a staking position on the Cardano blockchain by interacting with the MuesliSwap on-chain governance system. It identifies the relevant staking UTXO, constructs a transaction to withdraw funds, and submits it to the blockchain. The script is modular, using utility functions and classes to handle various aspects of transaction building and submission.", "file_path": "muesliswap-onchain-governance/muesliswap_onchain_governance/offchain/staking/close.py", "file": "close.py"}
{"instruction": "Explain the following smart contract code:", "input": "\"\"\"\nThe vault FT contract.\nThis FT represents a single governance token locked into a staking vault until a fixed amount of time.\n\nThis contract is intended to have inputs from these contracts:\n- the staking Vault contract (if minted for existing vault positions)\n\n\nOutputs of this contract may go to:\n- the staking vault contract (when minted for a new position)\n- any address (intended: user wallet, but no restriction is necessary)\n\n\nIt is not allowed to mint several vault FTs with different names in a single transaction. It is allowed to mint several of the same name.\n\"\"\"\nfrom muesliswap_onchain_governance.onchain.staking.staking_util import *\nfrom opshin.std.math import *\n\n\n@dataclass\nclass VaultDatum(PlutusData):\n    \"\"\"\n    The datum of a vault position\n    \"\"\"\n\n    CONSTR_ID = 0\n    owner: PubKeyHash\n    release_time: POSIXTime\n\n\n@dataclass\nclass ExistingVaultFTMint(PlutusData):\n    \"\"\"\n    Mint FT for an existing vault position\n    Only the owner of the vault may mint this FT and only for a limited time\n    \"\"\"\n\n    CONSTR_ID = 1\n    vault_ref_input_index: int\n\n\n@dataclass\nclass NewVaultFTMint(PlutusData):\n    \"\"\"\n    Mint FT for a new vault position\n    Indicate in the datum the output to the vault contract\n    \"\"\"\n\n    CONSTR_ID = 2\n    vault_output_index: int\n\n\n@dataclass\nclass BurnVaultFT(PlutusData):\n    \"\"\"\n    Burn FT for a vault position\n    \"\"\"\n\n    CONSTR_ID = 3\n\n\nVaultFTRedeemer = Union[ExistingVaultFTMint, NewVaultFTMint, BurnVaultFT]\n\n\ndef vault_ft_token_name(vault_datum: VaultDatum) -> TokenName:\n    \"\"\"\n    The name of the vault FT is the expiration time of the vault position\n    \"\"\"\n    return bytes_big_from_unsigned_int(vault_datum.release_time)\n\n\ndef check_vault_owner_allowed(\n    tx_info: TxInfo,\n    latest_existing_mint_time: ExtendedPOSIXTime,\n    vault_owner: PubKeyHash,\n) -> None:\n    \"\"\"\n    Check that the vault owner is allowed to mint a new FT\n    \"\"\"\n    assert before_ext(\n        tx_info.valid_range, latest_existing_mint_time\n    ), \"Trying to mint a new FT after the latest existing mint\"\n    assert vault_owner in tx_info.signatories, \"Vault owner must sign the transaction\"\n\n\ndef extract_vault_output(redeemer: VaultFTRedeemer, tx_info: TxInfo) -> TxOut:\n    \"\"\"\n    Extract the vault datum based on the redeemer. Ensure that the redeemer is valid.\n    \"\"\"\n    if isinstance(redeemer, ExistingVaultFTMint):\n        vault_output = tx_info.inputs[redeemer.vault_ref_input_index].resolved\n    elif isinstance(redeemer, NewVaultFTMint):\n        vault_output = tx_info.outputs[redeemer.vault_output_index]\n    else:\n        assert False, f\"Invalid redeemer {redeemer}\"\n    return vault_output\n\n\ndef validator(\n    vault_contract_address: Address,\n    latest_existing_mint_time: ExtendedPOSIXTime,\n    vault_admin: PubKeyHash,\n    # token that is worth 1_000_000 new governance tokens because of lacking decimals\n    old_governance_token: Token,\n    new_governance_token: Token,\n    redeemer: VaultFTRedeemer,\n    context: ScriptContext,\n) -> None:\n    \"\"\"\n    Vault position FT\n\n    This FT is substrate for the Goverance token locked in a vault position because those tokens can not participate in governance votes anymore.\n    The name of the token is the same as the expiration time of the vault position.\n    \"\"\"\n    purpose = get_minting_purpose(context)\n    tx_info = context.tx_info\n\n    own_mint = tx_info.mint[purpose.policy_id]\n    if isinstance(redeemer, BurnVaultFT):\n        # Burning FTs is always allowed\n        # but we need to make sure that all mints with this policy are burning\n        assert all(\n            [amount < 0 for amount in own_mint.values()]\n        ), \"Only burning is allowed in this transaction\"\n    else:\n        if isinstance(redeemer, ExistingVaultFTMint):\n            check_vault_owner_allowed(tx_info, latest_existing_mint_time, vault_admin)\n        vault_output = extract_vault_output(redeemer, tx_info)\n        assert (\n            vault_output.address == vault_contract_address\n        ), \"Vault position must be at the vault contract address\"\n        vault_datum: VaultDatum = resolve_datum_unsafe(vault_output, tx_info)\n        vault_amount = amount_of_token_in_output(\n            new_governance_token, vault_output\n        ) + 1_000_000 * amount_of_token_in_output(old_governance_token, vault_output)\n        token_name = vault_ft_token_name(vault_datum)\n        check_mint_exactly_n_with_name(\n            tx_info.mint, vault_amount, purpose.policy_id, token_name\n        )\n", "output": "This Cardano smart contract code is part of the MuesliSwap on-chain governance system, specifically dealing with the staking vault functionality. The contract is designed to manage fungible tokens (FTs) that represent governance tokens locked in a staking vault until a specified release time. Let's break down the code and its components in detail:\n\n### Overview\n\nThe contract allows for the minting and burning of fungible tokens (FTs) that represent governance tokens locked in a staking vault. These tokens are locked until a specified release time, and the contract ensures that only authorized actions are performed.\n\n### Key Components\n\n1. **Data Structures**:\n   - `VaultDatum`: Represents the data associated with a vault position, including the owner's public key hash and the release time (when the tokens can be unlocked).\n   - `ExistingVaultFTMint`: Represents a request to mint FTs for an existing vault position. Only the owner can mint these tokens, and only within a limited time.\n   - `NewVaultFTMint`: Represents a request to mint FTs for a new vault position, indicating the output to the vault contract.\n   - `BurnVaultFT`: Represents a request to burn FTs for a vault position.\n   - `VaultFTRedeemer`: A union type that can be any of the above three actions (minting for existing or new positions, or burning).\n\n2. **Functions**:\n   - `vault_ft_token_name`: Generates the token name for the vault FT based on the expiration time of the vault position.\n   - `check_vault_owner_allowed`: Ensures that the vault owner is allowed to mint a new FT by checking the transaction's validity range and the owner's signature.\n   - `extract_vault_output`: Extracts the vault output from the transaction based on the redeemer type, ensuring the redeemer is valid.\n   - `validator`: The main function that validates the minting or burning of vault FTs. It checks the transaction context, ensures the correct minting or burning actions, and verifies the vault position's address and token amounts.\n\n### Detailed Explanation\n\n- **Minting and Burning Logic**:\n  - The contract allows minting of FTs for both existing and new vault positions. For existing positions, the owner must mint within a specified time and must sign the transaction.\n  - Burning of FTs is always allowed, but the transaction must only involve burning (i.e., all amounts must be negative).\n\n- **Token Naming**:\n  - The name of the vault FT is derived from the expiration time of the vault position, ensuring uniqueness and traceability.\n\n- **Validation**:\n  - The `validator` function is the core of the contract, ensuring that all operations are valid. It checks the minting purpose, validates the redeemer type, and ensures that the vault position is correctly associated with the vault contract address.\n  - It also checks that the correct amount of tokens is minted, considering both new and old governance tokens.\n\n- **Security and Restrictions**:\n  - The contract enforces that only the vault owner can mint tokens for existing positions and that the vault position must be at the correct contract address.\n  - It restricts minting to a single token name per transaction, preventing multiple vault FTs with different names from being minted simultaneously.\n\n### Use Cases\n\n- **Governance Participation**: The FTs represent governance tokens that are locked and cannot participate in governance votes until the release time.\n- **Staking Rewards**: Users can lock their governance tokens in a vault to earn rewards, represented by the minted FTs.\n- **Token Management**: The contract provides a mechanism to manage the lifecycle of governance tokens in a staking vault, including minting, holding, and burning.\n\nOverall, this contract is a crucial part of the MuesliSwap on-chain governance system, providing a secure and efficient way to manage governance tokens in staking vaults.", "file_path": "muesliswap-onchain-governance/muesliswap_onchain_governance/onchain/staking/vault_ft.py", "file": "vault_ft.py"}
{"instruction": "Explain the following smart contract code:", "input": "from datetime import datetime\n\nimport pytest\n\nfrom muesliswap_onchain_governance.offchain.gov_state.init import main as init_gov_state\nfrom muesliswap_onchain_governance.offchain.gov_state.create_tally import (\n    main as create_tally,\n)\nfrom muesliswap_onchain_governance.offchain.staking.init import main as init_staking\nfrom muesliswap_onchain_governance.offchain.tally.add_vote_tally import (\n    main as add_vote_tally,\n)\nfrom muesliswap_onchain_governance.offchain.init_gov_tokens import (\n    main as init_gov_tokens,\n)\nfrom test.offchain.util import DEFAULT_TEST_CONFIG, wait_for_tx\n\n\ndef test_add_vote():\n    init_tk_tx = init_gov_tokens(\n        wallet=DEFAULT_TEST_CONFIG.voter_wallet_name,\n        token_name=DEFAULT_TEST_CONFIG.governance_token.split(\".\")[1],\n        amount=1000000,\n    )\n    wait_for_tx(init_tk_tx)\n    creation_tx, gov_nft_name = init_gov_state(\n        wallet=DEFAULT_TEST_CONFIG.creator_wallet_name,\n        governance_token=DEFAULT_TEST_CONFIG.governance_token,\n        min_quorum=DEFAULT_TEST_CONFIG.min_quorum,\n        min_proposal_duration=DEFAULT_TEST_CONFIG.min_proposal_duration,\n    )\n    wait_for_tx(creation_tx)\n    main_create_tally_params = {\n        \"wallet\": DEFAULT_TEST_CONFIG.creator_wallet_name,\n        \"gov_state_nft_tk_name\": gov_nft_name,\n        \"treasury_benefactor\": DEFAULT_TEST_CONFIG.treasury_benefactor_wallet_name,\n    }\n    tally_tx, tally_state = create_tally(\n        **main_create_tally_params,\n    )\n    wait_for_tx(tally_tx)\n    staking_tx = init_staking(\n        wallet=DEFAULT_TEST_CONFIG.voter_wallet_name,\n        governance_token=DEFAULT_TEST_CONFIG.governance_token,\n        locked_amount=1000,\n        tally_auth_nft_tk_name=gov_nft_name,\n    )\n    wait_for_tx(staking_tx)\n    added_tally_tx, tally_state = add_vote_tally(\n        wallet=DEFAULT_TEST_CONFIG.voter_wallet_name,\n        proposal_id=tally_state.params.proposal_id,\n        proposal_index=0,\n        tally_auth_nft_tk_name=gov_nft_name,\n    )\n    wait_for_tx(added_tally_tx)\n", "output": "This Python script is a test case for a Cardano-based on-chain governance system, specifically for the MuesliSwap platform. The test is designed to simulate the process of adding a vote to a governance proposal tally. Let's break down the code step by step:\n\n### Imports\n\n1. **datetime**: This module is imported but not used in the code. It might be a leftover from previous code or intended for future use.\n2. **pytest**: A testing framework for Python, used to write simple and scalable test cases.\n3. **muesliswap_onchain_governance.offchain modules**: These are custom modules specific to the MuesliSwap governance system. They provide functions to initialize governance state, create a tally, initialize staking, and add a vote to a tally.\n4. **test.offchain.util**: This module provides utility functions and constants for testing, such as `DEFAULT_TEST_CONFIG` and `wait_for_tx`.\n\n### Test Function: `test_add_vote`\n\nThis function simulates the process of adding a vote to a governance proposal tally. Here's a detailed breakdown:\n\n1. **Initialize Governance Tokens**:\n   - `init_gov_tokens` is called to initialize governance tokens for the voter. It uses the voter's wallet name, the governance token name, and an amount of 1,000,000 tokens.\n   - `wait_for_tx(init_tk_tx)` waits for the transaction to complete, ensuring the tokens are initialized before proceeding.\n\n2. **Initialize Governance State**:\n   - `init_gov_state` sets up the initial state for governance. It requires the creator's wallet name, the governance token, minimum quorum, and minimum proposal duration.\n   - The function returns a transaction and a governance NFT name, which are used in subsequent steps.\n   - `wait_for_tx(creation_tx)` ensures the governance state is initialized before moving on.\n\n3. **Create Tally**:\n   - `create_tally` is called to create a tally for a governance proposal. It requires the creator's wallet name, the governance state NFT token name, and the treasury benefactor's wallet name.\n   - The function returns a transaction and a tally state.\n   - `wait_for_tx(tally_tx)` ensures the tally is created before proceeding.\n\n4. **Initialize Staking**:\n   - `init_staking` initializes staking for the voter. It requires the voter's wallet name, the governance token, the amount to be locked (1,000 tokens), and the tally authorization NFT token name.\n   - `wait_for_tx(staking_tx)` ensures the staking is initialized before adding a vote.\n\n5. **Add Vote to Tally**:\n   - `add_vote_tally` is called to add a vote to the tally. It requires the voter's wallet name, the proposal ID from the tally state, the proposal index (0 in this case), and the tally authorization NFT token name.\n   - `wait_for_tx(added_tally_tx)` ensures the vote is added to the tally.\n\n### Summary\n\nThis test function simulates a complete workflow for adding a vote to a governance proposal tally in the MuesliSwap on-chain governance system. It involves initializing tokens, setting up governance state, creating a tally, initializing staking, and finally adding a vote. Each step involves a transaction, and the `wait_for_tx` function ensures that each transaction is completed before proceeding to the next step. This ensures the test runs smoothly and accurately reflects the real-world process on the Cardano blockchain.", "file_path": "muesliswap-onchain-governance/test/offchain/tally/test_add_vote.py", "file": "test_add_vote.py"}
{"instruction": "Explain the following smart contract code:", "input": "-- SPDX-License-Identifier: BUSL-1.1\n\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Indigo.Contracts.Governance.Gov.OnChain\n  ( validateGov,\n    govAddress,\n    govValidator,\n    govScriptCTL,\n    untypedGovHash,\n  )\nwhere\n\nimport Indigo.Contracts.Governance.Gov.Common\nimport Indigo.Contracts.Governance.Poll.Common\n  ( PollManager\n      ( PollManager,\n        pContent,\n        pCreatedShards,\n        pEndTime,\n        pExpirationTime,\n        pId,\n        pOwner,\n        pProposeEndTime,\n        pProtocolVersion,\n        pStatus,\n        pTalliedShards,\n        pTotalShards\n      ),\n    PollStatus (VoteCount, nNo, nYes),\n  )\nimport Indigo.Contracts.Governance.VersionRegistry.Common\n  ( validateUpgradeVersion,\n  )\nimport Indigo.Utils.Helpers qualified as Helpers\nimport Ledger qualified\nimport Ledger.Interval qualified as Interval\nimport Ledger.Value qualified as Value\nimport Plutus.Script.Utils.V2.Address qualified as Address\nimport Plutus.Script.Utils.V2.Scripts qualified as Scripts\nimport Plutus.Script.Utils.V2.Typed.Scripts.Validators\n  ( UntypedValidator,\n    mkUntypedValidator,\n  )\nimport Plutus.V2.Ledger.Api qualified as V2\nimport Plutus.V2.Ledger.Contexts qualified as Contexts\nimport PlutusTx qualified\nimport PlutusTx.Prelude hiding (divide, fromInteger)\n\n{-# INLINEABLE validateGov #-}\nvalidateGov :: GovParams -> GovDatum -> GovRedeemer -> V2.ScriptContext -> Bool\nvalidateGov param govDatum (CreatePoll pTime pOwner pContent) ctx =\n  validateCreateProposal param pTime pOwner pContent govDatum ctx\nvalidateGov param _ UpgradeGov ctx = validateGovUpgrade param ctx\nvalidateGov param _ UpgradeVersion ctx = validateGovVersionUpgrade param ctx\n\n{-# INLINEABLE validateCreateProposal #-}\nvalidateCreateProposal ::\n  GovParams ->\n  Ledger.POSIXTime ->\n  Ledger.PaymentPubKeyHash ->\n  ProposalContent ->\n  GovDatum ->\n  V2.ScriptContext ->\n  Bool\nvalidateCreateProposal\n  GovParams {gBiasTime, govNFT, indyAsset, pollToken, pollManagerValHash}\n  pTime\n  pOwner\n  pContent\n  govDatum@Gov {currentProposal, currentVersion, protocolParams}\n  ctx =\n    traceIfFalse\n      \"Incorrect Governance output\"\n      ( Helpers.checkOwnOutputAdaGeq @GovDatum\n          ctx\n          govDatum {currentProposal = currentProposal + 1}\n          (Helpers.unitValue govNFT)\n      )\n      && traceIfFalse\n        \"The transaction must be signed by owner\"\n        (Contexts.txSignedBy info (Ledger.unPaymentPubKeyHash pOwner))\n      && traceIfFalse\n        \"Proposal incompatible with current state\"\n        (checkExisted pContent)\n      && traceIfFalse\n        \"Invalid pTime\"\n        ( Helpers.validityTimeInInterval\n            info\n            (Interval.interval (pTime - gBiasTime) (pTime + gBiasTime))\n        )\n      && traceIfFalse\n        \"Transaction mint exactly 1 pollToken\"\n        (V2.txInfoMint info == Helpers.unitValue pollToken)\n      && traceIfFalse\n        \"Invalid Poll output\"\n        ( Helpers.checkOutputFromOtherScriptsAdaGeq\n            info\n            pollManagerValHash\n            pollDatum\n            pollValue\n        )\n      && traceIfFalse\n        \"TextProposal's length is <= 64\"\n        ( case pContent of\n            TextProposal txt -> lengthOfByteString txt <= 64\n            _ -> True\n        )\n    where\n      info :: V2.TxInfo\n      info = V2.scriptContextTxInfo ctx\n\n      checkExisted :: ProposalContent -> Bool\n      checkExisted (UpgradeProtocol UpgradePaths {uId}) =\n        uId == currentVersion + 1\n      checkExisted _ = True\n\n      pollEndTime :: Ledger.POSIXTime\n      pollEndTime = pTime + votingPeriod protocolParams\n\n      pollDatum :: PollManager\n      pollDatum =\n        PollManager\n          { pContent,\n            pEndTime = pollEndTime,\n            pExpirationTime = pollEndTime + expirationPeriod protocolParams,\n            pId = currentProposal + 1,\n            pOwner,\n            pStatus = VoteCount {nYes = zero, nNo = zero},\n            pCreatedShards = zero,\n            pTalliedShards = zero,\n            pTotalShards = totalShards protocolParams,\n            pProposeEndTime = pTime + proposingPeriod protocolParams,\n            pProtocolVersion = currentVersion\n          }\n\n      pollValue :: Ledger.Value\n      pollValue =\n        Helpers.unitValue pollToken\n          <> Value.assetClassValue indyAsset (proposalDeposit protocolParams)\n\n{-# INLINEABLE validateGovUpgrade #-}\nvalidateGovUpgrade :: GovParams -> V2.ScriptContext -> Bool\nvalidateGovUpgrade GovParams {upgradeToken} ctx =\n  traceIfFalse\n    \"Spend exactly 1 Upgrade Token\"\n    (Helpers.isSpendingUnitValue info upgradeToken)\n  where\n    info :: V2.TxInfo\n    info = V2.scriptContextTxInfo ctx\n\nvalidateGovVersionUpgrade :: GovParams -> V2.ScriptContext -> Bool\nvalidateGovVersionUpgrade GovParams {versionRecordToken} ctx =\n  validateUpgradeVersion \"Gov\" ctx versionRecordToken\n\ngovValidator :: GovParams -> V2.Validator\ngovValidator param =\n  V2.mkValidatorScript\n    (compiledValidateGov `PlutusTx.applyCode` PlutusTx.liftCode param)\n\ncompiledValidateGov :: PlutusTx.CompiledCode (GovParams -> UntypedValidator)\ncompiledValidateGov =\n  Helpers.optimizeUPLC\n    $$(PlutusTx.compile [||mkUntypedValidator . validateGov||])\n\ncompiledUntypedValidateGov ::\n  PlutusTx.CompiledCode (BuiltinData -> UntypedValidator)\ncompiledUntypedValidateGov =\n  Helpers.optimizeUPLC\n    $$( PlutusTx.compile\n          [||\n          mkUntypedValidator\n            . validateGov\n            . PlutusTx.unsafeFromBuiltinData\n          ||]\n      )\n\nuntypedGovValidator :: BuiltinData -> V2.Validator\nuntypedGovValidator params =\n  V2.mkValidatorScript\n    ( compiledUntypedValidateGov\n        `PlutusTx.applyCode` PlutusTx.liftCode params\n    )\n\nuntypedGovHash :: BuiltinData -> V2.ValidatorHash\nuntypedGovHash = Scripts.validatorHash . untypedGovValidator\n\n-- serialised for use in CTL\ngovScriptCTL :: V2.Script\ngovScriptCTL = V2.fromCompiledCode compiledUntypedValidateGov\n\ngovAddress :: GovParams -> Ledger.Address\ngovAddress = Address.mkValidatorAddress . govValidator\n", "output": "This Cardano smart contract code is part of the Indigo protocol's governance system. It defines the on-chain logic for validating governance-related transactions, such as creating proposals and upgrading governance parameters. Let's break down the key components and functionality of this code:\n\n### Module and Imports\n\n- **Module Declaration**: The module is named `Indigo.Contracts.Governance.Gov.OnChain`, indicating it handles on-chain governance logic.\n- **Imports**: The code imports various modules, including common governance and poll-related modules, utility functions, and Plutus libraries for working with scripts, addresses, and ledger contexts.\n\n### Key Functions\n\n1. **`validateGov` Function**:\n   - This is the main validation function for governance actions. It takes parameters (`GovParams`), the current state (`GovDatum`), a redeemer indicating the action (`GovRedeemer`), and the script context (`V2.ScriptContext`).\n   - It handles three types of actions:\n     - `CreatePoll`: Calls `validateCreateProposal` to validate the creation of a new poll.\n     - `UpgradeGov`: Calls `validateGovUpgrade` to validate a governance upgrade.\n     - `UpgradeVersion`: Calls `validateGovVersionUpgrade` to validate a version upgrade.\n\n2. **`validateCreateProposal` Function**:\n   - Validates the creation of a new governance proposal.\n   - Checks include:\n     - Ensuring the governance output is correct.\n     - Verifying the transaction is signed by the proposal owner.\n     - Ensuring the proposal content is compatible with the current state.\n     - Validating the proposed time (`pTime`) is within an acceptable interval.\n     - Ensuring exactly one poll token is minted.\n     - Validating the poll output.\n     - Checking the length of a text proposal does not exceed 64 bytes.\n   - Constructs a `PollManager` datum for the new poll, setting various fields like `pEndTime`, `pExpirationTime`, and `pStatus`.\n\n3. **`validateGovUpgrade` Function**:\n   - Validates a governance upgrade by ensuring exactly one upgrade token is spent.\n\n4. **`validateGovVersionUpgrade` Function**:\n   - Validates a version upgrade using the `validateUpgradeVersion` function from the `VersionRegistry.Common` module.\n\n### Script and Validator Construction\n\n- **`govValidator` Function**: Constructs a Plutus validator script using the `validateGov` function and the provided `GovParams`.\n- **`compiledValidateGov` and `compiledUntypedValidateGov`**: These are compiled versions of the `validateGov` function, optimized for use in Plutus scripts.\n- **`untypedGovValidator` and `untypedGovHash`**: Functions to create an untyped validator and its hash, respectively, from built-in data.\n- **`govScriptCTL`**: A serialized version of the compiled untyped validator for use in Cardano Transaction Language (CTL).\n- **`govAddress`**: Generates the on-chain address for the governance validator using the `govValidator`.\n\n### Governance Parameters and Data Structures\n\n- **`GovParams`**: Contains parameters needed for governance validation, such as tokens and protocol parameters.\n- **`GovDatum`**: Represents the current state of governance, including the current proposal and version.\n- **`GovRedeemer`**: Represents the action to be validated, such as creating a poll or upgrading governance.\n- **`PollManager`**: A data structure representing a poll, with fields for content, end time, status, and more.\n\n### Utility Functions\n\n- **`Helpers` Module**: Provides utility functions for checking outputs, validating time intervals, and handling values and tokens.\n\n### Conclusion\n\nThis code is a sophisticated implementation of governance logic for the Indigo protocol on Cardano. It ensures that governance actions are validated according to specific rules and conditions, maintaining the integrity and security of the governance process. The use of Plutus and various utility functions allows for efficient and secure on-chain validation.", "file_path": "indigo-smart-contracts/src/Indigo/Contracts/Governance/Gov/OnChain.hs", "file": "OnChain.hs"}
{"instruction": "Explain the following smart contract code:", "input": "{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}\n{-# OPTIONS_GHC -Wno-missing-import-lists #-}\n\nmodule AlwaysFails (pAlwaysFails, pAuthMint) where \n\nimport Plutarch.Prelude\nimport Plutarch.Api.V2 \nimport PriceDiscoveryEvent.Utils (pvalueOfOne)\n\npAlwaysFails ::\n  ClosedTerm PValidator\npAlwaysFails  = plam $ \\_dat _redmn _ctx' -> popaque $ perror\n\npAuthMint ::\n  Term s (PAsData PCurrencySymbol :--> PMintingPolicy)\npAuthMint  = plam $ \\multisigCert _redmn ctx ->\n  let inputs = pfield @\"inputs\" # (pfield @\"txInfo\" # ctx) \n   in pif (pany @PBuiltinList\n            # plam (\\inp -> (pvalueOfOne # multisigCert # (pfield @\"value\" # (pfield @\"resolved\" # inp)))) \n            # inputs)\n          (popaque $ pconstant ())\n          perror ", "output": "The provided Haskell code is a Cardano smart contract written using the Plutarch library, which is a domain-specific language (DSL) for writing Plutus smart contracts. This code defines two main components: `pAlwaysFails` and `pAuthMint`. Let's break down each part of the code:\n\n### Module and Imports\n\n```haskell\nmodule AlwaysFails (pAlwaysFails, pAuthMint) where \n\nimport Plutarch.Prelude\nimport Plutarch.Api.V2 \nimport PriceDiscoveryEvent.Utils (pvalueOfOne)\n```\n\n- **Module Declaration**: The module is named `AlwaysFails` and it exports two functions: `pAlwaysFails` and `pAuthMint`.\n- **Imports**:\n  - `Plutarch.Prelude`: Provides basic Plutarch functionality and types.\n  - `Plutarch.Api.V2`: Contains API definitions for Plutarch, including transaction and script context types.\n  - `PriceDiscoveryEvent.Utils (pvalueOfOne)`: Imports a utility function `pvalueOfOne` from another module, which is presumably used to check the value of a specific token.\n\n### `pAlwaysFails` Function\n\n```haskell\npAlwaysFails ::\n  ClosedTerm PValidator\npAlwaysFails  = plam $ \\_dat _redmn _ctx' -> popaque $ perror\n```\n\n- **Type**: `ClosedTerm PValidator` indicates that this is a validator script.\n- **Functionality**: \n  - `plam`: Defines a Plutarch lambda function.\n  - The function takes three parameters: `_dat`, `_redmn`, and `_ctx'`, which represent the datum, redeemer, and script context, respectively.\n  - `popaque $ perror`: This line makes the function always fail by using `perror`, which is a Plutarch function that causes the script to fail unconditionally. `popaque` is used to wrap the error in an opaque term, which is a common pattern in Plutarch to handle terms that should not be evaluated further.\n\n### `pAuthMint` Function\n\n```haskell\npAuthMint ::\n  Term s (PAsData PCurrencySymbol :--> PMintingPolicy)\npAuthMint  = plam $ \\multisigCert _redmn ctx ->\n  let inputs = pfield @\"inputs\" # (pfield @\"txInfo\" # ctx) \n   in pif (pany @PBuiltinList\n            # plam (\\inp -> (pvalueOfOne # multisigCert # (pfield @\"value\" # (pfield @\"resolved\" # inp)))) \n            # inputs)\n          (popaque $ pconstant ())\n          perror\n```\n\n- **Type**: `Term s (PAsData PCurrencySymbol :--> PMintingPolicy)` indicates that this is a minting policy script.\n- **Functionality**:\n  - The function takes three parameters: `multisigCert`, `_redmn`, and `ctx`.\n    - `multisigCert`: A currency symbol wrapped in `PAsData`, which is likely used to identify a specific token or certificate.\n    - `_redmn`: The redeemer, which is not used in this function.\n    - `ctx`: The script context, which contains transaction information.\n  - `inputs = pfield @\"inputs\" # (pfield @\"txInfo\" # ctx)`: Extracts the list of transaction inputs from the transaction info within the context.\n  - `pany @PBuiltinList`: Checks if any input in the list satisfies a given condition.\n    - The condition is defined by the lambda function `plam (\\inp -> ...)`, which checks if the value of the resolved input contains the specified `multisigCert` using `pvalueOfOne`.\n  - `pif`: A conditional expression that executes the first branch if the condition is true, otherwise executes the second branch.\n    - If the condition is true (i.e., the multisig certificate is found in the inputs), it returns `popaque $ pconstant ()`, which represents a successful execution.\n    - If the condition is false, it calls `perror`, causing the script to fail.\n\n### Summary\n\n- **`pAlwaysFails`**: A validator script that always fails, regardless of the input. This could be used for testing or as a placeholder.\n- **`pAuthMint`**: A minting policy that checks if a specific multisig certificate is present in the transaction inputs. If the certificate is found, the minting is authorized; otherwise, it fails.\n\nThis code demonstrates basic patterns in Plutarch for writing validator and minting policy scripts, including handling transaction contexts and using utility functions to check conditions.", "file_path": "iscovery/src/AlwaysFails.hs", "file": "AlwaysFails.hs"}
{"instruction": "Explain the following smart contract code:", "input": "module Main (main) where\n\nimport Data.List.Extra (trim)\nimport Data.Maybe (mapMaybe)\nimport Prettyprinter\nimport Text.Regex.TDFA\nimport Text.Regex.TDFA.String (compile)\nimport Text.XML.Light\nimport Prelude\n\ndata Tree = Section String [Tree] | Leaf String [String] deriving (Show)\n\n-- | Reads stdin which should be the benchmark tests XML contents and outputs to stdout\n-- | a YAML style formatted report with endpoint limits.\nmain :: IO ()\nmain = do\n  input <- getContents\n  let [_, Elem Element {elContent = [Elem body]}] = parseXML input\n  putStr (show $ vsep (fmap formatTree (parseTree body)) <+> line')\n\nreportRegex :: Regex\nRight reportRegex =\n  compile\n    defaultCompOpt {multiline = True}\n    defaultExecOpt\n    \"size[[:space:]]*: [[:digit:]]*\\\\.[[:digit:]]*\\\\%[[:space:]]*mem[[:space:]]*: [[:digit:]]*\\\\.[[:digit:]]*\\\\%[[:space:]]*steps[[:space:]]*: [[:digit:]]*\\\\.[[:digit:]]*\\\\%\"\n\nparseTree :: Element -> [Tree]\nparseTree Element {elContent = content} =\n  mapMaybe\n    ( \\case\n        Elem Element {elAttribs = attr : _, elContent = [Elem Element {elName = QName {qName = \"failure\"}, elContent = [Text failDat]}]} ->\n          case parseReport (cdData failDat) of\n            Just a -> Just $ Leaf (attrVal attr) a\n            Nothing -> Just $ Leaf (attrVal attr) [\"Could not parse\"]\n        Elem el ->\n          if null (elContent el)\n            then Nothing\n            else case elAttribs el of\n              attr : _ -> Just $ Section (attrVal attr) (parseTree el)\n              _ -> Nothing\n        _ -> Nothing\n    )\n    content\n  where\n    parseReport :: String -> Maybe [String]\n    parseReport a =\n      let allMatches = getAllTextMatches (match reportRegex a)\n       in if null allMatches\n            then Nothing\n            else\n              let l = lines $ last allMatches\n               in Just $ trim <$> drop (length l - 3) l\n\nformatTree :: Tree -> Doc a\nformatTree (Leaf name content) = nest 2 (vsep (pretty <$> ((name <> \":\") : content)))\nformatTree (Section name contents) = nest 2 $ vsep (pretty (name <> \":\") : (formatTree <$> contents))\n", "output": "This Haskell code is a Cardano smart contract utility that processes XML benchmark test results and outputs a formatted report in a YAML-like style. Let's break down the code step by step:\n\n### Module and Imports\n\n```haskell\nmodule Main (main) where\n```\n\nThis defines the `Main` module and exports the `main` function, which is the entry point of the program.\n\n```haskell\nimport Data.List.Extra (trim)\nimport Data.Maybe (mapMaybe)\nimport Prettyprinter\nimport Text.Regex.TDFA\nimport Text.Regex.TDFA.String (compile)\nimport Text.XML.Light\nimport Prelude\n```\n\nThese are the necessary imports:\n- `Data.List.Extra (trim)`: Provides a function to trim whitespace from strings.\n- `Data.Maybe (mapMaybe)`: Provides a function to map over a list and filter out `Nothing` values.\n- `Prettyprinter`: Used for pretty-printing the output.\n- `Text.Regex.TDFA`: Provides regular expression functionality.\n- `Text.Regex.TDFA.String (compile)`: Used to compile regular expressions.\n- `Text.XML.Light`: Used for parsing XML data.\n- `Prelude`: Standard Haskell library.\n\n### Data Types\n\n```haskell\ndata Tree = Section String [Tree] | Leaf String [String] deriving (Show)\n```\n\nThis defines a recursive data type `Tree` with two constructors:\n- `Section String [Tree]`: Represents a section with a name and a list of sub-trees.\n- `Leaf String [String]`: Represents a leaf node with a name and a list of strings (content).\n\n### Main Function\n\n```haskell\nmain :: IO ()\nmain = do\n  input <- getContents\n  let [_, Elem Element {elContent = [Elem body]}] = parseXML input\n  putStr (show $ vsep (fmap formatTree (parseTree body)) <+> line')\n```\n\n- `getContents`: Reads the entire input from standard input (stdin), which is expected to be XML content.\n- `parseXML input`: Parses the XML input into a list of `Content` elements.\n- The pattern match `[_, Elem Element {elContent = [Elem body]}]` extracts the main body of the XML.\n- `parseTree body`: Parses the XML body into a list of `Tree` structures.\n- `formatTree`: Formats each `Tree` into a pretty-printed document.\n- `vsep`: Vertically separates the formatted documents.\n- `putStr`: Outputs the final formatted document to standard output (stdout).\n\n### Regular Expression\n\n```haskell\nreportRegex :: Regex\nRight reportRegex =\n  compile\n    defaultCompOpt {multiline = True}\n    defaultExecOpt\n    \"size[[:space:]]*: [[:digit:]]*\\\\.[[:digit:]]*\\\\%[[:space:]]*mem[[:space:]]*: [[:digit:]]*\\\\.[[:digit:]]*\\\\%[[:space:]]*steps[[:space:]]*: [[:digit:]]*\\\\.[[:digit:]]*\\\\%\"\n```\n\n- `reportRegex`: A compiled regular expression used to match specific patterns in the XML content.\n- The pattern looks for lines containing \"size\", \"mem\", and \"steps\" with percentage values.\n\n### Parsing the XML Tree\n\n```haskell\nparseTree :: Element -> [Tree]\nparseTree Element {elContent = content} =\n  mapMaybe\n    ( \\case\n        Elem Element {elAttribs = attr : _, elContent = [Elem Element {elName = QName {qName = \"failure\"}, elContent = [Text failDat]}]} ->\n          case parseReport (cdData failDat) of\n            Just a -> Just $ Leaf (attrVal attr) a\n            Nothing -> Just $ Leaf (attrVal attr) [\"Could not parse\"]\n        Elem el ->\n          if null (elContent el)\n            then Nothing\n            else case elAttribs el of\n              attr : _ -> Just $ Section (attrVal attr) (parseTree el)\n              _ -> Nothing\n        _ -> Nothing\n    )\n    content\n```\n\n- `parseTree`: Converts XML elements into a list of `Tree` structures.\n- `mapMaybe`: Maps over the XML content and filters out `Nothing` values.\n- The lambda function uses pattern matching to handle different XML structures:\n  - If an element has a \"failure\" child, it attempts to parse the failure data using `parseReport`.\n  - If parsing is successful, it creates a `Leaf` with the attribute value and parsed content.\n  - If parsing fails, it creates a `Leaf` with a \"Could not parse\" message.\n  - If an element has no content, it returns `Nothing`.\n  - Otherwise, it creates a `Section` with the attribute value and recursively parses its children.\n\n### Parsing the Report\n\n```haskell\nparseReport :: String -> Maybe [String]\nparseReport a =\n  let allMatches = getAllTextMatches (match reportRegex a)\n   in if null allMatches\n        then Nothing\n        else\n          let l = lines $ last allMatches\n           in Just $ trim <$> drop (length l - 3) l\n```\n\n- `parseReport`: Attempts to extract relevant data from a string using the regular expression.\n- `getAllTextMatches`: Finds all matches of the regex in the input string.\n- If no matches are found, it returns `Nothing`.\n- If matches are found, it processes the last match, trims whitespace, and returns the last three lines.\n\n### Formatting the Tree\n\n```haskell\nformatTree :: Tree -> Doc a\nformatTree (Leaf name content) = nest 2 (vsep (pretty <$> ((name <> \":\") : content)))\nformatTree (Section name contents) = nest 2 $ vsep (pretty (name <> \":\") : (formatTree <$> contents))\n```\n\n- `formatTree`: Converts a `Tree` into a pretty-printed document.\n- `Leaf`: Indents the content by 2 spaces and formats it with the name followed by its content.\n- `Section`: Indents the section name and recursively formats its contents.\n\nOverall, this code is designed to process XML benchmark results, extract specific performance metrics, and output them in a human-readable format.", "file_path": "indigo-smart-contracts/format-benchmarks/Main.hs", "file": "Main.hs"}
{"instruction": "Explain the following smart contract code:", "input": "import re\nfrom copy import copy\nfrom typing import Optional\nfrom enum import Enum\n\nfrom ..util import CompilingNodeTransformer\nfrom ..typed_ast import *\n\n\"\"\"\nChecks that there was an import of wraps_builtin if there are any wrapped builtins\n\"\"\"\n\nDECORATOR_NAME = \"wraps_builtin\"\n\n\nclass RewriteImportUPLCBuiltins(CompilingNodeTransformer):\n    step = \"Resolving imports and usage of UPLC builtins\"\n\n    imports_uplc_builtins = False\n\n    def visit_ImportFrom(self, node: ImportFrom) -> Optional[AST]:\n        if node.module != \"opshin.bridge\":\n            return node\n        for n in node.names:\n            assert (\n                n.name == DECORATOR_NAME\n            ), \"Imports something other from the bridge than the builtin wrapper\"\n            assert n.asname is None, \"Renames the builtin wrapper. This is forbidden.\"\n        self.imports_uplc_builtins = True\n        return None\n\n    def visit_FunctionDef(self, node: TypedFunctionDef) -> AST:\n        if not node.decorator_list or len(node.decorator_list) != 1:\n            return node\n        is_wrapped = any(isinstance(n, Name) and n.id for n in node.decorator_list)\n        if not is_wrapped:\n            return node\n        assert (\n            self.imports_uplc_builtins\n        ), \"To wrap builtin functions, you need to import the builtin function. Add `from opshin.bridge import wraps_builtin` to your code.\"\n        # we replace the body with a forwarded call to the wrapped builtin\n        CamelCaseFunName = \"\".join(\n            p.capitalize() for p in re.split(r\"_(?!\\d)\", node.orig_name)\n        )\n        uplc_fun = plt.__dict__[CamelCaseFunName]\n        pluto_expression = RawPlutoExpr(\n            typ=node.typ.typ.rettyp,\n            expr=uplc_fun(\n                *(plt.Force(plt.Var(a.arg)) for a in node.args.args),\n            ),\n        )\n        node_cp = copy(node)\n        node_cp.body = [Return(pluto_expression, typ=node.typ.typ.rettyp)]\n        return node_cp\n", "output": "This code is part of a system that processes and transforms an abstract syntax tree (AST) for a smart contract written in a language that compiles to Cardano's Plutus Core. The specific task of this code is to ensure that any usage of wrapped built-in functions from the UPLC (Untyped Plutus Core) is correctly imported and used. Let's break down the code in detail:\n\n### Key Components\n\n1. **Imports and Constants:**\n   - The code imports several modules and classes, such as `re`, `copy`, and `Enum`, which are used for regular expressions, copying objects, and defining enumerations, respectively.\n   - `CompilingNodeTransformer` and `TypedFunctionDef` are imported from the local module, which are likely custom classes for handling AST transformations and typed function definitions.\n   - `DECORATOR_NAME` is a constant set to `\"wraps_builtin\"`, which is the name of the decorator expected to be used for wrapping built-in functions.\n\n2. **Class `RewriteImportUPLCBuiltins`:**\n   - This class inherits from `CompilingNodeTransformer`, indicating it is designed to transform nodes in an AST during the compilation process.\n   - The class has a class-level attribute `step` that describes its role in the compilation process: \"Resolving imports and usage of UPLC builtins\".\n   - `imports_uplc_builtins` is a boolean attribute initialized to `False`, used to track whether the necessary import statement has been encountered.\n\n3. **Method `visit_ImportFrom`:**\n   - This method processes `ImportFrom` nodes in the AST, which represent import statements like `from module import name`.\n   - It checks if the module being imported from is `\"opshin.bridge\"`. If not, it returns the node unchanged.\n   - For each name being imported, it asserts that the name is exactly `DECORATOR_NAME` and that it is not being renamed (i.e., `asname` is `None`).\n   - If these conditions are met, it sets `imports_uplc_builtins` to `True`, indicating that the necessary import has been found.\n\n4. **Method `visit_FunctionDef`:**\n   - This method processes `FunctionDef` nodes, which represent function definitions in the AST.\n   - It checks if the function has exactly one decorator. If not, it returns the node unchanged.\n   - It verifies if the decorator is a name and matches the expected decorator (`wraps_builtin`).\n   - If the function is wrapped, it asserts that `imports_uplc_builtins` is `True`. If not, it raises an assertion error, instructing the user to add the necessary import statement.\n   - If the function is correctly wrapped and imported, it transforms the function body to forward the call to the corresponding UPLC built-in function:\n     - It constructs a CamelCase version of the original function name.\n     - It retrieves the corresponding UPLC function from a dictionary (`plt.__dict__`).\n     - It creates a `RawPlutoExpr` object representing the call to the UPLC function, with the function's arguments being forced (evaluated immediately).\n     - It copies the original function node and replaces its body with a `Return` statement that returns the `RawPlutoExpr`.\n\n### Summary\n\nThis code is part of a compilation process that ensures the correct usage of UPLC built-in functions in a smart contract. It checks for the necessary import of a decorator (`wraps_builtin`) and transforms functions that use this decorator to call the corresponding UPLC built-in functions directly. This transformation is crucial for ensuring that the smart contract correctly interfaces with the low-level UPLC functions provided by the Cardano blockchain.", "file_path": "opshin/opshin/rewrite/rewrite_import_uplc_builtins.py", "file": "rewrite_import_uplc_builtins.py"}
{"instruction": "Explain the following smart contract code:", "input": "{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}\n\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RecordWildCards #-}\n\nmodule Test.OneWaySwap.CloseSwap\n  ( \n    -- * Scenarios Tested\n    -- ** Scenarios that should succeed\n    regressionTest1\n  , regressionTest2\n  , regressionTest3\n\n    -- ** Scenarios that should fail\n  , failureTest1\n  , failureTest2\n  , failureTest3\n  , failureTest4\n  , failureTest5\n  , failureTest6\n  , failureTest7\n  , failureTest8\n    \n    -- ** Benchmark Tests\n  , benchTest1\n  , benchTest2\n    \n    -- * Full TestTree\n  , tests\n  ) where\n\nimport qualified Ledger.Value.CardanoAPI as LV\nimport qualified Ledger.Address as LA\nimport qualified PlutusLedgerApi.V2 as PV2\nimport qualified Ledger.CardanoWallet as Mock \nimport Test.Tasty (TestTree,testGroup)\nimport Data.String (fromString)\nimport Control.Monad (replicateM_,forM_)\n\nimport CardanoSwaps.OneWaySwap\nimport CardanoSwaps.Utils \n\nimport Test.Prelude\n\n-------------------------------------------------\n-- Initialize reference scripts.\n-------------------------------------------------\ninitializeReferenceScripts :: MonadEmulator m => m (TxOutRef,TxOutRef)\ninitializeReferenceScripts = do\n  let w1 = Mock.knownMockWallet 1\n  \n  void $ transact (Mock.mockWalletAddress w1) [refScriptAddress] [Mock.paymentPrivateKey w1] $\n    emptyTxParams\n      { outputs =\n          [ Output\n              { outputAddress = refScriptAddress\n              , outputValue = LV.lovelaceToValue 20_000_000\n              , outputDatum = NoOutputDatum\n              , outputReferenceScript = toReferenceScript $ Just beaconScript\n              }\n          , Output\n              { outputAddress = refScriptAddress\n              , outputValue = LV.lovelaceToValue 22_000_000\n              , outputDatum = NoOutputDatum\n              , outputReferenceScript = toReferenceScript $ Just swapScript\n              }\n          ]\n      }\n\n  (,) <$> txOutRefWithReferenceScript (scriptHash beaconScript)\n      <*> txOutRefWithReferenceScript (scriptHash swapScript)\n\n-------------------------------------------------\n-- Mint Test Tokens\n-------------------------------------------------\nmintTestTokens :: MonadEmulator m => Mock.MockWallet -> LV.Lovelace -> [(TokenName,Integer)] -> m ()\nmintTestTokens w lovelace ts = do\n  let walletAddress = Mock.mockWalletAddress w\n  void $ transact walletAddress [refScriptAddress] [Mock.paymentPrivateKey w] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = ts\n              , mintRedeemer = toRedeemer ()\n              , mintPolicy = toVersioned alwaysSucceedPolicy\n              , mintReference = Nothing\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = walletAddress\n              , outputValue = utxoValue lovelace $\n                  foldMap (uncurry $ PV2.singleton testTokenSymbol) ts\n              , outputDatum = NoOutputDatum\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      }\n\n-------------------------------------------------\n-- Regression Tests\n-------------------------------------------------\n-- | Close a single swap UTxO.\nregressionTest1 :: MonadEmulator m => m ()\nregressionTest1 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,1),(offerBeacon,1),(askBeacon,1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon 1\n                  , uncurry PV2.singleton (unOfferAsset offer) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      , referenceInputs = [mintRef]\n      }\n\n  swapRef <- \n    txOutRefWithValue $ \n      utxoValue 3_000_000 $ mconcat\n        [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n        , PV2.singleton beaconCurrencySymbol offerBeacon 1\n        , PV2.singleton beaconCurrencySymbol askBeacon 1\n        , uncurry PV2.singleton (unOfferAsset offer) 10\n        ]\n\n  -- Try to close the swap UTxO.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,-1),(offerBeacon,-1),(askBeacon,-1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs =\n          [ Input\n              { inputId = swapRef\n              , inputWitness = \n                  SpendWithPlutusReference spendRef InlineDatum (toRedeemer SpendWithMint)\n              }\n          ]\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-- | Close multiple valid Swap UTxOs. All swaps are for the same trading pair.\nregressionTest2 :: MonadEmulator m => m ()\nregressionTest2 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Try to create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,3),(offerBeacon,3),(askBeacon,3)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs = replicate 3 $\n          Output\n            { outputAddress = swapAddress\n            , outputValue = utxoValue 3_000_000 $ mconcat\n                [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                , PV2.singleton beaconCurrencySymbol askBeacon 1\n                , uncurry PV2.singleton (unOfferAsset offer) 10\n                ]\n            , outputDatum = OutputDatum $ toDatum swapDatum\n            , outputReferenceScript = toReferenceScript Nothing\n            }\n          \n      , referenceInputs = [mintRef]\n      }\n\n  swaps <- txOutRefsAndDatumsAtAddress @SwapDatum swapAddress\n\n  -- Try to close the swap UTxOs.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,-3),(offerBeacon,-3),(askBeacon,-3)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs = flip map swaps $ \\(swapRef,_) ->\n          Input\n            { inputId = swapRef\n            , inputWitness = \n                SpendWithPlutusReference spendRef InlineDatum (toRedeemer SpendWithMint)\n            }\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-- | Close multiple valid Swap UTxOs. All swaps are for unique trading pairs.\nregressionTest3 :: MonadEmulator m => m ()\nregressionTest3 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap1 Info\n      offer1 = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask1 = AskAsset (adaSymbol,adaToken)\n      pairBeacon1 = genPairBeaconName offer1 ask1\n      offerBeacon1 = genOfferBeaconName offer1\n      askBeacon1 = genAskBeaconName ask1\n      swapDatum1 = genSwapDatum offer1 ask1 (unsafeRatio 1_000_000 1) Nothing\n\n      -- Swap2 Info\n      offer2 = OfferAsset (testTokenSymbol,\"TestToken2\")\n      ask2 = ask1 -- same as swap1\n      pairBeacon2 = genPairBeaconName offer2 ask2\n      offerBeacon2 = genOfferBeaconName offer2\n      askBeacon2 = genAskBeaconName ask2\n      swapDatum2 = genSwapDatum offer2 ask2 (unsafeRatio 1_000_000 1) Nothing\n\n      -- Swap3 Info\n      offer3 = OfferAsset (testTokenSymbol,\"TestToken3\")\n      ask3 = ask1 -- same as swap1\n      pairBeacon3 = genPairBeaconName offer3 ask3\n      offerBeacon3 = genOfferBeaconName offer3\n      askBeacon3 = genAskBeaconName ask3\n      swapDatum3 = genSwapDatum offer3 ask3 (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 \n    [ (\"TestToken1\",1000)\n    , (\"TestToken2\",1000)\n    , (\"TestToken3\",1000)\n    ]\n\n  -- Try to create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = \n                  [ (pairBeacon1,1),(offerBeacon1,1),(askBeacon1,1) -- swap1\n                  , (pairBeacon2,1),(offerBeacon2,1),(askBeacon2,1) -- swap2\n                  , (pairBeacon3,1),(offerBeacon3,1),(askBeacon3,1) -- swap3\n                  ]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon1 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon1 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon1 1\n                  , uncurry PV2.singleton (unOfferAsset offer1) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum1\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          , Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon2 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon2 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon2 1\n                  , uncurry PV2.singleton (unOfferAsset offer2) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum2\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          , Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon3 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon3 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon3 1\n                  , uncurry PV2.singleton (unOfferAsset offer3) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum3\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      , referenceInputs = [mintRef]\n      }\n\n  swaps <- txOutRefsAndDatumsAtAddress @SwapDatum swapAddress\n\n  -- Try to create the swap UTxO.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = \n                  [ (pairBeacon1,-1),(offerBeacon1,-1),(askBeacon1,-1) -- swap1\n                  , (pairBeacon2,-1),(offerBeacon2,-1),(askBeacon2,-1) -- swap2\n                  , (pairBeacon3,-1),(offerBeacon3,-1),(askBeacon3,-1) -- swap3\n                  ]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs = flip map swaps $ \\(swapRef,_) ->\n          Input\n            { inputId = swapRef\n            , inputWitness = \n                SpendWithPlutusReference spendRef InlineDatum (toRedeemer SpendWithMint)\n            }\n      , referenceInputs = [spendRef,mintRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-------------------------------------------------\n-- Failure Tests\n-------------------------------------------------\n-- | When closing a single swap UTxO, withdraw the pair beacon.\nfailureTest1 :: MonadEmulator m => m ()\nfailureTest1 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,1),(offerBeacon,1),(askBeacon,1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon 1\n                  , uncurry PV2.singleton (unOfferAsset offer) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      , referenceInputs = [mintRef]\n      }\n\n  swapRef <- \n    txOutRefWithValue $ \n      utxoValue 3_000_000 $ mconcat\n        [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n        , PV2.singleton beaconCurrencySymbol offerBeacon 1\n        , PV2.singleton beaconCurrencySymbol askBeacon 1\n        , uncurry PV2.singleton (unOfferAsset offer) 10\n        ]\n\n  -- Try to close the swap UTxO.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,0),(offerBeacon,-1),(askBeacon,-1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs =\n          [ Input\n              { inputId = swapRef\n              , inputWitness = \n                  SpendWithPlutusReference spendRef InlineDatum (toRedeemer SpendWithMint)\n              }\n          ]\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-- | When closing a single swap UTxO, withdraw the offer beacon.\nfailureTest2 :: MonadEmulator m => m ()\nfailureTest2 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,1),(offerBeacon,1),(askBeacon,1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon 1\n                  , uncurry PV2.singleton (unOfferAsset offer) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      , referenceInputs = [mintRef]\n      }\n\n  swapRef <- \n    txOutRefWithValue $ \n      utxoValue 3_000_000 $ mconcat\n        [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n        , PV2.singleton beaconCurrencySymbol offerBeacon 1\n        , PV2.singleton beaconCurrencySymbol askBeacon 1\n        , uncurry PV2.singleton (unOfferAsset offer) 10\n        ]\n\n  -- Try to close the swap UTxO.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,-1),(offerBeacon,0),(askBeacon,-1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs =\n          [ Input\n              { inputId = swapRef\n              , inputWitness = \n                  SpendWithPlutusReference spendRef InlineDatum (toRedeemer SpendWithMint)\n              }\n          ]\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-- | When closing a single swap UTxO, withdraw the ask beacon.\nfailureTest3 :: MonadEmulator m => m ()\nfailureTest3 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,1),(offerBeacon,1),(askBeacon,1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon 1\n                  , uncurry PV2.singleton (unOfferAsset offer) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      , referenceInputs = [mintRef]\n      }\n\n  swapRef <- \n    txOutRefWithValue $ \n      utxoValue 3_000_000 $ mconcat\n        [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n        , PV2.singleton beaconCurrencySymbol offerBeacon 1\n        , PV2.singleton beaconCurrencySymbol askBeacon 1\n        , uncurry PV2.singleton (unOfferAsset offer) 10\n        ]\n\n  -- Try to close the swap UTxO.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,-1),(offerBeacon,-1),(askBeacon,0)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs =\n          [ Input\n              { inputId = swapRef\n              , inputWitness = \n                  SpendWithPlutusReference spendRef InlineDatum (toRedeemer SpendWithMint)\n              }\n          ]\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-- | When closing a single swap UTxO, withdraw all of the beacons with the `SpendWithMint` redeemer.\nfailureTest4 :: MonadEmulator m => m ()\nfailureTest4 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,1),(offerBeacon,1),(askBeacon,1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon 1\n                  , uncurry PV2.singleton (unOfferAsset offer) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      , referenceInputs = [mintRef]\n      }\n\n  swapRef <- \n    txOutRefWithValue $ \n      utxoValue 3_000_000 $ mconcat\n        [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n        , PV2.singleton beaconCurrencySymbol offerBeacon 1\n        , PV2.singleton beaconCurrencySymbol askBeacon 1\n        , uncurry PV2.singleton (unOfferAsset offer) 10\n        ]\n\n  -- Try to close the swap UTxO.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,0),(offerBeacon,0),(askBeacon,0)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs =\n          [ Input\n              { inputId = swapRef\n              , inputWitness = \n                  SpendWithPlutusReference spendRef InlineDatum (toRedeemer SpendWithMint)\n              }\n          ]\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-- | When closing a single swap UTxO, withdraw all of the beacons with the `SpendWithStake` \n-- redeemer. The beacon script is not executed as a staking script.\nfailureTest5 :: MonadEmulator m => m ()\nfailureTest5 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,1),(offerBeacon,1),(askBeacon,1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon 1\n                  , uncurry PV2.singleton (unOfferAsset offer) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      , referenceInputs = [mintRef]\n      }\n\n  swapRef <- \n    txOutRefWithValue $ \n      utxoValue 3_000_000 $ mconcat\n        [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n        , PV2.singleton beaconCurrencySymbol offerBeacon 1\n        , PV2.singleton beaconCurrencySymbol askBeacon 1\n        , uncurry PV2.singleton (unOfferAsset offer) 10\n        ]\n\n  -- Try to close the swap UTxO.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,0),(offerBeacon,0),(askBeacon,0)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs =\n          [ Input\n              { inputId = swapRef\n              , inputWitness = \n                  SpendWithPlutusReference spendRef InlineDatum (toRedeemer SpendWithStake)\n              }\n          ]\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-- | When closing a single swap UTxO, withdraw all of the beacons with the `SpendWithStake` \n-- redeemer. The beacon script is executed as a staking script.\nfailureTest6 :: MonadEmulator m => m ()\nfailureTest6 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,1),(offerBeacon,1),(askBeacon,1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon 1\n                  , uncurry PV2.singleton (unOfferAsset offer) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      , referenceInputs = [mintRef]\n      }\n\n  swapRef <- \n    txOutRefWithValue $ \n      utxoValue 3_000_000 $ mconcat\n        [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n        , PV2.singleton beaconCurrencySymbol offerBeacon 1\n        , PV2.singleton beaconCurrencySymbol askBeacon 1\n        , uncurry PV2.singleton (unOfferAsset offer) 10\n        ]\n\n  -- Try to close the swap UTxO.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { inputs =\n          [ Input\n              { inputId = swapRef\n              , inputWitness = \n                  SpendWithPlutusReference spendRef InlineDatum $ toRedeemer SpendWithStake\n              }\n          ]\n      , withdrawals =\n          [ Withdrawal\n              { withdrawalCredential = PV2.ScriptCredential $ scriptHash beaconScript\n              , withdrawalAmount = 0\n              , withdrawalWitness = \n                  StakeWithPlutusReference mintRef $ toRedeemer UpdateSwaps\n              }\n          ]\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-- | When closing a single swap UTxO, mint a non-beacon asset with the minting policy.\nfailureTest7 :: MonadEmulator m => m ()\nfailureTest7 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,1),(offerBeacon,1),(askBeacon,1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon 1\n                  , uncurry PV2.singleton (unOfferAsset offer) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      , referenceInputs = [mintRef]\n      }\n\n  swapRef <- \n    txOutRefWithValue $ \n      utxoValue 3_000_000 $ mconcat\n        [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n        , PV2.singleton beaconCurrencySymbol offerBeacon 1\n        , PV2.singleton beaconCurrencySymbol askBeacon 1\n        , uncurry PV2.singleton (unOfferAsset offer) 10\n        ]\n\n  -- Try to close the swap UTxO.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(\"other\",1),(pairBeacon,-1),(offerBeacon,-1),(askBeacon,-1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs =\n          [ Input\n              { inputId = swapRef\n              , inputWitness = \n                  SpendWithPlutusReference spendRef InlineDatum (toRedeemer SpendWithMint)\n              }\n          ]\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-- | When closing a single swap UTxO, the address' staking credential did not approve.\nfailureTest8 :: MonadEmulator m => m ()\nfailureTest8 = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n      -- Other Info\n      otherWallet = Mock.knownMockWallet 2\n      otherPersonalAddr = Mock.mockWalletAddress otherWallet\n      otherPayPrivKey = Mock.paymentPrivateKey otherWallet\n      otherPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash otherWallet\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Create the swap UTxO.\n  void $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,1),(offerBeacon,1),(askBeacon,1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs =\n          [ Output\n              { outputAddress = swapAddress\n              , outputValue = utxoValue 3_000_000 $ mconcat\n                  [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                  , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                  , PV2.singleton beaconCurrencySymbol askBeacon 1\n                  , uncurry PV2.singleton (unOfferAsset offer) 10\n                  ]\n              , outputDatum = OutputDatum $ toDatum swapDatum\n              , outputReferenceScript = toReferenceScript Nothing\n              }\n          ]\n      , referenceInputs = [mintRef]\n      }\n\n  swapRef <- \n    txOutRefWithValue $ \n      utxoValue 3_000_000 $ mconcat\n        [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n        , PV2.singleton beaconCurrencySymbol offerBeacon 1\n        , PV2.singleton beaconCurrencySymbol askBeacon 1\n        , uncurry PV2.singleton (unOfferAsset offer) 10\n        ]\n\n  -- Try to close the swap UTxO.\n  void $ transact otherPersonalAddr [swapAddress,refScriptAddress] [otherPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = [(pairBeacon,-1),(offerBeacon,-1),(askBeacon,-1)]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs =\n          [ Input\n              { inputId = swapRef\n              , inputWitness = \n                  SpendWithPlutusReference spendRef InlineDatum (toRedeemer SpendWithMint)\n              }\n          ]\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [otherPubKey]\n      }\n\n-------------------------------------------------\n-- Benchmark Tests\n-------------------------------------------------\n-- | Close multiple swaps for the same trading pair.\nbenchTest1 :: MonadEmulator m => Int -> m ()\nbenchTest1 number = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Swap Info\n      offer = OfferAsset (testTokenSymbol,\"TestToken1\")\n      ask = AskAsset (adaSymbol,adaToken)\n      pairBeacon = genPairBeaconName offer ask\n      offerBeacon = genOfferBeaconName offer\n      askBeacon = genAskBeaconName ask\n      swapDatum = genSwapDatum offer ask (unsafeRatio 1_000_000 1) Nothing\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 10_000_000 [(\"TestToken1\",1000)]\n\n  -- Create the swap UTxOs.\n  replicateM_ 3 $ transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = \n                  [ (pairBeacon,25)\n                  , (offerBeacon,25)\n                  , (askBeacon,25)\n                  ]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , outputs = replicate 25 $\n          Output\n            { outputAddress = swapAddress\n            , outputValue = utxoValue 3_000_000 $ mconcat\n                [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                , PV2.singleton beaconCurrencySymbol askBeacon 1\n                , uncurry PV2.singleton (unOfferAsset offer) 10\n                ]\n            , outputDatum = OutputDatum $ toDatum swapDatum\n            , outputReferenceScript = toReferenceScript Nothing\n            }\n      , referenceInputs = [mintRef]\n      }\n          \n  swaps <- take number <$> txOutRefsAndDatumsAtAddress @SwapDatum swapAddress\n\n  -- Try to close the swap UTxOs.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = \n                  [ (pairBeacon,fromIntegral (-number))\n                  , (offerBeacon,fromIntegral (-number))\n                  , (askBeacon,fromIntegral (-number))\n                  ]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs = flip map swaps $ \\(swapRef,_) ->\n          Input\n            { inputId = swapRef\n            , inputWitness = \n                SpendWithPlutusReference spendRef InlineDatum $ toRedeemer SpendWithMint\n            }\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-- | Close multiple swap UTxOs for different trading pairs. \nbenchTest2 :: MonadEmulator m => Int -> m ()\nbenchTest2 number = do\n  let -- Seller Info\n      sellerWallet = Mock.knownMockWallet 1\n      sellerPersonalAddr = Mock.mockWalletAddress sellerWallet\n      sellerPayPrivKey = Mock.paymentPrivateKey sellerWallet\n      sellerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash sellerWallet\n      swapAddress = toCardanoApiAddress $\n        PV2.Address (PV2.ScriptCredential $ scriptHash swapScript) \n                    (Just $ PV2.StakingHash $ PV2.PubKeyCredential sellerPubKey)\n\n      -- Other Info\n      assetNames = map (\\i -> fromString $ \"TestToken\" <> show @Int i) [1..120]\n\n      -- Swap Info\n      offers = map (\\name -> OfferAsset (testTokenSymbol,name)) $ drop 60 assetNames\n      asks = map (\\name -> AskAsset (testTokenSymbol,name)) $ take 60 assetNames\n      pairs = zip offers asks\n      datums = \n        flip map pairs $ \\(offer,ask) -> \n          genSwapDatum offer ask (unsafeRatio 1 1) Nothing\n\n      sampleOutputs ds = flip map ds $ \\datum@SwapDatum{..} ->\n          Output\n            { outputAddress = swapAddress\n            , outputValue = utxoValue 3_000_000 $ mconcat\n                [ PV2.singleton beaconCurrencySymbol pairBeacon 1\n                , PV2.singleton beaconCurrencySymbol offerBeacon 1\n                , PV2.singleton beaconCurrencySymbol askBeacon 1\n                , PV2.singleton offerId offerName 10\n                ]\n            , outputDatum = OutputDatum $ toDatum datum\n            , outputReferenceScript = toReferenceScript Nothing\n            }\n\n  -- Initialize scenario\n  (mintRef,spendRef) <- initializeReferenceScripts \n  mintTestTokens sellerWallet 100_000_000 $ zip assetNames (repeat 1000)\n\n  -- Create the swap UTxO.\n  forM_ (grouped 20 datums) $ \\ds -> \n    transact sellerPersonalAddr [refScriptAddress] [sellerPayPrivKey] $\n      emptyTxParams\n        { tokens =\n            [ TokenMint\n                { mintTokens = flip concatMap ds $ \\SwapDatum{..} ->\n                    [ (pairBeacon,1)\n                    , (offerBeacon,1)\n                    , (askBeacon,1)\n                    ]\n                , mintRedeemer = toRedeemer CreateOrCloseSwaps\n                , mintPolicy = toVersionedMintingPolicy beaconScript\n                , mintReference = Just mintRef\n                }\n            ]\n        , outputs = sampleOutputs ds\n        , referenceInputs = [mintRef]\n        }\n\n  swaps <- take number <$> txOutRefsAndDatumsAtAddress @SwapDatum swapAddress\n\n  -- Try to close the swap UTxOs.\n  void $ transact sellerPersonalAddr [swapAddress,refScriptAddress] [sellerPayPrivKey] $\n    emptyTxParams\n      { tokens =\n          [ TokenMint\n              { mintTokens = flip concatMap swaps $ \\(_,Just SwapDatum{..}) ->\n                  [ (pairBeacon,-1)\n                  , (offerBeacon,-1)\n                  , (askBeacon,-1)\n                  ]\n              , mintRedeemer = toRedeemer CreateOrCloseSwaps\n              , mintPolicy = toVersionedMintingPolicy beaconScript\n              , mintReference = Just mintRef\n              }\n          ]\n      , inputs = flip map swaps $ \\(swapRef,_) ->\n          Input\n            { inputId = swapRef\n            , inputWitness = \n                SpendWithPlutusReference spendRef InlineDatum $ toRedeemer SpendWithMint\n            }\n      , referenceInputs = [mintRef,spendRef]\n      , extraKeyWitnesses = [sellerPubKey]\n      }\n\n-------------------------------------------------\n-- Test Function\n-------------------------------------------------\n-- | A `TestTree` containing all swap close scenarios.\ntests :: TestTree\ntests =\n  testGroup \"Close Swap(s)\"\n    [ -- Success Tests (Regression Tests)\n      mustSucceed \"regressionTest1\" regressionTest1\n    , mustSucceed \"regressionTest2\" regressionTest2\n    , mustSucceed \"regressionTest3\" regressionTest3\n\n      -- Failure Tests\n    , scriptMustFailWithError \"failureTest1\" \n        \"One-way swaps must have exactly three kinds of beacons\"\n        failureTest1\n    , scriptMustFailWithError \"failureTest2\" \n        \"One-way swaps must have exactly three kinds of beacons\"\n        failureTest2\n    , scriptMustFailWithError \"failureTest3\" \n        \"One-way swaps must have exactly three kinds of beacons\"\n        failureTest3\n    , scriptMustFailWithError \"failureTest4\" \n        \"Beacon script not executed as minting policy\"\n        failureTest4\n    , scriptMustFailWithError \"failureTest5\" \n        \"Beacon script not executed as staking script\"\n        failureTest5\n    , scriptMustFail \"failureTest6\" failureTest6\n    , scriptMustFailWithError \"failureTest7\" \n        \"One-way swaps must have exactly three kinds of beacons\"\n        failureTest7\n    , scriptMustFailWithError \"failureTest8\" \n        \"Staking credential did not approve\"\n        failureTest8\n\n      -- Benchmark Tests\n    , mustSucceed \"benchTest1\" $ benchTest1 56\n    , mustSucceed \"benchTest2\" $ benchTest2 56\n\n      -- Performance Increase Tests\n    , mustExceedTxLimits \"perfIncreaseTest1\" $ benchTest1 57\n    , mustExceedTxLimits \"perfIncreaseTest2\" $ benchTest2 57\n    ]\n", "output": "The provided Haskell code is a test suite for a Cardano smart contract module, specifically for testing the \"Close Swap\" functionality of a one-way swap contract. This code is part of a larger testing framework that uses the Plutus smart contract platform and the Cardano blockchain. Let's break down the key components and functionality of this code:\n\n### Module and Imports\n\n- **Module Declaration**: The module is named `Test.OneWaySwap.CloseSwap`. It exports several test functions and a `TestTree` named `tests`.\n- **Language Extensions**: The code uses several Haskell language extensions, such as `OverloadedStrings` and `RecordWildCards`, to facilitate more concise and flexible code.\n- **Imports**: The code imports various modules, including those for handling ledger values, addresses, Plutus V2 API, mock wallets, and testing utilities. These imports provide the necessary functions and types for constructing and testing transactions on the Cardano blockchain.\n\n### Key Functions and Components\n\n1. **initializeReferenceScripts**: \n   - This function initializes reference scripts by creating two outputs with specific scripts (`beaconScript` and `swapScript`) and returns their transaction output references. These references are used later in transactions to refer to these scripts.\n\n2. **mintTestTokens**:\n   - This function mints test tokens for a given wallet. It constructs a transaction that mints specified tokens and sends them to the wallet's address.\n\n3. **Regression Tests**:\n   - **regressionTest1, regressionTest2, regressionTest3**: These functions test scenarios where closing swap UTxOs should succeed. They involve setting up swap UTxOs with specific conditions and then attempting to close them by constructing and submitting transactions.\n\n4. **Failure Tests**:\n   - **failureTest1 to failureTest8**: These functions test scenarios where closing swap UTxOs should fail. Each test is designed to violate a specific rule or condition, such as withdrawing incorrect beacons, using incorrect redeemers, or not having the necessary approvals.\n\n5. **Benchmark Tests**:\n   - **benchTest1, benchTest2**: These functions test the performance of closing multiple swap UTxOs. They are designed to measure the transaction limits and performance of the contract under load.\n\n6. **TestTree `tests`**:\n   - This is a collection of all the test scenarios organized into a `TestTree`. It includes both success and failure tests, as well as benchmark tests. The `TestTree` is used by the testing framework to run all the tests and report results.\n\n### Testing Framework\n\n- The code uses a testing framework (`Test.Tasty`) to organize and run tests. Each test is defined with a name and a function that performs the test.\n- **mustSucceed** and **scriptMustFailWithError** are utility functions that assert whether a test should succeed or fail with a specific error message.\n\n### Smart Contract Context\n\n- The tests are designed to validate the behavior of a one-way swap contract on the Cardano blockchain. This involves creating, managing, and closing swap UTxOs (Unspent Transaction Outputs) with specific conditions and constraints.\n- The tests ensure that the contract behaves correctly under various scenarios, including edge cases and invalid operations.\n\n### Conclusion\n\nThis code is a comprehensive test suite for a specific aspect of a Cardano smart contract. It uses a combination of Haskell, Plutus, and Cardano-specific libraries to simulate and validate the behavior of the contract in a controlled environment. The tests cover both successful and failing scenarios, ensuring that the contract adheres to its intended logic and constraints.", "file_path": "no-swaps/test/Test/OneWaySwap/CloseSwap.hs", "file": "CloseSwap.hs"}
{"instruction": "Explain the following smart contract code:", "input": "-- | This module provides some predicates or assertions, that could be used together with\n--  `Test.Plutip.Contract.assertExecution` to run tests for Contract in private testnet.\n--\n--  Module also exports `Predicate` constructor itself, so any arbitrary predicate could be made.\nmodule Test.Plutip.Predicate (\n  Predicate (..),\n  pTag,\n  shouldSucceed,\n  Test.Plutip.Predicate.not,\n  shouldFail,\n  yieldSatisfies,\n  shouldYield,\n  errorSatisfies,\n  failReasonSatisfies,\n  shouldThrow,\n  stateSatisfies,\n  stateIs,\n  budgetsFitUnder,\n  policyLimit,\n  scriptLimit,\n  assertOverallBudget,\n  overallBudgetFits,\n  noBudgetsMessage,\n) where\n\nimport BotPlutusInterface.Types (TxBudget (TxBudget), mintBudgets, spendBudgets)\nimport Data.List.NonEmpty (NonEmpty)\nimport Data.Map (Map)\nimport Data.Map qualified as Map\nimport Ledger (ExBudget (ExBudget), ExCPU (ExCPU), ExMemory (ExMemory), TxId, Value)\nimport PlutusCore.Evaluation.Machine.ExMemory (CostingInteger)\nimport Prettyprinter (\n  Doc,\n  align,\n  defaultLayoutOptions,\n  indent,\n  layoutPretty,\n  viaShow,\n  vsep,\n  (<+>),\n )\nimport Prettyprinter.Render.String (renderString)\nimport Test.Plutip.Internal.Types (\n  ExecutionResult (ExecutionResult, contractState, outcome),\n  FailureReason (CaughtException, ContractExecutionError),\n  budgets,\n  isSuccessful,\n )\nimport Test.Plutip.Tools.Format (fmtExBudget, fmtTxBudgets)\nimport Text.Show.Pretty (ppShow)\n\n-- | Predicate is used to build test cases for Contract.\n--  List of predicates should be passed to `Test.Plutip.Contract.assertExecution`\n--  to make assertions about contract execution.\n--  Each predicate will result in separate test case.\n--\n-- @since 0.2\ndata Predicate w e a = Predicate\n  { -- | description for the case when predicate holds\n    positive :: String\n  , -- | description for the opposite of `positive` case (mostly for `not` functionality)\n    negative :: String\n  , -- | some useful debugging info that `Predicate` can print based on contract execution result,\n    -- used to print info in case of check failure\n    debugInfo :: ExecutionResult w e (a, NonEmpty Value) -> String\n  , -- | check that `Predicate` performs on Contract execution result,\n    -- if check evaluates to `False` test case considered failure\n    pCheck :: ExecutionResult w e (a, NonEmpty Value) -> Bool\n  }\n\n-- | `positive` description of `Predicate` that will be used as test case tag.\n--\n-- @since 0.2\npTag :: Predicate w e a -> String\npTag = positive\n\n-- | Switch the meaning of `Predicate` to the opposite.\n--\n-- @since 0.2\nnot :: Predicate w e a -> Predicate w e a\nnot predicate =\n  let (Predicate pos' neg' dbgInfo' check') = predicate\n   in Predicate neg' pos' dbgInfo' (Prelude.not . check')\n\n-- Predefined predicates --\n\n-- Basic success/fail --\n\n-- | Check that Contract didn't fail.\n--\n-- @since 0.2\nshouldSucceed :: (Show e, Show a, Show w) => Predicate w e a\nshouldSucceed =\n  Predicate\n    \"Contract should succeed\"\n    \"Contract should fail\"\n    (mappend \"But it didn't.\\nResult: \" . renderString . layoutPretty defaultLayoutOptions . prettyExecutionResult)\n    isSuccessful\n\n-- | Pretty print ExecutionResult hiding budget stats and logs.\nprettyExecutionResult :: (Show e, Show w, Show a) => ExecutionResult e w a -> Doc ann\nprettyExecutionResult ExecutionResult {outcome, contractState} =\n  vsep\n    [ \"Execution result {\"\n    , indent 4 $\n        align $\n          vsep\n            [ \"outcome:\" <+> viaShow outcome\n            , \"final state: \" <+> viaShow contractState\n            ]\n    , \"}\"\n    ]\n\n-- | Check that Contract didn't succeed.\n--\n-- @since 0.2\nshouldFail :: (Show e, Show a, Show w) => Predicate w e a\nshouldFail = Test.Plutip.Predicate.not shouldSucceed\n\n-- Contract result --\n\n-- | Check that Contract returned the expected value.\n--\n-- @since 0.2\nshouldYield :: (Show a, Eq a) => a -> Predicate w e a\nshouldYield expected =\n  (yieldSatisfies \"\" (== expected))\n    { positive = \"Should yield '\" <> ppShow expected <> \"'\"\n    , negative = \"Should NOT yield '\" <> ppShow expected <> \"'\"\n    }\n\n-- | Check that the returned value of the Contract satisfies the predicate.\n--\n--  Provided `String` description will be used in tes case tag.\n--\n-- @since 0.2\nyieldSatisfies :: (Show a) => String -> (a -> Bool) -> Predicate w e a\nyieldSatisfies description p =\n  Predicate\n    description\n    (\"Should violate '\" <> description <> \"'\")\n    debugInfo'\n    checkOutcome\n  where\n    debugInfo' r = case outcome r of\n      Left _ -> \"Contract failed\"\n      Right (a, _) -> \"Got: \" <> ppShow a\n\n    checkOutcome r =\n      case outcome r of\n        Left _ -> False\n        Right (a, _) -> p a\n\n-- Contract state --\n\n-- | Check that Contract has expected state after being executed.\n--  State will be accessible even if Contract failed.\n--\n-- @since 0.2\nstateIs :: (Show w, Eq w) => w -> Predicate w e a\nstateIs expected =\n  (stateSatisfies \"\" (== expected))\n    { positive = \"State should be '\" <> ppShow expected <> \"'\"\n    , negative = \"State should NOT be '\" <> ppShow expected <> \"'\"\n    }\n\n-- | Check that Contract after execution satisfies the predicate.\n--  State will be accessible even if Contract failed.\n--\n--  Provided `String` description will be used in test case tag.\n--\n-- @since 0.2\nstateSatisfies :: Show w => String -> (w -> Bool) -> Predicate w e a\nstateSatisfies description p =\n  Predicate\n    description\n    (\"Should violate '\" <> description <> \"'\")\n    debugInfo'\n    checkState\n  where\n    currentState = (\"Current state is: \" <>) . ppShow . contractState\n    debugInfo' r = case outcome r of\n      Left _ -> \"Contract failed.\\n\" <> currentState r\n      Right _ -> currentState r\n    checkState r = p (contractState r)\n\n-- Errors --\n\n-- | Check that Contract throws expected error.\n--  In case of exception that could happen during Contract execution,\n--  predicate won't hold.\n--\n-- @since 0.2\nshouldThrow :: (Show e, Eq e) => e -> Predicate w e a\nshouldThrow expected =\n  (errorSatisfies \"\" (== expected))\n    { positive = \"Should throw '\" <> ppShow expected <> \"'\"\n    , negative = \"Should NOT throw '\" <> ppShow expected <> \"'\"\n    }\n\n-- | Check that error thrown by Contract satisfies predicate.\n--  In case of exception that could happen during Contract execution,\n--  predicate won't hold.\n--\n--  Provided `String` description will be used in test case tag.\n--\n-- @since 0.2\nerrorSatisfies :: Show e => String -> (e -> Bool) -> Predicate w e a\nerrorSatisfies description p =\n  failReasonSatisfies description $ \\case\n    ContractExecutionError e -> p e\n    _ -> False\n\n-- | The most general check for possible Contract failure.\n--  Can examine any possible contract failure represented by `FailureReason`:\n--  errors thrown by contracts or exceptions that happened during the run.\n--  Provided `String` description will be used in test case tag.\n--\n-- @since 0.2\nfailReasonSatisfies :: Show e => String -> (FailureReason e -> Bool) -> Predicate w e a\nfailReasonSatisfies description p =\n  Predicate\n    description\n    (\"Should violate '\" <> description <> \"'\")\n    debugInfo'\n    checkOutcome\n  where\n    debugInfo' r = case outcome r of\n      Left e -> sayType e <> ppShow e\n      Right _ -> \"Contract didn't fail\"\n    checkOutcome r =\n      case outcome r of\n        Left e -> p e\n        Right _ -> False\n\n    sayType = \\case\n      CaughtException _ -> \"Exception was caught: \"\n      ContractExecutionError _ -> \"Error was thrown: \"\n\n-- | Check if overall budget (sum of all CPU and MEM budgets) less than or equal\n--  to specified limits.\n--\n-- If heck fails, all collected budgets will be printed to output.\n--\n-- @since 0.2\noverallBudgetFits :: ExCPU -> ExMemory -> Predicate w e a\noverallBudgetFits cpuLimit memLimit =\n  let p =\n        assertOverallBudget\n          (\"Budget should fit \" ++ fmtExBudget (ExBudget cpuLimit memLimit))\n          (<= cpuLimit)\n          (<= memLimit)\n   in p {negative = \"Budget should NOT fit \" ++ fmtExBudget (ExBudget cpuLimit memLimit)}\n\n-- | Check if overall cpu and mem budgets satisfy their predicates.\n-- (more general version of `overallBudgetFits`)\n--\n-- If heck fails, all collected budgets will be printed to output.\n--\n-- @since 0.2\nassertOverallBudget :: String -> (ExCPU -> Bool) -> (ExMemory -> Bool) -> Predicate w e a\nassertOverallBudget description cpuCheck memCheck =\n  let positive = description\n      negative = (\"Should violate '\" <> description <> \"'\")\n      debugInfo (budgets -> bs)\n        | null bs =\n          -- at least some budgets expected for assertion\n          noBudgetsMessage\n        | otherwise =\n          let budget = foldMap sumBudgets bs\n           in mconcat\n                [ \"Overall budget: \"\n                , fmtExBudget budget\n                , \"\\nBudget details:\\n\"\n                , fmtTxBudgets bs\n                ]\n\n      pCheck (budgets -> bs)\n        -- at least some budgets expected for assertion\n        | null bs = False\n        | otherwise =\n          let ExBudget cpu mem = foldMap sumBudgets bs\n           in cpuCheck cpu && memCheck mem\n\n      sumBudgets :: TxBudget -> ExBudget\n      sumBudgets (TxBudget spend mint) =\n        mconcat $ Map.elems spend ++ Map.elems mint\n   in Predicate {..}\n\n-- | More precise fitting assertion: it checks each script\n-- and minting policy budget if they fit specified limits. Limits are specified\n-- separately for scripts and minting policies.\n\n-- If check fails, any budget that didn't fit limit, will be printed to output.\n--\n-- @since 0.2\nbudgetsFitUnder :: Limit 'Script -> Limit 'Policy -> Predicate w e a\nbudgetsFitUnder (Limit sCpu sMem) (Limit pCpu pMem) =\n  let positive =\n        mconcat\n          [ \"Each script fits \"\n          , fmtExBudget (ExBudget sCpu sMem)\n          , \" and each policy fits \"\n          , fmtExBudget (ExBudget pCpu pMem)\n          ]\n      negative = \"TBD negative\"\n      debugInfo (budgets -> bs)\n        | null bs =\n          -- at least some budgets expected for assertion\n          noBudgetsMessage\n        | filtered <- processMap bs\n          , Prelude.not (null filtered) =\n          \"Budgets that didn't fit the limit :\\n\" ++ fmtTxBudgets filtered\n        | otherwise =\n          -- show at least some debug info\n          \"Collected budgets:\\n\" ++ fmtTxBudgets bs\n\n      pCheck (budgets -> bs) = null (processMap bs)\n      -- TODO: second iteration over stats happens here,\n      -- maybe `pCheck` and `debugInfo` could be somehow combined to avoid this\n\n      -- process a map with budgets collecting only those that do not fit into the specified limit\n      processMap :: Map TxId TxBudget -> Map TxId TxBudget\n      processMap =\n        Map.foldMapWithKey\n          ( \\txId bdg ->\n              let badOnes = findNonFitting bdg\n               in if isEmpty badOnes\n                    then -- if transaction doesn't have \"bad\" budgets,\n                    -- it won't be included into debug info\n                      mempty\n                    else Map.singleton txId badOnes\n          )\n\n      -- \"filter\" `TxBudget` by removing only script or minting budgets\n      -- that fit limits\n      findNonFitting b =\n        filterBudget (Prelude.not . fits sCpu sMem) (Prelude.not . fits pCpu pMem) b\n\n      fits cpuLimit memLimit (ExBudget cpu' mem') =\n        cpu' <= cpuLimit && mem' <= memLimit\n   in Predicate {..}\n\nnoBudgetsMessage :: String\nnoBudgetsMessage = \"Empty budgets data (probably, no scripts or policies in contract or contract failed)\"\n\n-- to protect from accidental `scriptLimit` <-> `policyLimit` swapping\n-- while making `budgetsFitUnder` predicate\ndata LimitType = Script | Policy\ndata Limit (a :: LimitType) = Limit ExCPU ExMemory\n  deriving stock (Show)\n\n-- | Construct script limit for `budgetsFitUnder`\nscriptLimit :: CostingInteger -> CostingInteger -> Limit a\nscriptLimit cpu mem =\n  Limit (ExCPU cpu) (ExMemory mem)\n\n-- | Construct policy limit for `budgetsFitUnder`\npolicyLimit :: CostingInteger -> CostingInteger -> Limit a\npolicyLimit cpu mem =\n  Limit (ExCPU cpu) (ExMemory mem)\n\n-- | Modifies (\"filters\") `TxBudget` in such a way, that it contains only\n-- script and minting policy budgets that satisfy predicates.\nfilterBudget :: (ExBudget -> Bool) -> (ExBudget -> Bool) -> TxBudget -> TxBudget\nfilterBudget spendFilter mintFilter txB =\n  let newSb = Map.filter spendFilter (spendBudgets txB)\n      newMb = Map.filter mintFilter (mintBudgets txB)\n   in TxBudget newSb newMb\n\nisEmpty :: TxBudget -> Bool\nisEmpty (TxBudget s p) = null s && null p\n", "output": "The provided Haskell module `Test.Plutip.Predicate` is part of a testing framework for Cardano smart contracts, specifically designed to work with the Plutus platform. This module defines a set of predicates or assertions that can be used to test the execution of smart contracts on a private testnet. Here's a detailed breakdown of the code:\n\n### Module Overview\n\n- **Purpose**: The module provides predicates to assert conditions on the execution of Plutus contracts. These predicates can be used with `Test.Plutip.Contract.assertExecution` to create test cases.\n- **Exports**: The module exports the `Predicate` data type and several predefined predicates for common assertions.\n\n### Key Components\n\n#### Predicate Data Type\n\n- **Definition**: \n  ```haskell\n  data Predicate w e a = Predicate\n    { positive :: String\n    , negative :: String\n    , debugInfo :: ExecutionResult w e (a, NonEmpty Value) -> String\n    , pCheck :: ExecutionResult w e (a, NonEmpty Value) -> Bool\n    }\n  ```\n  - **Fields**:\n    - `positive`: A description used when the predicate holds true.\n    - `negative`: A description used when the predicate does not hold (useful for negation).\n    - `debugInfo`: A function that provides debugging information based on the contract execution result.\n    - `pCheck`: A function that performs the actual check on the execution result, returning `True` if the predicate holds.\n\n- **Usage**: Predicates are used to define conditions that the contract execution results should satisfy. Each predicate corresponds to a test case.\n\n#### Predefined Predicates\n\n1. **Basic Success/Fail Checks**:\n   - `shouldSucceed`: Asserts that the contract execution was successful.\n   - `shouldFail`: Asserts that the contract execution failed. It is the negation of `shouldSucceed`.\n\n2. **Contract Result Checks**:\n   - `shouldYield`: Checks if the contract returned a specific expected value.\n   - `yieldSatisfies`: Checks if the returned value satisfies a given condition.\n\n3. **Contract State Checks**:\n   - `stateIs`: Checks if the contract's final state matches an expected state.\n   - `stateSatisfies`: Checks if the contract's final state satisfies a given condition.\n\n4. **Error Handling**:\n   - `shouldThrow`: Checks if the contract throws a specific error.\n   - `errorSatisfies`: Checks if the error thrown by the contract satisfies a given condition.\n   - `failReasonSatisfies`: A general check for any contract failure, examining the `FailureReason`.\n\n5. **Budget Checks**:\n   - `overallBudgetFits`: Checks if the overall CPU and memory budgets fit within specified limits.\n   - `assertOverallBudget`: A more general version of `overallBudgetFits`, allowing custom predicates for CPU and memory checks.\n   - `budgetsFitUnder`: Checks if each script and minting policy budget fits specified limits.\n\n#### Utility Functions\n\n- **`prettyExecutionResult`**: Pretty prints the execution result, excluding budget stats and logs, for debugging purposes.\n- **`filterBudget`**: Filters a `TxBudget` to include only those budgets that satisfy given predicates.\n- **`isEmpty`**: Checks if a `TxBudget` is empty, i.e., contains no spend or mint budgets.\n\n#### Budget Limit Types\n\n- **`LimitType` and `Limit`**: These types are used to define limits for scripts and policies, ensuring that the correct limits are applied in budget checks.\n- **`scriptLimit` and `policyLimit`**: Constructors for creating limits for scripts and policies, respectively.\n\n### Conclusion\n\nThis module is a crucial part of a testing framework for Plutus smart contracts, providing a flexible and extensible way to define and check conditions on contract execution. By using these predicates, developers can create comprehensive test suites to ensure their contracts behave as expected under various conditions.", "file_path": "plutip/src/Test/Plutip/Predicate.hs", "file": "Predicate.hs"}
{"instruction": "Explain the following smart contract code:", "input": "module PExtra.PTriple where\n\nimport Plutarch.Builtin (pconstrBuiltin, pforgetData)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\ntype PTuple3 a b c =\n    PDataSum\n        '[ '[ \"_0\" ':= a\n            , \"_1\" ':= b\n            , \"_2\" ':= c\n            ]\n         ]\n\nptuple3 :: Term s (PAsData a :--> PAsData b :--> PAsData c :--> PTuple3 a b c)\nptuple3 = phoistAcyclic $\n    plam $ \\x y z ->\n        let target :: Term _ (PAsData (PBuiltinPair PInteger (PBuiltinList PData)))\n            target = pconstrBuiltin # 0 #$ pcons # pforgetData x #$ pcons # pforgetData y #$ pcons # pforgetData z # pnil\n         in punsafeCoerce target\n", "output": "This Cardano smart contract code is written in Plutarch, a Haskell-based eDSL (embedded domain-specific language) for writing smart contracts on the Cardano blockchain. The code defines a data structure and a function to construct a triple (a tuple with three elements) using Plutarch's type system and functions.\n\nLet's break down the code step by step:\n\n### Module Declaration\n\n```haskell\nmodule PExtra.PTriple where\n```\n\nThis line declares a Haskell module named `PExtra.PTriple`. Modules in Haskell are used to group related functions, types, and typeclasses together.\n\n### Imports\n\n```haskell\nimport Plutarch.Builtin (pconstrBuiltin, pforgetData)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n```\n\n- `Plutarch.Builtin`: This module provides built-in functions for working with Plutarch's low-level data types. `pconstrBuiltin` is used to construct Plutarch data types, and `pforgetData` is used to convert `PAsData` types to their underlying representation.\n- `Plutarch.Prelude`: This module includes essential Plutarch functions and types.\n- `Plutarch.Unsafe`: This module provides unsafe operations, such as `punsafeCoerce`, which allows for type coercion without type checking.\n\n### Type Definition\n\n```haskell\ntype PTuple3 a b c =\n    PDataSum\n        '[ '[ \"_0\" ':= a\n            , \"_1\" ':= b\n            , \"_2\" ':= c\n            ]\n         ]\n```\n\n- `PTuple3 a b c`: This is a type alias for a Plutarch data type that represents a tuple with three elements. It uses `PDataSum`, which is a sum type (similar to a union type) that can hold different types of data.\n- The list `'[ '_0 ':= a, '_1 ':= b, '_2 ':= c ]` defines a single constructor with three fields, each associated with a type (`a`, `b`, and `c`).\n\n### Function Definition\n\n```haskell\nptuple3 :: Term s (PAsData a :--> PAsData b :--> PAsData c :--> PTuple3 a b c)\n```\n\n- `ptuple3`: This is a function that constructs a `PTuple3` from three `PAsData` values. `PAsData` is a wrapper type used in Plutarch to represent data that can be serialized on the blockchain.\n- The type signature indicates that `ptuple3` takes three arguments of types `PAsData a`, `PAsData b`, and `PAsData c`, and returns a `PTuple3 a b c`.\n\n```haskell\nptuple3 = phoistAcyclic $\n    plam $ \\x y z ->\n        let target :: Term _ (PAsData (PBuiltinPair PInteger (PBuiltinList PData)))\n            target = pconstrBuiltin # 0 #$ pcons # pforgetData x #$ pcons # pforgetData y #$ pcons # pforgetData z # pnil\n         in punsafeCoerce target\n```\n\n- `phoistAcyclic`: This is a Plutarch function that optimizes the function by hoisting it out of recursive contexts, ensuring it is evaluated only once.\n- `plam`: This is a Plutarch function that creates a lambda abstraction, allowing you to define a function with parameters `x`, `y`, and `z`.\n- `target`: This is a local variable that constructs a Plutarch data structure using `pconstrBuiltin`. It creates a built-in pair with an integer and a list of `PData`.\n  - `pconstrBuiltin # 0`: Constructs a data type with constructor index `0`.\n  - `pcons`: Constructs a list by prepending an element.\n  - `pforgetData`: Converts `PAsData` to its underlying `PData` representation.\n  - `pnil`: Represents an empty list.\n- `punsafeCoerce target`: This coerces the constructed data type to the desired `PTuple3 a b c` type. This is unsafe because it bypasses type checking, so it should be used with caution.\n\n### Summary\n\nThis code defines a type and a function to create a tuple with three elements in Plutarch. It uses low-level Plutarch functions to construct the data type and performs an unsafe type coercion to fit the desired type. This is useful in smart contracts where you need to handle multiple data types in a structured way.", "file_path": "no-dex-contracts/cardano-dex-contracts-onchain/PExtra/PTriple.hs", "file": "PTriple.hs"}
{"instruction": "Explain the following smart contract code:", "input": "{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule ErgoDex.PContracts.PDeposit (\n    DepositConfig (..),\n    depositValidatorT,\n) where\n\nimport qualified GHC.Generics as GHC\nimport Generics.SOP (Generic, I (I))\n\nimport Plutarch\nimport Plutarch.Api.V2.Contexts\nimport Plutarch.DataRepr\nimport Plutarch.Lift\nimport Plutarch.Prelude\nimport Plutarch.Api.V1 (PMaybeData, PPubKeyHash, PValue)\nimport Plutarch.Extra.TermCont\n\nimport PExtra.API\nimport PExtra.Ada\nimport PExtra.List (pelemAt)\nimport PExtra.Monadic (tlet, tletField, tmatch)\n\nimport ErgoDex.PContracts.PApi (containsSignature, getRewardValue', maxLqCap, pmin, tletUnwrap)\nimport ErgoDex.PContracts.POrder (OrderAction (Apply, Refund), OrderRedeemer)\n\nimport qualified ErgoDex.Contracts.Proxy.Deposit as D\n\nnewtype DepositConfig (s :: S)\n    = DepositConfig\n        ( Term\n            s\n            ( PDataRecord\n                '[ \"poolNft\" ':= PAssetClass\n                 , \"x\" ':= PAssetClass\n                 , \"y\" ':= PAssetClass\n                 , \"lq\" ':= PAssetClass\n                 , \"exFee\" ':= PInteger -- execution fee specified by the user\n                 , \"rewardPkh\" ':= PPubKeyHash -- PublicKeyHash of the user\n                 , \"stakePkh\" ':= PMaybeData PPubKeyHash\n                 , \"collateralAda\" ':= PInteger -- we reserve a small amount of ADA to put it into user output later\n                 ]\n            )\n        )\n    deriving stock (GHC.Generic)\n    deriving\n        (PIsData, PDataFields, PlutusType)\n\ninstance DerivePlutusType DepositConfig where type DPTStrat _ = PlutusTypeData\n\ninstance PUnsafeLiftDecl DepositConfig where type PLifted DepositConfig = D.DepositConfig\nderiving via (DerivePConstantViaData D.DepositConfig DepositConfig) instance (PConstantDecl D.DepositConfig)\n\ndepositValidatorT :: ClosedTerm (DepositConfig :--> OrderRedeemer :--> PScriptContext :--> PBool)\ndepositValidatorT = plam $ \\conf' redeemer' ctx' -> unTermCont $ do\n    ctx  <- pletFieldsC @'[\"txInfo\", \"purpose\"] ctx'\n    conf <- pletFieldsC @'[\"x\", \"y\", \"lq\", \"poolNft\", \"exFee\", \"rewardPkh\", \"stakePkh\", \"collateralAda\"] conf'\n    let \n        collateralAda = getField @\"collateralAda\" conf\n\n        rewardPkh = getField @\"rewardPkh\" conf\n        stakePkh  = getField @\"stakePkh\"  conf\n        exFee     = getField @\"exFee\" conf\n\n        x  = getField @\"x\"  conf\n        y  = getField @\"y\"  conf\n        lq = getField @\"lq\" conf\n\n        txInfo' = getField @\"txInfo\" ctx\n    \n    txInfo  <- pletFieldsC @'[\"inputs\", \"outputs\", \"signatories\"] txInfo'\n    inputs  <- tletUnwrap $ getField @\"inputs\"  txInfo\n    outputs <- tletUnwrap $ getField @\"outputs\" txInfo\n\n    redeemer <- pletFieldsC @'[\"poolInIx\", \"orderInIx\", \"rewardOutIx\", \"action\"] redeemer'\n    let \n      poolInIx    = getField @\"poolInIx\"    redeemer\n      orderInIx   = getField @\"orderInIx\"   redeemer\n      rewardOutIx = getField @\"rewardOutIx\" redeemer\n      action = getField @\"action\" redeemer\n\n    rewardOut   <- tlet $ pelemAt # rewardOutIx # outputs\n    rewardValue <- tlet $ getRewardValue' # rewardOut # rewardPkh # stakePkh\n\n    poolIn'   <- tlet $ pelemAt # poolInIx # inputs\n    poolIn    <- pletFieldsC @'[\"outRef\", \"resolved\"] poolIn'\n    poolValue <-\n        let pool = pfromData $ getField @\"resolved\" poolIn\n         in tletField @\"value\" pool\n    let poolIdentity = -- operation is performed with the pool selected by the user \n            let requiredNft = pfromData $ getField @\"poolNft\" conf\n                nftAmount = assetClassValueOf # poolValue # requiredNft\n             in nftAmount #== 1\n\n    selfIn'   <- tlet $ pelemAt # orderInIx # inputs\n    selfIn    <- pletFieldsC @'[\"outRef\", \"resolved\"] selfIn'\n    selfValue <-\n        let self = pfromData $ getField @\"resolved\" selfIn\n         in tletField @\"value\" self\n\n    PSpending selfRef' <- pmatchC $ getField @\"purpose\" ctx\n    let \n        selfIdentity =\n            let selfRef   = pfield @\"_0\" # selfRef'\n                selfInRef = getField @\"outRef\" selfIn\n             in selfRef #== selfInRef -- check that orderInIx points to the actual order\n\n        strictInputs = -- ensure double satisfaction attack is not possible\n            let inputsLength = plength # inputs\n             in inputsLength #== 2\n\n    liquidity <-\n        let lqNegative = assetClassValueOf # poolValue # lq\n         in tlet $ maxLqCap - lqNegative\n\n    reservesX <- tlet $ assetClassValueOf # poolValue # x\n    reservesY <- tlet $ assetClassValueOf # poolValue # y\n\n    minRewardByX <- tlet $ minAssetReward # selfValue # x # reservesX # liquidity # exFee # collateralAda\n    minRewardByY <- tlet $ minAssetReward # selfValue # y # reservesY # liquidity # exFee # collateralAda\n    let validChange = -- pair excess is returned to user\n            pif\n                (minRewardByX #== minRewardByY)\n                (pcon PTrue)\n                ( pif\n                    (minRewardByX #< minRewardByY)\n                    (validChange' # rewardValue # y # minRewardByY # minRewardByX # reservesY # liquidity)\n                    (validChange' # rewardValue # x # minRewardByX # minRewardByY # reservesX # liquidity)\n                )\n        minReward = pmin # minRewardByX # minRewardByY\n        validReward = -- calculated minimal output of LQ tokens is satisfied\n            let actualReward = assetClassValueOf # rewardValue # lq\n             in minReward #<= actualReward\n\n    pure $\n        pmatch action $ \\case\n            Apply -> poolIdentity #&& selfIdentity #&& strictInputs #&& validChange #&& validReward\n            Refund ->\n                let sigs = pfromData $ getField @\"signatories\" txInfo\n                 in containsSignature # sigs # rewardPkh -- user signed the refund\n\n-- Checks whether an asset overflow is returned back to user\nvalidChange' :: Term s (PValue _ _ :--> PAssetClass :--> PInteger :--> PInteger :--> PInteger :--> PInteger :--> PBool)\nvalidChange' =\n    phoistAcyclic $\n        plam $ \\rewardValue overflowAsset overflowAssetInput otherAssetInput overflowAssetReserves liquidity ->\n            let diff = overflowAssetInput - otherAssetInput\n                excess = pdiv # (diff * overflowAssetReserves) # liquidity\n                change = assetClassValueOf # rewardValue # overflowAsset\n             in excess #<= change\n\nminAssetReward :: Term s (PValue _ _ :--> PAssetClass :--> PInteger :--> PInteger :--> PInteger :--> PInteger :--> PInteger)\nminAssetReward =\n    phoistAcyclic $\n        plam $ \\selfValue asset assetReserves liquidity exFee collateralAda ->\n            unTermCont $ do\n                assetInput <- tlet $ assetClassValueOf # selfValue # asset\n                let depositInput = pif (pIsAda # asset) (assetInput - exFee - collateralAda) assetInput\n                pure $ pdiv # (depositInput * liquidity) # assetReserves\n", "output": "This Cardano smart contract code is written in Haskell using the Plutarch library, which is a domain-specific language (DSL) for writing Plutus smart contracts. The contract is part of the ErgoDex decentralized exchange and specifically handles deposit operations. Let's break down the code in detail:\n\n### Module and Imports\n\n- **Module Declaration**: The module is named `ErgoDex.PContracts.PDeposit` and it exports two things: `DepositConfig` and `depositValidatorT`.\n- **Language Extensions**: The code uses `ScopedTypeVariables` and `UndecidableInstances` extensions, which are common in Haskell for more flexible type handling.\n- **Imports**: The code imports various modules from Plutarch and other libraries, which provide the necessary functions and types for smart contract development.\n\n### Data Types and Instances\n\n- **`DepositConfig`**: This is a newtype wrapper around a `PDataRecord` that holds the configuration for a deposit operation. It includes fields like `poolNft`, `x`, `y`, `lq`, `exFee`, `rewardPkh`, `stakePkh`, and `collateralAda`. These fields represent various assets, execution fees, public key hashes, and collateral amounts involved in the deposit.\n\n- **Typeclass Instances**: \n  - `DerivePlutusType` and `PUnsafeLiftDecl` are used to derive necessary instances for `DepositConfig` to be used in Plutarch. \n  - `PConstantDecl` is derived via `DerivePConstantViaData`, linking the on-chain representation with an off-chain Haskell type.\n\n### Main Function: `depositValidatorT`\n\n- **Type Signature**: The function `depositValidatorT` is a Plutarch term that takes a `DepositConfig`, an `OrderRedeemer`, and a `PScriptContext`, and returns a `PBool`. This represents the validation logic for a deposit transaction.\n\n- **Function Body**: \n  - **Context and Configuration Extraction**: The function uses `pletFieldsC` to extract fields from the context (`ctx'`) and configuration (`conf'`). This includes transaction information and deposit parameters.\n  \n  - **Redeemer Fields**: The redeemer, which specifies the action to be taken (either `Apply` or `Refund`), is also decomposed into its fields.\n\n  - **Transaction Inputs and Outputs**: The function retrieves and processes transaction inputs and outputs to verify the transaction's validity.\n\n  - **Pool and Self Identity Checks**: \n    - **Pool Identity**: Ensures the operation is performed with the correct pool by checking the presence of a specific NFT.\n    - **Self Identity**: Verifies that the transaction input matches the expected order reference.\n\n  - **Strict Inputs Check**: Ensures there are exactly two inputs to prevent double satisfaction attacks.\n\n  - **Liquidity and Reserves Calculation**: Calculates available liquidity and reserves for assets `x` and `y`.\n\n  - **Reward Calculation**: Computes the minimum reward required for the transaction to be valid, based on the liquidity and reserves.\n\n  - **Validation Logic**: \n    - **Valid Change**: Ensures any excess assets are returned to the user.\n    - **Valid Reward**: Checks that the actual reward meets or exceeds the minimum required reward.\n\n  - **Action Matching**: \n    - **Apply**: Validates the transaction based on pool identity, self identity, input strictness, valid change, and valid reward.\n    - **Refund**: Ensures the refund is signed by the user.\n\n### Helper Functions\n\n- **`validChange'`**: Checks if any overflow of assets is correctly returned to the user. It calculates the excess and compares it to the change in the reward value.\n\n- **`minAssetReward`**: Computes the minimum asset reward required for a given asset, based on the input value, reserves, liquidity, execution fee, and collateral ADA.\n\n### Summary\n\nThis smart contract code is a validator for deposit operations on the ErgoDex platform. It ensures that deposits are processed correctly, with checks on pool identity, transaction inputs, and reward calculations. The contract uses Plutarch to define the logic in a way that can be executed on the Cardano blockchain, ensuring security and correctness of the deposit process.", "file_path": "no-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PDeposit.hs", "file": "PDeposit.hs"}
{"instruction": "Explain the following smart contract code:", "input": "{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Spec.Governance.Transactions\n  ( CreateProposalResult,\n    executeProposalSuccessfully,\n    executeProposalExploitSuccessfully,\n    createAssetProposal,\n    createMigrateProposal,\n    createDelistProposal,\n    runInitialize,\n    runInitGov,\n    runCreateProposal,\n    runCreateShards,\n    runVote,\n    runMergeShards,\n    runEndProposal,\n    runExecute,\n    runGovUpgrade,\n    runCollectorUpgrade,\n    identityDatumUpgradeCompiled,\n    versionIncrementGovDatumUpgradeCompiled,\n    versionIncrementGovDatumUpgrade,\n    runMergeShardsChunks,\n    runCreateShardsChunks,\n    runInitRefScriptGov,\n    runInitRefScriptPollManager,\n    runInitRefScriptPoll,\n    runInitRefScriptExecute,\n    runMergeShardsExploit,\n  )\nwhere\n\nimport Control.Monad (forM_, void, when)\nimport Data.List (unfoldr)\nimport Data.List.Split (chunksOf)\nimport GHC.Stack (HasCallStack)\nimport Indigo.Contracts.CDP.Common\n  ( CDPDatum (IAssetDatum),\n    CDPRedeemer (UpgradeAsset),\n    IAsset (IAsset),\n    iaMinRatio,\n    iaName,\n    iaPrice,\n  )\nimport Indigo.Contracts.Collector.Common (CollectorRedeemer (UpgradeVersion))\nimport Indigo.Contracts.Governance.Execute.Common qualified as Execute\nimport Indigo.Contracts.Governance.Gov.Common\n  ( GovDatum (Gov, currentProposal, currentVersion, protocolStartTime),\n  )\nimport Indigo.Contracts.Governance.Gov.Common qualified as Gov\nimport Indigo.Contracts.Governance.Poll.Common qualified as Poll\nimport Indigo.Contracts.Governance.VersionRegistry.Common\n  ( VersionRecord (VersionRecord, versionId, versionPaths),\n    VersionRecordMintingPolicyRedeemer (AddRecord),\n  )\nimport Indigo.Contracts.Oracle.Common (OracleAssetNFT)\nimport Indigo.Contracts.StabilityPool.Common\n  ( StabilityDatum\n      ( StabilityPoolDatum,\n        epochToScaleToSum,\n        spIAsset,\n        spSnapshot\n      ),\n    initEpochToScaleToSumMap,\n    initSPSnapshot,\n  )\nimport Indigo.Contracts.Staking.Common qualified as Staking\nimport Indigo.Data.Decimal (OnChainDecimal (OnChainDecimal))\nimport Indigo.Utils.Helpers (getTokenName, oneSecond, unitValue)\nimport Indigo.Utils.Spooky qualified as Spooky\nimport Ledger qualified\nimport Ledger.Ada qualified as Ada\nimport Ledger.Value qualified as Value\nimport Plutus.Model\n  ( DatumMode (InlineDatum),\n    Run,\n    Tx,\n    currentTime,\n    getMainUser,\n    mintValue,\n    payToKey,\n    payToRef,\n    payToScript,\n    refInputInline,\n    sendTx,\n    signTx,\n    spend,\n    spendScript,\n    spendScriptRef,\n    userSpend,\n    utxoAt,\n    validateIn,\n    validatorHash,\n    wait,\n    waitNSlots,\n  )\nimport Plutus.V2.Ledger.Api qualified as V2\nimport PlutusTx qualified\nimport PlutusTx.AssocMap qualified as AssocMap\nimport PlutusTx.Prelude hiding (mconcat, mempty, pure, ratio, (<>))\nimport PlutusTx.Prelude qualified as PlutusTx\nimport Spec.CDP.Helpers (cdpCreatorValue, findIAsset)\nimport Spec.CDP.Script (cdpCreatorScript, cdpScript)\nimport Spec.Collector.Script (collectorScript)\nimport Spec.Collector.Transactions (runInitCollector)\nimport Spec.Governance.Helpers\n  ( findAllPollShardsWithId,\n    findFirstPollShardWithId,\n    findGov,\n    findPollManagerWithId,\n    findUpgradeWithId,\n    findVersionRecordByValHash,\n    versionRecordOutputValue,\n  )\nimport Spec.Governance.Params\n  ( CreateProposalParam (CreateProposalParam, cpContent),\n    CreateShardsParam (CreateShardsParam, csEndTime, csId, csTotalShards),\n    EndParam (EndParam, eId, eTotalShards),\n    ExecuteParam (ExecuteParam, exId),\n    MergeShardsParam (MergeShardsParam, msId),\n    VoteParam (VoteParam, vId, vOption),\n  )\nimport Spec.Governance.Script\n  ( executeScript,\n    govScript,\n    pollManagerAddress,\n    pollManagerScript,\n    pollScript,\n    upgradePolicy,\n    versionRecordPolicy,\n    versionRegistryScript,\n  )\nimport Spec.StabilityPool.Script (stabilityPoolScript)\nimport Spec.Staking.Helpers (findStakingPosition)\nimport Spec.Staking.Params (OpenStakingPositionParam (OpenStakingPositionParam))\nimport Spec.Staking.Script (stakingScript)\nimport Spec.Staking.Transactions\n  ( OpenPositionVariation (OpenSucceed),\n    runInitStaking,\n    runOpenStakingPos,\n  )\nimport Spec.Treasury.Script (treasuryScript)\nimport Utils.Helpers (getFirstRefScript, initScriptRef, minLovelacesPerUtxo)\nimport Utils.MintPolicies (authPolicy)\nimport Utils.Mock qualified as Mock\nimport Prelude (Int, fail, fromIntegral, mconcat, mempty, pure, replicate, (<>))\n\nexecuteProposalSuccessfully :: CreateProposalResult -> Run ()\nexecuteProposalSuccessfully (pId, endTime, totalShards) = do\n  runCreateShards (CreateShardsParam pId endTime totalShards)\n  admin <- getMainUser\n  runVote admin (VoteParam pId Poll.Yes)\n  waitNSlots 10\n  runMergeShards (MergeShardsParam pId)\n  runEndProposal 0 (EndParam pId totalShards)\n  waitNSlots 3\n  runExecute (ExecuteParam pId)\n\nexecuteProposalExploitSuccessfully :: CreateProposalResult -> CreateProposalResult -> Run ()\nexecuteProposalExploitSuccessfully (pId1, endTime1, totalShards1) (pId2, endTime2, totalShards2) = do\n  runCreateShards (CreateShardsParam pId1 endTime1 totalShards1)\n  runCreateShards (CreateShardsParam pId2 endTime2 totalShards2)\n  admin <- getMainUser\n  runVote admin (VoteParam pId1 Poll.Yes)\n  runVote admin (VoteParam pId2 Poll.Yes)\n  waitNSlots 10\n  runMergeShards (MergeShardsParam pId1)\n  runMergeShards (MergeShardsParam pId2)\n  runEndProposal 0 (EndParam pId1 totalShards1)\n  runEndProposal 0 (EndParam pId2 totalShards2)\n  waitNSlots 3\n  runExecuteExploit (ExecuteParam pId1) (ExecuteParam pId2)\n\ncreateAssetProposal ::\n  Ledger.TokenName ->\n  OnChainDecimal ->\n  OracleAssetNFT ->\n  Run CreateProposalResult\ncreateAssetProposal token ratio oracleAssetNFT = do\n  let cpParam =\n        CreateProposalParam (Gov.ProposeAsset token ratio oracleAssetNFT)\n  runCreateProposal cpParam\n\nrunExecuteExploit :: HasCallStack => ExecuteParam -> ExecuteParam -> Run ()\nrunExecuteExploit ExecuteParam {exId = exId1} ExecuteParam {exId = exId2} = do\n  admin <- getMainUser\n  refScriptUtxoExecute <- getFirstRefScript (executeScript Mock.executeParams)\n  (orefm, om, govDatum) <- findGov\n\n  (oref1, _, upgrade1@Execute.Upgrade {Execute.uEndTime}) <-\n    findUpgradeWithId exId1 -- First text proposal\n  (oref2, _, upgrade2) <-\n    findUpgradeWithId exId2 -- Second text proposal, required for the exploit\n  let execution =\n        mconcat\n          [ refInputInline orefm,\n            payToKey admin (Ada.lovelaceValueOf minLovelacesPerUtxo),\n            payToKey admin (Ada.lovelaceValueOf minLovelacesPerUtxo)\n          ]\n\n  now <- currentTime\n  let pToken = Gov.pollToken Mock.govParams\n      uToken = Gov.upgradeToken Mock.govParams\n      upgradeTokenName = getTokenName uToken\n      now' = now - oneSecond\n      Gov.ProtocolParams {Gov.expirationPeriod} =\n        Gov.protocolParams govDatum\n  payValue <-\n    if now - oneSecond > uEndTime + expirationPeriod\n      then\n        validateIn\n          (Ledger.from now')\n          ( payToRef\n              (govScript Mock.govParams)\n              (InlineDatum govDatum)\n              (V2.txOutValue om)\n          )\n      else\n        validateIn\n          (Ledger.interval now' (uEndTime + expirationPeriod - oneSecond))\n          execution\n\n  let tx =\n        mconcat\n          [ spendScriptRef\n              refScriptUtxoExecute\n              (executeScript Mock.executeParams)\n              oref1\n              Execute.Execute\n              upgrade1,\n            spendScriptRef\n              refScriptUtxoExecute\n              (executeScript Mock.executeParams)\n              oref2\n              Execute.Execute\n              upgrade2,\n            mintValue\n              (authPolicy pToken upgradeTokenName)\n              ()\n              (inv $ unitValue uToken),\n            payValue,\n            payToKey admin (unitValue uToken) -- user steals the upgrade token\n          ]\n\n  void $ signTx admin tx >>= sendTx\n\ncreateMigrateProposal ::\n  Ledger.TokenName ->\n  OnChainDecimal ->\n  OracleAssetNFT ->\n  Run CreateProposalResult\ncreateMigrateProposal token newRatio oracle = do\n  let cpParam =\n        CreateProposalParam (Gov.MigrateAsset token newRatio (Right oracle))\n  runCreateProposal cpParam\n\ncreateDelistProposal :: Ledger.TokenName -> Run CreateProposalResult\ncreateDelistProposal token = do\n  let cpParam =\n        CreateProposalParam\n          ( Gov.MigrateAsset\n              token\n              (OnChainDecimal 100_000_000)\n              (Left $ OnChainDecimal 1_000_000)\n          )\n  runCreateProposal cpParam\n\nrunInitRefScriptGov :: Run ()\nrunInitRefScriptGov = initScriptRef (govScript Mock.govParams)\n\nrunInitRefScriptPollManager :: Run ()\nrunInitRefScriptPollManager =\n  initScriptRef (pollManagerScript Mock.pollManagerParams)\n\nrunInitRefScriptPoll :: Run ()\nrunInitRefScriptPoll = initScriptRef (pollScript Mock.pollParams)\n\nrunInitRefScriptExecute :: Run ()\nrunInitRefScriptExecute = initScriptRef (executeScript Mock.executeParams)\n\nrunInitGov :: HasCallStack => Run ()\nrunInitGov = do\n  runInitRefScriptGov\n  runInitRefScriptPollManager\n  runInitRefScriptPoll\n  runInitRefScriptExecute\n  admin <- getMainUser\n  let govVal =\n        unitValue (Gov.govNFT Mock.govParams)\n          <> Ada.lovelaceValueOf minLovelacesPerUtxo\n  sp <- spend admin govVal\n  now <- currentTime\n  void $ signTx admin (userSpend sp <> initTk now govVal) >>= sendTx\n  where\n    initTk :: Ledger.POSIXTime -> Ledger.Value -> Tx\n    initTk protocolStart =\n      payToRef\n        (govScript Mock.govParams)\n        ( InlineDatum\n            Gov\n              { currentProposal = 0,\n                currentVersion = 0,\n                Gov.protocolParams = Mock.protocolParams,\n                protocolStartTime = protocolStart\n              }\n        )\n\nrunInitialize :: HasCallStack => Run ()\nrunInitialize = do\n  runInitGov\n  initScriptRef (cdpCreatorScript Mock.cdpCreatorParams)\n  initScriptRef (cdpScript Mock.cdpParams)\n  initScriptRef (stabilityPoolScript Mock.spParams)\n  runInitStaking\n  admin <- getMainUser\n  runOpenStakingPos admin (OpenStakingPositionParam 1_000_000_000) OpenSucceed\n  runInitCollector 1 Nothing\n  runInitCDPCreator\n  where\n    runInitCDPCreator :: Run ()\n    runInitCDPCreator = do\n      admin <- getMainUser\n      sp <- spend admin cdpCreatorValue\n      void $\n        signTx\n          admin\n          ( mconcat\n              [ userSpend sp,\n                payToScript\n                  (cdpCreatorScript Mock.cdpCreatorParams)\n                  (InlineDatum ())\n                  cdpCreatorValue\n              ]\n          )\n          >>= sendTx\n\n-- Containts (proposal id, end of proposal voting period,\n-- total amount of voting shards)\ntype CreateProposalResult = (Integer, Ledger.POSIXTime, Integer)\n\nrunCreateProposal :: HasCallStack => CreateProposalParam -> Run CreateProposalResult\nrunCreateProposal CreateProposalParam {cpContent} = do\n  refScriptUtxo <- getFirstRefScript (govScript Mock.govParams)\n  admin <- getMainUser\n  (oref, o, govDatum) <- findGov\n  now <- currentTime\n  let Gov {currentProposal, Gov.protocolParams = pParam, currentVersion} =\n        govDatum\n      eTime = now + Gov.votingPeriod pParam\n      expirationTime = eTime + Gov.expirationPeriod pParam\n      proposeEndTime = now + Gov.proposingPeriod pParam\n      totalShards = Gov.totalShards pParam\n      pDatum =\n        Poll.PollManager\n          { Poll.pId = currentProposal + 1,\n            Poll.pOwner = Ledger.PaymentPubKeyHash admin,\n            Poll.pContent = cpContent,\n            Poll.pStatus = Poll.VoteCount {Poll.nYes = 0, Poll.nNo = 0},\n            Poll.pEndTime = eTime,\n            Poll.pCreatedShards = 0,\n            Poll.pTalliedShards = 0,\n            Poll.pTotalShards = totalShards,\n            Poll.pProposeEndTime = proposeEndTime,\n            Poll.pExpirationTime = expirationTime,\n            Poll.pProtocolVersion = currentVersion\n          }\n      govNFT = Gov.govNFT Mock.govParams\n      pollToken = Gov.pollToken Mock.govParams\n      pollTokenName = getTokenName pollToken\n      indy = Gov.indyAsset Mock.govParams\n      biasTime = Gov.gBiasTime Mock.govParams\n      indyAmount = Value.assetClassValue indy (Gov.proposalDeposit pParam)\n  sp <- spend admin (Ada.lovelaceValueOf minLovelacesPerUtxo <> indyAmount)\n  tx <-\n    validateIn\n      (Ledger.interval (now - oneSecond) (now + biasTime - oneSecond))\n      ( mconcat\n          [ spendScriptRef\n              refScriptUtxo\n              (govScript Mock.govParams)\n              oref\n              (Gov.CreatePoll now (Ledger.PaymentPubKeyHash admin) cpContent)\n              govDatum,\n            mintValue\n              (authPolicy govNFT pollTokenName)\n              ()\n              (unitValue pollToken),\n            payToRef\n              (govScript Mock.govParams)\n              (InlineDatum govDatum {Gov.currentProposal = currentProposal + 1})\n              (V2.txOutValue o),\n            payToRef\n              (pollManagerScript Mock.pollManagerParams)\n              (InlineDatum pDatum)\n              ( Value.assetClassValue indy (Gov.proposalDeposit pParam)\n                  <> unitValue pollToken\n                  <> Ada.lovelaceValueOf minLovelacesPerUtxo\n              )\n          ]\n      )\n\n  void $ signTx admin (userSpend sp <> tx) >>= sendTx\n  pure (currentProposal + 1, eTime, totalShards)\n\nrunCreateShardsChunks :: HasCallStack => Integer -> CreateShardsParam -> Run ()\nrunCreateShardsChunks\n  chunkSize\n  CreateShardsParam {csId, csEndTime, csTotalShards} = do\n    refScriptUtxoPoll <-\n      getFirstRefScript (pollManagerScript Mock.pollManagerParams)\n    admin <- getMainUser\n    let chunks =\n          unfoldr\n            ( \\sizeLeft ->\n                let chunk = min chunkSize sizeLeft\n                 in if chunk <= 0\n                      then Nothing\n                      else Just (chunk, sizeLeft - chunkSize)\n            )\n            csTotalShards\n    forM_\n      chunks\n      $ \\newShardsChunkSize -> do\n        (poref, po, poll) <- findPollManagerWithId csId\n        now <- currentTime\n        let createdShards = Poll.pCreatedShards poll\n            newPollManager =\n              poll {Poll.pCreatedShards = createdShards + newShardsChunkSize}\n            zeroStatus = Poll.VoteCount {Poll.nYes = 0, Poll.nNo = 0}\n            shardDatum =\n              Poll.PollShard\n                { psId = csId,\n                  psStatus = zeroStatus,\n                  psEndTime = csEndTime,\n                  psManagerAddress =\n                    Spooky.toSpookyAddress\n                      (pollManagerAddress Mock.pollManagerParams)\n                }\n            govNFT = Gov.govNFT Mock.govParams\n            pollToken = Gov.pollToken Mock.govParams\n            pollTokenName = getTokenName pollToken\n            biasTime = Gov.gBiasTime Mock.govParams\n        sp <-\n          spend\n            admin\n            (Ada.lovelaceValueOf (minLovelacesPerUtxo * newShardsChunkSize))\n        tx <-\n          validateIn\n            (Ledger.interval (now - oneSecond) (now + biasTime - oneSecond))\n            ( mconcat\n                ( [ mintValue\n                      (authPolicy govNFT pollTokenName)\n                      ()\n                      (Value.assetClassValue pollToken newShardsChunkSize),\n                    spendScriptRef\n                      refScriptUtxoPoll\n                      (pollManagerScript Mock.pollManagerParams)\n                      poref\n                      (Poll.CreateShards now)\n                      poll,\n                    payToRef\n                      (pollManagerScript Mock.pollManagerParams)\n                      (InlineDatum newPollManager)\n                      (V2.txOutValue po)\n                  ]\n                    ++ replicate\n                      (fromIntegral newShardsChunkSize)\n                      ( payToRef\n                          (pollScript Mock.pollParams)\n                          (InlineDatum shardDatum)\n                          ( unitValue pollToken\n                              <> Ada.lovelaceValueOf minLovelacesPerUtxo\n                          )\n                      )\n                )\n            )\n\n        void $ signTx admin (userSpend sp <> tx) >>= sendTx\n\n-- commented out to reduce the time (and to reduce `proposingPeriod`) value\n-- required to create all shards in successive chunks\n-- in plutus-simple-model test\n-- when (newShardsChunkSize < csTotalShards) $ waitNSlots 1\n\nrunCreateShards :: HasCallStack => CreateShardsParam -> Run ()\nrunCreateShards param@CreateShardsParam {csTotalShards} =\n  runCreateShardsChunks csTotalShards param\n\nrunMergeShardsChunksImpl ::\n  HasCallStack =>\n  [[(V2.TxOutRef, V2.TxOut, Poll.PollShard)]] ->\n  MergeShardsParam ->\n  Run ()\nrunMergeShardsChunksImpl shardUtxosChunks MergeShardsParam {msId} = do\n  refScriptUtxoPollManager <-\n    getFirstRefScript (pollManagerScript Mock.pollManagerParams)\n  refScriptUtxoPoll <- getFirstRefScript (pollScript Mock.pollParams)\n  admin <- getMainUser\n  let numChunks = length shardUtxosChunks\n  forM_ shardUtxosChunks $ \\shardUtxos -> do\n    (poref, po, poll@Poll.PollManager {Poll.pStatus}) <-\n      findPollManagerWithId msId\n    now <- currentTime\n    let shardVotes =\n          PlutusTx.fold $\n            map (\\(_, _, Poll.PollShard {Poll.psStatus = s}) -> s) shardUtxos\n        shardAda =\n          PlutusTx.fold $\n            map (\\(_, o, _) -> Value.adaOnlyValue $ V2.txOutValue o) shardUtxos\n        numShards = fromIntegral $ length shardUtxos\n        newPollManager =\n          poll\n            { Poll.pTalliedShards = Poll.pTalliedShards poll + numShards,\n              Poll.pStatus = pStatus PlutusTx.<> shardVotes\n            }\n        govNFT = Gov.govNFT Mock.govParams\n        biasTime = Gov.gBiasTime Mock.govParams\n        pollToken = Gov.pollToken Mock.govParams\n        pollTokenName = getTokenName pollToken\n    tx <-\n      validateIn\n        (Ledger.interval (now - oneSecond) (now + biasTime - oneSecond))\n        ( mconcat\n            ( [ mintValue\n                  (authPolicy govNFT pollTokenName)\n                  ()\n                  (Value.assetClassValue pollToken (negate numShards)),\n                spendScriptRef\n                  refScriptUtxoPollManager\n                  (pollManagerScript Mock.pollManagerParams)\n                  poref\n                  (Poll.MergeShardsManager now)\n                  poll,\n                payToRef\n                  (pollManagerScript Mock.pollManagerParams)\n                  (InlineDatum newPollManager)\n                  (V2.txOutValue po <> shardAda)\n              ]\n                ++ map\n                  ( \\(oref, _, dt) ->\n                      spendScriptRef\n                        refScriptUtxoPoll\n                        (pollScript Mock.pollParams)\n                        oref\n                        (Poll.MergeShards now $ Spooky.toSpookyTxOutRef poref)\n                        dt\n                  )\n                  shardUtxos\n            )\n        )\n\n    void $ signTx admin tx >>= sendTx\n    when (numChunks > 1) $ waitNSlots 1\n\nrunMergeShardsChunks :: HasCallStack => Int -> MergeShardsParam -> Run ()\nrunMergeShardsChunks chunkLen msp@MergeShardsParam {msId} = do\n  shardUtxos <- findAllPollShardsWithId msId\n  let chunks = chunksOf chunkLen shardUtxos\n  runMergeShardsChunksImpl chunks msp\n\nrunMergeShards :: HasCallStack => MergeShardsParam -> Run ()\nrunMergeShards msp@MergeShardsParam {msId} = do\n  shardUtxos <- findAllPollShardsWithId msId\n  runMergeShardsChunksImpl [shardUtxos] msp\n\nrunMergeShardsExploit ::\n  MergeShardsParam ->\n  MergeShardsParam ->\n  Run ()\nrunMergeShardsExploit\n  MergeShardsParam {msId = msId1}\n  MergeShardsParam {msId = msId2} = do\n    -- Get all the shards of 1st proposal\n    shardUtxos <- findAllPollShardsWithId msId1\n\n    admin <- getMainUser\n\n    refScriptUtxoPollManager <-\n      getFirstRefScript (pollManagerScript Mock.pollManagerParams)\n    refScriptUtxoPoll <-\n      getFirstRefScript (pollScript Mock.pollParams)\n\n    -- Find poll manager of 2nd proposal.\n    (poref, po, poll@Poll.PollManager {}) <- findPollManagerWithId msId2\n\n    now <- currentTime\n\n    let biasTime = Gov.gBiasTime Mock.govParams\n        pollToken = Gov.pollToken Mock.govParams\n\n    tx <-\n      validateIn\n        (Ledger.interval (now - oneSecond) (now + biasTime - oneSecond))\n        ( mconcat\n            ( [ spendScriptRef\n                  refScriptUtxoPollManager\n                  (pollManagerScript Mock.pollManagerParams)\n                  poref\n                  (Poll.MergeShardsManager now)\n                  poll,\n                payToRef\n                  (pollManagerScript Mock.pollManagerParams)\n                  (InlineDatum poll)\n                  (V2.txOutValue po),\n                -- User takes all the PollToken and it's ada.\n                payToKey\n                  admin\n                  (Ada.lovelaceValueOf 20000000 <> Value.assetClassValue pollToken 10)\n              ]\n                ++ map\n                  ( \\(oref, _, dt) ->\n                      spendScriptRef\n                        refScriptUtxoPoll\n                        (pollScript Mock.pollParams)\n                        oref\n                        (Poll.MergeShards now $ Spooky.toSpookyTxOutRef poref)\n                        dt\n                  )\n                  shardUtxos\n            )\n        )\n    void $ signTx admin tx >>= sendTx\n\nrunVote :: HasCallStack => Ledger.PubKeyHash -> VoteParam -> Run ()\nrunVote user VoteParam {vId, vOption} = do\n  refScriptUtxoPoll <- getFirstRefScript (pollScript Mock.pollParams)\n  refScriptUtxoStaking <- getFirstRefScript (stakingScript Mock.stakeParams)\n  (oref, o, poll@Poll.PollShard {Poll.psId, Poll.psEndTime}) <-\n    findFirstPollShardWithId vId\n  (soref, so, stakingPosition@(Staking.StakingPosition _ sMap snapshot)) <-\n    findStakingPosition (Ledger.PaymentPubKeyHash user)\n  let positionOutputValue = V2.txOutValue so\n      indyStakedAmount = Value.assetClassValueOf positionOutputValue indyAsset\n      Poll.PollManagerParams {Poll.indyAsset} = Mock.pollManagerParams\n      newPoll = Poll.vote poll vOption indyStakedAmount\n      pValue = V2.txOutValue o\n  tx <-\n    validateIn\n      (Ledger.to $ psEndTime - oneSecond)\n      ( mconcat\n          [ spendScriptRef\n              refScriptUtxoPoll\n              (pollScript Mock.pollParams)\n              oref\n              (Poll.Vote vOption)\n              poll,\n            payToRef (pollScript Mock.pollParams) (InlineDatum newPoll) pValue,\n            spendScriptRef\n              refScriptUtxoStaking\n              (stakingScript Mock.stakeParams)\n              soref\n              Staking.Lock\n              stakingPosition,\n            payToRef\n              (stakingScript Mock.stakeParams)\n              ( InlineDatum $\n                  Staking.StakingPosition\n                    (Ledger.PaymentPubKeyHash user)\n                    (AssocMap.insert psId (indyStakedAmount, psEndTime) sMap)\n                    snapshot\n              )\n              (V2.txOutValue so)\n          ]\n      )\n  void $ signTx user tx >>= sendTx\n\nrunEndProposal :: HasCallStack => Ledger.POSIXTime -> EndParam -> Run ()\nrunEndProposal timeShift EndParam {eId, eTotalShards} = do\n  wait timeShift\n\n  refScriptUtxoPoll <-\n    getFirstRefScript (pollManagerScript Mock.pollManagerParams)\n\n  admin <- getMainUser\n  (orefm, _om, Gov.Gov {Gov.protocolStartTime}) <- findGov\n  (oref, o, poll) <- findPollManagerWithId eId\n\n  now <- currentTime\n  let Poll.PollManager\n        { Poll.pContent,\n          Poll.pEndTime,\n          Poll.pId,\n          Poll.pStatus,\n          Poll.pExpirationTime,\n          Poll.pProtocolVersion\n        } = poll\n      passQuorum =\n        Poll.pollPassQuorum\n          pStatus\n          protocolStartTime\n          initialIndyDistribution\n          totalINDYSupply\n          now\n          distributionSchedule\n      Poll.PollManagerParams\n        { Poll.distributionSchedule,\n          Poll.initialIndyDistribution,\n          Poll.totalINDYSupply,\n          Poll.pBiasTime\n        } = Mock.pollManagerParams\n      proposalExpired = now > pExpirationTime\n      proposalPassed = not proposalExpired && passQuorum\n      upgradeDatum =\n        Execute.Upgrade\n          { Execute.uId = pId,\n            Execute.uContent = pContent,\n            Execute.uPassedTime = now,\n            Execute.uEndTime = pEndTime,\n            Execute.uProtocolVersion = pProtocolVersion\n          }\n      govNFT = Gov.govNFT Mock.govParams\n      pToken = Gov.pollToken Mock.govParams\n      pollTokenName = getTokenName pToken\n      uToken = Gov.upgradeToken Mock.govParams\n      upgradeTokenName = getTokenName uToken\n      proposalDeposit =\n        Value.assetClassValueOf\n          (V2.txOutValue o)\n          (Staking.indyToken Mock.stakeParams)\n  let payNewProposal =\n        if proposalPassed\n          then\n            mconcat\n              [ payToRef\n                  (executeScript Mock.executeParams)\n                  (InlineDatum upgradeDatum)\n                  (unitValue uToken <> Ada.lovelaceValueOf minLovelacesPerUtxo),\n                mintValue\n                  (authPolicy pToken upgradeTokenName)\n                  ()\n                  (unitValue uToken)\n              ]\n          else mempty\n  proposalDepositConstraint <-\n    payProposalDepositConstraint proposalPassed admin proposalDeposit\n  tx <-\n    validateIn\n      (Ledger.interval (now - oneSecond) (now + pBiasTime - oneSecond))\n      ( mconcat\n          [ spendScriptRef\n              refScriptUtxoPoll\n              (pollManagerScript Mock.pollManagerParams)\n              oref\n              (Poll.EndPoll now)\n              poll,\n            refInputInline orefm,\n            mintValue\n              (authPolicy govNFT pollTokenName)\n              ()\n              (inv $ unitValue pToken),\n            payNewProposal,\n            proposalDepositConstraint\n          ]\n      )\n  void $ signTx admin tx >>= sendTx\n  where\n    proposalAdaFromShards =\n      Ada.lovelaceValueOf (minLovelacesPerUtxo * eTotalShards)\n    proposalAdaFromPollManager = Ada.lovelaceValueOf minLovelacesPerUtxo\n\n    payProposalDepositConstraint ::\n      Bool -> Ledger.PubKeyHash -> Integer -> Run Tx\n    payProposalDepositConstraint True usr proposalDeposit = do\n      sp <- spend usr proposalAdaFromPollManager\n      pure $\n        mconcat\n          [ payToKey\n              usr\n              ( Value.assetClassValue\n                  (Staking.indyToken Mock.stakeParams)\n                  proposalDeposit\n                  <> proposalAdaFromShards\n                  <> proposalAdaFromPollManager\n              ),\n            userSpend sp\n          ]\n    payProposalDepositConstraint False usr proposalDeposit = do\n      pure $\n        mconcat\n          [ payToRef\n              (treasuryScript Mock.treasuryParams)\n              (InlineDatum ())\n              ( Ada.lovelaceValueOf minLovelacesPerUtxo\n                  <> Value.assetClassValue\n                    (Staking.indyToken Mock.stakeParams)\n                    proposalDeposit\n              ),\n            payToKey usr proposalAdaFromShards\n          ]\n\nrunExecute :: HasCallStack => ExecuteParam -> Run ()\nrunExecute ExecuteParam {exId} = do\n  refScriptUtxoCdp <- getFirstRefScript (cdpScript Mock.cdpParams)\n  refScriptUtxoGov <- getFirstRefScript (govScript Mock.govParams)\n  refScriptUtxoExecute <- getFirstRefScript (executeScript Mock.executeParams)\n  admin <- getMainUser\n  (orefm, om, govDatum) <- findGov\n  (oref, _, upgrade@Execute.Upgrade {Execute.uContent, Execute.uEndTime}) <-\n    findUpgradeWithId exId\n  let Execute.ExecuteParams\n        { Execute.iAssetToken,\n          Execute.stabilityPoolToken,\n          Execute.versionRecordToken\n        } = Mock.executeParams\n      Gov.ProtocolParams {Gov.expirationPeriod} =\n        Gov.protocolParams govDatum\n      iAssetOutputValue =\n        unitValue iAssetToken <> Ada.lovelaceValueOf minLovelacesPerUtxo\n      spOutputValue =\n        unitValue stabilityPoolToken <> Ada.lovelaceValueOf minLovelacesPerUtxo\n      stabilityPoolTokenName = getTokenName stabilityPoolToken\n      iAssetTokenName = getTokenName iAssetToken\n      uToken = Gov.upgradeToken Mock.govParams\n  execution <- case uContent of\n    Gov.ProposeAsset iaName iaRatio iaParam -> do\n      -- This is a hack to overcome Plutus simple model spend bug with zero ada.\n      sp <- spend admin (Ada.lovelaceValueOf minLovelacesPerUtxo)\n      pure\n        ( mconcat\n            [ refInputInline orefm,\n              mintValue\n                (authPolicy uToken stabilityPoolTokenName)\n                ()\n                (unitValue stabilityPoolToken),\n              mintValue\n                (authPolicy uToken iAssetTokenName)\n                ()\n                (unitValue iAssetToken),\n              payToRef\n                (cdpScript Mock.cdpParams)\n                (InlineDatum $ IAssetDatum (IAsset iaName iaRatio (Right iaParam)))\n                iAssetOutputValue,\n              payToRef\n                (stabilityPoolScript Mock.spParams)\n                ( InlineDatum $\n                    StabilityPoolDatum\n                      { spIAsset = iaName,\n                        spSnapshot = initSPSnapshot,\n                        epochToScaleToSum = initEpochToScaleToSumMap\n                      }\n                )\n                spOutputValue,\n              userSpend sp\n            ]\n        )\n    Gov.UpgradeProtocol Gov.UpgradePaths {Gov.uId, Gov.uPaths} ->\n      pure\n        ( mconcat\n            [ spendScript\n                (govScript Mock.govParams)\n                orefm\n                Gov.UpgradeGov\n                govDatum,\n              mintValue\n                (versionRecordPolicy Mock.vrParams)\n                AddRecord\n                (unitValue versionRecordToken),\n              payToRef\n                versionRegistryScript\n                ( InlineDatum\n                    VersionRecord\n                      { versionId = uId,\n                        versionPaths = Gov.upgradeSymbol PlutusTx.<$> uPaths\n                      }\n                )\n                versionRecordOutputValue,\n              payToRef\n                (govScript Mock.govParams)\n                ( InlineDatum\n                    govDatum\n                      { Gov.currentVersion = Gov.currentVersion govDatum + 1\n                      }\n                )\n                (V2.txOutValue om)\n            ]\n        )\n    Gov.MigrateAsset iaName iaMinRatio iaOracle -> do\n      (orefIAsset, oIAsset, iAsset) <- findIAsset iaName\n      pure\n        ( mconcat\n            [ refInputInline orefm,\n              spendScriptRef\n                refScriptUtxoCdp\n                (cdpScript Mock.cdpParams)\n                orefIAsset\n                UpgradeAsset\n                (IAssetDatum iAsset),\n              payToRef\n                (cdpScript Mock.cdpParams)\n                ( InlineDatum $\n                    IAssetDatum (IAsset {iaName, iaMinRatio, iaPrice = iaOracle})\n                )\n                (V2.txOutValue oIAsset),\n              payToKey admin (Ada.lovelaceValueOf minLovelacesPerUtxo)\n            ]\n        )\n    Gov.TextProposal _ ->\n      pure\n        ( mconcat\n            [ refInputInline orefm,\n              payToKey admin (Ada.lovelaceValueOf minLovelacesPerUtxo)\n            ]\n        )\n    Gov.ModifyProtocolParams p ->\n      pure\n        ( mconcat\n            [ spendScriptRef\n                refScriptUtxoGov\n                (govScript Mock.govParams)\n                orefm\n                Gov.UpgradeGov\n                govDatum,\n              payToRef\n                (govScript Mock.govParams)\n                (InlineDatum (govDatum {Gov.protocolParams = p}))\n                (V2.txOutValue om),\n              payToKey admin (Ada.lovelaceValueOf minLovelacesPerUtxo)\n            ]\n        )\n\n  now <- currentTime\n  let pToken = Gov.pollToken Mock.govParams\n      upgradeTokenName = getTokenName uToken\n      now' = now - oneSecond\n  payValue <-\n    if now - oneSecond > uEndTime + expirationPeriod\n      then\n        validateIn\n          (Ledger.from now')\n          ( payToRef\n              (govScript Mock.govParams)\n              (InlineDatum govDatum)\n              (V2.txOutValue om)\n          )\n      else\n        validateIn\n          (Ledger.interval now' (uEndTime + expirationPeriod - oneSecond))\n          execution\n  let tx =\n        mconcat\n          [ spendScriptRef\n              refScriptUtxoExecute\n              (executeScript Mock.executeParams)\n              oref\n              Execute.Execute\n              upgrade,\n            mintValue\n              (authPolicy pToken upgradeTokenName)\n              ()\n              (inv $ unitValue uToken),\n            payValue\n          ]\n  void $ signTx admin tx >>= sendTx\n\nrunCollectorUpgrade ::\n  Run ()\nrunCollectorUpgrade = do\n  let collectorValHash = validatorHash $ collectorScript Mock.collectorParams\n      collectorVal = 20_000_000\n\n  -- create multiple collector utxos with same amount ada.\n  runInitCollector 3 (Just collectorVal)\n\n  admin <- getMainUser\n\n  (vr, _, VersionRecord {versionPaths}) <-\n    findVersionRecordByValHash collectorValHash\n      >>= maybe (fail \"missing version record\") pure\n\n  collectorRefScriptUtxo <- getFirstRefScript (collectorScript Mock.collectorParams)\n  rewardUtxos <- utxoAt collectorValHash\n\n  let Just upgradeSymbol = AssocMap.lookup collectorValHash versionPaths\n      upgradeTokenVal = Value.singleton upgradeSymbol \"upgrade\" 1\n      tx =\n        mconcat\n          [ mintValue\n              (upgradePolicy collectorValHash collectorValHash identityDatumUpgradeCompiled)\n              ()\n              upgradeTokenVal,\n            refInputInline vr,\n            spendScriptRef\n              collectorRefScriptUtxo\n              (collectorScript Mock.collectorParams)\n              (fst $ rewardUtxos !! 1)\n              UpgradeVersion\n              (),\n            payToRef\n              (collectorScript Mock.collectorParams)\n              (InlineDatum ())\n              (V2.txOutValue $ snd $ rewardUtxos !! 1),\n            payToKey admin upgradeTokenVal\n          ]\n\n  void $ signTx admin tx >>= sendTx\n\nrunGovUpgrade ::\n  HasCallStack =>\n  Gov.GovParams ->\n  (GovDatum -> GovDatum) ->\n  PlutusTx.CompiledCode (Ledger.Datum -> Ledger.Datum) ->\n  Run ()\nrunGovUpgrade newGovParams datumUpgrade compiledDatumUpgrade = do\n  refScriptUtxo <- getFirstRefScript (govScript Mock.govParams)\n  admin <- getMainUser\n  (gr, go, gd) <- findGov\n  let Just govValHash = Ledger.toValidatorHash $ V2.txOutAddress go\n  (vr, _, VersionRecord {versionPaths}) <-\n    findVersionRecordByValHash govValHash\n      >>= maybe (fail \"missing version record\") pure\n\n  let Just upgradeSymbol = AssocMap.lookup govValHash versionPaths\n      oldGovValidator = govScript Mock.govParams\n      newGovValidator = govScript newGovParams\n      newGovValHash = validatorHash newGovValidator\n      upgradeTokenVal = Value.singleton upgradeSymbol \"upgrade\" 1\n      tx =\n        mconcat\n          [ mintValue\n              (upgradePolicy govValHash newGovValHash compiledDatumUpgrade)\n              ()\n              upgradeTokenVal,\n            spendScriptRef\n              refScriptUtxo\n              oldGovValidator\n              gr\n              Gov.UpgradeVersion\n              gd,\n            refInputInline vr,\n            payToRef\n              newGovValidator\n              (InlineDatum (datumUpgrade gd))\n              (V2.txOutValue go),\n            payToKey admin upgradeTokenVal\n          ]\n  void $ signTx admin tx >>= sendTx\n\nidentityDatumUpgradeCompiled ::\n  PlutusTx.CompiledCode (Ledger.Datum -> Ledger.Datum)\nidentityDatumUpgradeCompiled = $$(PlutusTx.compile [||id||])\n\nversionIncrementGovDatumUpgradeCompiled ::\n  PlutusTx.CompiledCode (Ledger.Datum -> Ledger.Datum)\nversionIncrementGovDatumUpgradeCompiled =\n  $$(PlutusTx.compile [||upgradeDatum||])\n  where\n    upgradeDatum :: Ledger.Datum -> Ledger.Datum\n    upgradeDatum (Ledger.Datum d) = case PlutusTx.fromBuiltinData d of\n      Nothing -> PlutusTx.traceError \"Can't decode datum\"\n      Just dd ->\n        Ledger.Datum\n          (PlutusTx.toBuiltinData (versionIncrementGovDatumUpgrade dd))\n\n{-# INLINEABLE versionIncrementGovDatumUpgrade #-}\nversionIncrementGovDatumUpgrade :: GovDatum -> GovDatum\nversionIncrementGovDatumUpgrade d@Gov {Gov.currentVersion} =\n  d {Gov.currentVersion = currentVersion PlutusTx.+ 1}\n", "output": "The provided Haskell code is a test suite for Cardano smart contracts, specifically focusing on governance transactions within the Indigo protocol. This suite is designed to simulate and verify the behavior of various governance-related operations, such as creating proposals, voting, and executing proposals. Let's break down the key components and functions in this code:\n\n### Module and Imports\n\n- **Module Declaration**: The module is named `Spec.Governance.Transactions`, and it exports several functions and types related to governance transactions.\n- **Language Extensions**: The code uses `NamedFieldPuns` for more readable record syntax and `TemplateHaskell` for metaprogramming capabilities.\n- **Imports**: The code imports various modules, including those for handling CDP (Collateralized Debt Position), governance, staking, and utility functions. It also imports Plutus libraries for interacting with the Cardano blockchain.\n\n### Key Types and Functions\n\n1. **CreateProposalResult**: A type alias for a tuple containing a proposal ID, the end time of the proposal voting period, and the total number of voting shards.\n\n2. **executeProposalSuccessfully**: This function simulates the successful execution of a proposal. It involves creating shards, voting, merging shards, ending the proposal, and executing it.\n\n3. **executeProposalExploitSuccessfully**: Similar to `executeProposalSuccessfully`, but it handles two proposals and demonstrates an exploit scenario where both proposals are executed.\n\n4. **createAssetProposal**: Creates a proposal to add a new asset to the system. It takes a token name, a ratio, and an oracle asset NFT as parameters.\n\n5. **runExecuteExploit**: Demonstrates an exploit where two proposals are executed in a way that allows unauthorized actions, such as stealing upgrade tokens.\n\n6. **createMigrateProposal**: Creates a proposal to migrate an asset, changing its ratio and oracle.\n\n7. **createDelistProposal**: Creates a proposal to delist an asset, effectively removing it from the system.\n\n8. **runInitRefScriptGov**: Initializes the reference script for the governance contract.\n\n9. **runInitGov**: Initializes the governance system, setting up the necessary scripts and state.\n\n10. **runInitialize**: A comprehensive initialization function that sets up the entire system, including governance, CDP, staking, and other components.\n\n11. **runCreateProposal**: Handles the creation of a new proposal, including minting necessary tokens and setting up the proposal's state.\n\n12. **runCreateShardsChunks**: Creates voting shards in chunks, which is useful for handling large numbers of shards.\n\n13. **runMergeShardsChunksImpl**: Merges voting shards in chunks, updating the poll manager's state with the results.\n\n14. **runMergeShardsExploit**: Demonstrates an exploit where shards from one proposal are used in another, potentially manipulating the voting outcome.\n\n15. **runVote**: Simulates a user voting on a proposal, updating the poll shard and staking position accordingly.\n\n16. **runEndProposal**: Ends a proposal, determining if it passed or failed based on the voting results and handling the proposal's deposit.\n\n17. **runExecute**: Executes a proposal, performing the actions specified in the proposal content, such as upgrading the protocol or adding a new asset.\n\n18. **runCollectorUpgrade**: Demonstrates upgrading the collector contract, minting an upgrade token, and applying the upgrade.\n\n19. **runGovUpgrade**: Upgrades the governance contract, applying a specified datum upgrade and minting an upgrade token.\n\n20. **identityDatumUpgradeCompiled** and **versionIncrementGovDatumUpgradeCompiled**: Compiled PlutusTx code for upgrading datums, either by identity or by incrementing the version.\n\n### Summary\n\nThis test suite is designed to simulate and verify the behavior of governance-related operations in the Indigo protocol on the Cardano blockchain. It covers a wide range of scenarios, including normal operations, exploits, and upgrades, ensuring that the smart contracts behave as expected under various conditions. The use of Plutus and Haskell allows for precise control and testing of the contract logic, which is crucial for maintaining the security and reliability of the protocol.", "file_path": "indigo-smart-contracts/tests/Spec/Governance/Transactions.hs", "file": "Transactions.hs"}
{"instruction": "Explain the following smart contract code:", "input": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "output": "The provided Cardano smart contract code is written in Haskell using the Plutarch library, which is a domain-specific language (DSL) for writing Plutus smart contracts. This code is part of a module named `LiquidityEvent.Validator`, which defines two main functions: `pLiquiditySetValidator` and `pLiquidityGlobalLogicW`. Let's break down the code and understand its components and logic.\n\n### Module and Imports\n\nThe module `LiquidityEvent.Validator` exports two functions: `pLiquiditySetValidator` and `pLiquidityGlobalLogicW`. It imports several modules from the Plutarch library and other custom modules, which provide various utilities and types used in the contract.\n\n- **Plutarch and Plutarch.Api.V1/V2**: These provide the core functionality and types for writing Plutus smart contracts, such as `PValidator`, `PStakeValidator`, and transaction-related types.\n- **Plutarch.Extra**: These are additional utilities for working with intervals and script contexts.\n- **PriceDiscoveryEvent.Utils**: This module likely contains utility functions specific to the price discovery event, such as assertions and currency symbol checks.\n- **Types.Constants and Types.LiquiditySet**: These modules define constants and types related to the liquidity set, such as `PLBELockConfig` and `PLiquiditySetNode`.\n\n### Function: `pLiquidityGlobalLogicW`\n\nThis function defines a stake validator that checks for the presence of a specific currency symbol (fold token) in the transaction inputs.\n\n- **Parameters**: It takes a currency symbol (`foldCS'`) and a context (`ctx`).\n- **Logic**:\n  - It extracts the transaction information from the context.\n  - It checks if any input in the transaction contains the specified currency symbol (`foldCS`).\n  - If the fold token is present, it returns a successful validation (`popaque $ pconstant ()`); otherwise, it throws an error (`perror`).\n\n### Function: `pLiquiditySetValidator`\n\nThis function defines a validator for liquidity set operations. It takes a configuration, a prefix, and transaction-related data (datum, redeemer, context) as inputs.\n\n- **Redeemer Matching**: The function uses pattern matching on the redeemer to determine the type of action being performed. The actions include `PLRewardFoldAct`, `PLCommitFoldAct`, `PLLinkedListAct`, `PLModifyCommitment`, and `PLClaimAct`.\n\n- **PLRewardFoldAct and PLCommitFoldAct**:\n  - These actions involve checking withdrawal certificates against expected credentials (`rewardCred` or `commitCred`) in the configuration.\n  - If the expected credential is found in the withdrawal certificates, the transaction is valid; otherwise, it fails.\n\n- **PLLinkedListAct**:\n  - This action involves checking that the transaction mints or burns tokens with currency symbols that match a specific prefix.\n  - It ensures that the transaction interacts with the linked list by asserting the presence of these currency symbols.\n\n- **PLModifyCommitment**:\n  - This action checks that the datum and non-ADA value of the transaction output match the input, ensuring no unauthorized modifications.\n  - It also checks that no tokens are minted and that the transaction occurs after a specified deadline.\n\n- **PLClaimAct**:\n  - This action involves claiming rewards and requires the presence of a specific signature and no minting.\n  - It checks if the transaction occurs within a valid range and, if necessary, includes a reference input for the reward fold.\n  - The reward fold must be complete (i.e., the `next` field is null) for the claim to be valid.\n\n### Summary\n\nThe code defines a complex validator for a liquidity event on the Cardano blockchain. It handles various actions related to liquidity sets, such as reward folding, commitment, linked list interactions, and claims. The validator ensures that transactions adhere to specific rules and conditions, such as checking credentials, currency symbols, and transaction properties. The use of Plutarch allows for writing these rules in a functional and type-safe manner, leveraging Haskell's capabilities.", "file_path": "iscovery/src/LiquidityEvent/Validator.hs", "file": "Validator.hs"}
{"instruction": "Explain the following smart contract code:", "input": "{-# LANGUAGE DerivingStrategies #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE StrictData #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nmodule Test.Prelude\n  ( \n    -- * Core Test Framework\n    TokenMint(..)\n  , Input(..)\n  , InputDatum(..)\n  , SpendWitness(..)\n  , StakeWitness(..)\n  , Withdrawal(..)\n  , Certificate(..)\n  , CertificateAction(..)\n  , Output(..)\n  , TransactionParams(..)\n  , emptyTxParams\n  , transact\n\n    -- * Basic Configs\n  , refScriptAddress\n  , testTokenSymbol\n\n    -- * EmulatorPredicates\n  , mustSucceed\n  , mustExceedTxLimits\n  , scriptMustFail\n  , scriptMustFailWithError\n\n    -- * Helper Functions\n  , toReferenceScript\n  , toVersionedMintingPolicy\n  , toCardanoApiAddress\n  , toRedeemer\n  , toDatum\n  , utxoValue\n  , txOutRefWithReferenceScript\n  , txOutRefWithValue\n  , txOutRefsAndDatumsAtAddress\n  , toVersioned\n  , testTraceLastLogs\n  , grouped\n  , testTrace\n\n    -- * Re-exports\n  , E.runEmulatorM\n  , E.defaultOptions\n  , E.MonadEmulator\n  , E.nextSlot\n  , PV2.OutputDatum(..)\n  , void\n  , alwaysSucceedValidator\n  , alwaysSucceedPolicy\n  , L.CardanoAddress\n  , TxOutRef\n  ) where\n\nimport GHC.Generics (Generic)\nimport qualified Ledger.Tx.CardanoAPI as C\nimport qualified Cardano.Api as C\nimport qualified Cardano.Api.Shelley as C\nimport qualified Ledger as L\nimport qualified Ledger.Tx.CardanoAPI.Internal as LTx\nimport qualified Ledger.Value.CardanoAPI as LV\nimport qualified PlutusLedgerApi.V2 as PV2\nimport qualified Cardano.Node.Emulator as E\nimport qualified Cardano.Node.Emulator.LogMessages as E \nimport qualified Cardano.Node.Emulator.Internal.Node as E hiding (queueTx,nextSlot)\nimport qualified Ledger.Index as Index\nimport qualified Ledger.AddressMap as AM\nimport Plutus.Script.Utils.V2.Generators (alwaysSucceedPolicy,alwaysSucceedValidator)\nimport Plutus.Script.Utils.Value (flattenValue)\nimport qualified Data.Map as Map\nimport qualified Data.ByteString as B\nimport Data.Sequence (Seq(..))\nimport qualified Data.Sequence as Seq\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Foldable (foldl',toList)\nimport Control.Monad (void,unless)\nimport Lens.Micro ((^.),(^?))\nimport Control.Monad.RWS.Class (get)\nimport Prettyprinter (pretty,vsep)\nimport qualified Prettyprinter as Pretty\nimport Test.Tasty (TestName,TestTree)\nimport Test.Tasty.HUnit (testCase,assertFailure)\nimport Control.Monad.Except (runExceptT)\nimport Control.Monad.RWS.Strict (runRWS)\n\nimport CardanoSwaps.Utils\n\n-------------------------------------------------\n-- Core Test Framework\n-------------------------------------------------\n-- | Mint or burn native tokens. Can use either a reference script or a local script.\ndata TokenMint = TokenMint \n  { mintTokens :: [(PV2.TokenName,Integer)]\n  , mintRedeemer :: PV2.Redeemer\n  , mintPolicy :: L.Versioned L.MintingPolicy\n  , mintReference :: Maybe L.TxOutRef\n  } deriving stock (Generic,Show,Eq)\n\n-- | Create a transaction output at the specified address with the specified value, datum,\n-- and reference script.\ndata Output = Output\n  { outputAddress :: L.CardanoAddress\n  , outputValue :: LV.Value\n  , outputDatum :: PV2.OutputDatum\n  , outputReferenceScript :: L.ReferenceScript\n  } deriving (Generic,Show,Eq)\n\n-- | What kind of datum the input being spent has.\ndata InputDatum\n  = InlineDatum\n  | DatumHash PV2.Datum\n  deriving (Generic,Show,Eq)\n\ninputDatumToScriptDatum :: InputDatum -> C.ScriptDatum C.WitCtxTxIn\ninputDatumToScriptDatum InlineDatum = C.InlineScriptDatum\ninputDatumToScriptDatum (DatumHash d) = \n  C.ScriptDatumForTxIn $ LTx.toCardanoScriptData $ PV2.getDatum d\n\n-- | A witness for a spend event.\ndata SpendWitness\n  = SpendWithPubKey\n  | SpendWithPlutusScript (L.Versioned L.Script) InputDatum L.Redeemer\n  | SpendWithPlutusReference L.TxOutRef InputDatum L.Redeemer\n  deriving (Generic,Show,Eq)\n\n-- | Spend a transaction input.\ndata Input = Input\n  { inputId :: L.TxOutRef\n  , inputWitness :: SpendWitness\n  } deriving (Generic,Show,Eq)\n\n-- | A witness for a stake event.\ndata StakeWitness\n  = StakeWithPubKey\n  | StakeWithPlutusScript (L.Versioned L.Script) L.Redeemer\n  | StakeWithPlutusReference L.TxOutRef L.Redeemer\n  deriving (Generic,Show,Eq)\n\n-- | Withdrawals from a reward address.\ndata Withdrawal = Withdrawal\n  { withdrawalCredential :: PV2.Credential\n  , withdrawalAmount :: C.Lovelace\n  , withdrawalWitness :: StakeWitness\n  } deriving (Generic,Show,Eq)\n\ndata CertificateAction\n  = Register\n  | UnRegister\n  deriving (Generic,Show,Eq)\n\ndata Certificate = Certificate\n  { certificateCredential :: PV2.Credential\n  , certificateWitness :: StakeWitness\n  , certificateAction :: CertificateAction\n  } deriving (Generic,Show,Eq)\n\n-- | Used to create a transaction with the specified constraints.\ndata TransactionParams = TransactionParams\n  { tokens :: [TokenMint]\n  , inputs :: [Input]\n  , outputs :: [Output]\n  , referenceInputs :: [TxOutRef]\n  , extraKeyWitnesses :: [PV2.PubKeyHash] \n  -- ^ In order for a plutus script to see a pubkey, it must be present in this list.\n  , withdrawals :: [Withdrawal] \n  , certificates :: [Certificate] \n  } deriving (Generic,Show,Eq)\n\nemptyTxParams :: TransactionParams\nemptyTxParams = TransactionParams [] [] [] [] [] [] []\n\ntransact \n  :: (E.MonadEmulator m) \n  => L.CardanoAddress \n  -- ^ The main address where change will be returned.\n  -> [L.CardanoAddress] \n  -- ^ Any other addresses where inputs will come from. This includes reference inputs\n  -> [L.PaymentPrivateKey] \n  -- ^ All private keys that must sign the transaction. This does not mean a plutus script will\n  -- see the signature. You must include the key in the `extraKeyWitnesses` of `TransactionParams`\n  -- for a plutus script to see it.\n  -> TransactionParams \n  -> m LTx.CardanoTx\ntransact mainAddress extraAddresses privKeys TransactionParams{..} = do\n  utxos <- foldl' (<>) <$> E.utxosAt mainAddress <*> mapM E.utxosAt extraAddresses\n  let mintWitnessMap = C.BuildTxWith $ Map.fromList $ flip map tokens $ \\TokenMint{..} -> \n        ( LV.policyId mintPolicy\n        , unsafeFromRight $ \n            C.toCardanoMintWitness mintRedeemer (toVersioned <$> mintReference) (Just mintPolicy)\n        )\n      mintValue = flip foldMap tokens $ \\TokenMint{..} -> \n        flip foldMap mintTokens $ \\(tn,i) -> \n          LV.singleton (LV.policyId mintPolicy) (unsafeFromRight $ C.toCardanoAssetName tn) i\n      outs = flip map outputs $ \\Output{..} ->\n        C.TxOut\n          outputAddress\n          (C.toCardanoTxOutValue outputValue)\n          (unsafeFromRight $ C.toCardanoTxOutDatum outputDatum)\n          outputReferenceScript\n      ins = flip map inputs $ \\Input{..} ->\n        ( unsafeFromRight $ LTx.toCardanoTxIn inputId\n        , C.BuildTxWith $ case inputWitness of\n            SpendWithPubKey -> \n              C.KeyWitness C.KeyWitnessForSpending\n            SpendWithPlutusScript script datum redeemer -> \n              C.ScriptWitness C.ScriptWitnessForSpending $\n                C.toCardanoTxInScriptWitnessHeader \n                  script\n                  (inputDatumToScriptDatum datum)\n                  (C.toCardanoScriptData $ PV2.getRedeemer redeemer)\n                  LTx.zeroExecutionUnits -- The autobalancer will set these.\n            SpendWithPlutusReference ref datum redeemer-> \n              C.ScriptWitness C.ScriptWitnessForSpending $\n                (unsafeFromRight $ C.toCardanoTxInReferenceWitnessHeader $ toVersioned ref)\n                  (inputDatumToScriptDatum datum)\n                  (C.toCardanoScriptData $ PV2.getRedeemer redeemer)\n                  LTx.zeroExecutionUnits -- The autobalancer will set these.\n        )\n      wdrls = flip map withdrawals $ \\Withdrawal{..} ->\n        ( C.makeStakeAddress E.testnet $ case withdrawalCredential of\n            PV2.ScriptCredential hash -> \n              C.StakeCredentialByScript $ unsafeFromRight $ C.toCardanoScriptHash hash\n            PV2.PubKeyCredential hash -> \n              C.StakeCredentialByKey $ unsafeFromRight $ C.toCardanoStakeKeyHash hash\n        , withdrawalAmount\n        , C.BuildTxWith $ case withdrawalWitness of\n            StakeWithPubKey -> C.KeyWitness C.KeyWitnessForStakeAddr\n            StakeWithPlutusScript script redeemer-> \n              C.ScriptWitness C.ScriptWitnessForStakeAddr $\n                C.toCardanoTxInScriptWitnessHeader \n                  script\n                  C.NoScriptDatumForStake\n                  (C.toCardanoScriptData $ PV2.getRedeemer redeemer)\n                  LTx.zeroExecutionUnits -- The autobalancer will set these.\n            StakeWithPlutusReference ref redeemer-> \n              C.ScriptWitness C.ScriptWitnessForStakeAddr $\n                (unsafeFromRight $ C.toCardanoTxInReferenceWitnessHeader $ toVersioned ref)\n                  C.NoScriptDatumForStake\n                  (C.toCardanoScriptData $ PV2.getRedeemer redeemer)\n                  LTx.zeroExecutionUnits -- The autobalancer will set these.\n        )\n      references = \n        C.TxInsReference C.BabbageEraOnwardsBabbage $ \n          map (unsafeFromRight . LTx.toCardanoTxIn) referenceInputs\n      (certs,certWits) = unzip $ flip map certificates $ \\Certificate{..} ->\n        let stakeCred = case certificateCredential of\n              PV2.ScriptCredential hash -> \n                C.StakeCredentialByScript $ unsafeFromRight $ C.toCardanoScriptHash hash\n              PV2.PubKeyCredential hash -> \n                C.StakeCredentialByKey $ unsafeFromRight $ C.toCardanoStakeKeyHash hash\n        in ( case certificateAction of\n               Register -> \n                 C.makeStakeAddressRegistrationCertificate $\n                   C.StakeAddrRegistrationPreConway\n                     C.ShelleyToBabbageEraBabbage \n                     stakeCred\n               UnRegister -> \n                 C.makeStakeAddressUnregistrationCertificate $\n                   C.StakeAddrRegistrationPreConway\n                     C.ShelleyToBabbageEraBabbage \n                     stakeCred\n           , (stakeCred,) $\n              case certificateWitness of\n                StakeWithPubKey -> C.KeyWitness C.KeyWitnessForStakeAddr\n                StakeWithPlutusScript script redeemer-> \n                  C.ScriptWitness C.ScriptWitnessForStakeAddr $\n                    C.toCardanoTxInScriptWitnessHeader \n                      script\n                      C.NoScriptDatumForStake\n                      (C.toCardanoScriptData $ PV2.getRedeemer redeemer)\n                      LTx.zeroExecutionUnits -- The autobalancer will set these.\n                StakeWithPlutusReference ref redeemer-> \n                  C.ScriptWitness C.ScriptWitnessForStakeAddr $\n                    (unsafeFromRight $ C.toCardanoTxInReferenceWitnessHeader $ toVersioned ref)\n                      C.NoScriptDatumForStake\n                      (C.toCardanoScriptData $ PV2.getRedeemer redeemer)\n                      LTx.zeroExecutionUnits -- The autobalancer will set these.\n           )\n      tx =\n        C.CardanoBuildTx $ E.emptyTxBodyContent\n          { C.txMintValue = C.TxMintValue C.MaryEraOnwardsBabbage mintValue mintWitnessMap\n          , C.txIns = ins\n          , C.txOuts = outs\n          , C.txInsReference = references\n          , C.txExtraKeyWits = C.TxExtraKeyWitnesses C.AlonzoEraOnwardsBabbage $\n              map (unsafeFromRight . toCardanoApiKeyHash) extraKeyWitnesses\n          , C.txWithdrawals = C.TxWithdrawals C.ShelleyBasedEraBabbage wdrls\n          , C.txCertificates = C.TxCertificates C.ShelleyBasedEraBabbage certs $\n              C.BuildTxWith $ Map.fromList certWits\n          }\n  E.submitTxConfirmed utxos mainAddress privKeys tx\n\n-------------------------------------------------\n-- Basic Configs\n-------------------------------------------------\n-- | An always succeeding validator address without a staking credential. All reference scripts\n-- are assumed to be stored here.\nrefScriptAddress :: L.CardanoAddress\nrefScriptAddress = \n  let alwaysScriptHash = scriptHash $ L.unScript $ L.getValidator alwaysSucceedValidator \n  in toCardanoApiAddress $ PV2.Address (PV2.ScriptCredential alwaysScriptHash) Nothing\n\ntestTokenSymbol :: CurrencySymbol\ntestTokenSymbol = CurrencySymbol \n                $ PV2.getScriptHash \n                $ scriptHash \n                $ L.unScript \n                $ L.unMintingPolicyScript alwaysSucceedPolicy\n\n-------------------------------------------------\n-- EmulatorPredicates\n-------------------------------------------------\nmustSucceed :: TestName -> E.EmulatorM a -> TestTree\nmustSucceed testName contract =\n  testCase testName $\n    let (res,(st,lg)) = E.runEmulatorM E.defaultOptions contract\n    in case res of\n          Left err -> assertFailure $ show err\n          Right _ ->  -- Just because it returned a Right does not mean everything succeeded.\n            let (res1, _, _) = \n                  runRWS (runExceptT (hasNoFailedTransactions lg)) (E.params E.defaultOptions) st\n            in case res1 of\n                Left err -> assertFailure $ show err\n                -- Right (Just msg) -> assertFailure $ unpack (E.renderLogs lg) ++ \"\\n\" ++ msg\n                Right (Just msg) -> assertFailure msg\n                _ -> pure ()\n\nmustExceedTxLimits :: TestName -> E.EmulatorM a -> TestTree\nmustExceedTxLimits testName contract =\n  testCase testName $\n    let (res,(st,lg)) = E.runEmulatorM E.defaultOptions contract\n    in case res of\n          Left err -> assertFailure $ show err -- It should return Right.\n          Right _ ->  -- Just because it returned a Right does not mean everything succeeded.\n            let (res1, _, _) = \n                  runRWS (runExceptT (hasExceededTxLimits lg)) (E.params E.defaultOptions) st\n            in case res1 of\n                Left err -> assertFailure $ show err\n                Right (Just msg) -> assertFailure msg\n                _ -> pure ()\n\nscriptMustFail :: TestName -> E.EmulatorM a -> TestTree\nscriptMustFail testName contract =\n  testCase testName $\n    let (res,_) = E.runEmulatorM E.defaultOptions contract\n    in case res of\n          Left (E.ValidationError (_,Index.ScriptFailure _)) -> pure ()\n          Left err -> assertFailure $ \"Emulator terminated for other reason:\" <> \"\\n\" <> show err\n          Right _ -> assertFailure \"Transaction succeeded\"\n\nscriptMustFailWithError :: TestName -> Text -> E.EmulatorM a -> TestTree\nscriptMustFailWithError testName errCode contract =\n  testCase testName $\n    let (res,_) = E.runEmulatorM E.defaultOptions contract\n    in case res of\n          Left err@(E.ValidationError (_,Index.ScriptFailure (L.EvaluationError errs _))) -> \n            unless (errCode `elem` errs) $ \n              assertFailure $ \"Script failed for different reason:\" <> \"\\n\" <> show err\n          Left err -> assertFailure $ \"Transaction failed for different reason:\" <> \"\\n\" <> show err\n          Right _ -> assertFailure \"Transaction succeeded\"\n\nhasNoFailedTransactions :: E.EmulatorLogs -> E.EmulatorM (Maybe String)\nhasNoFailedTransactions Empty = pure Nothing\nhasNoFailedTransactions (l :<| lg) = case l of\n  E.LogMessage _ (E.ChainEvent (E.TxnValidation Index.FailPhase1{})) -> \n    pure $ Just $ show $ pretty l\n  E.LogMessage _ (E.ChainEvent (E.TxnValidation Index.FailPhase2{})) -> \n    pure $ Just $ show $ pretty l\n  E.LogMessage _ (E.TxBalanceMsg E.ValidationFailed{}) -> \n    pure $ Just $ show $ pretty l\n  _otherLogMsg -> hasNoFailedTransactions lg\n\nhasExceededTxLimits :: E.EmulatorLogs -> E.EmulatorM (Maybe String)\nhasExceededTxLimits Empty = pure $ Just \"No transactions exceeded limits\"\nhasExceededTxLimits (l :<| lg) = do\n  let properMsg m = m == \"(MaxTxSizeUTxO\" || m == \"(ExUnitsTooBigUTxO\"\n      hasProperMsg msgs =\n        if any properMsg $ T.words msgs\n        then pure Nothing\n        else hasExceededTxLimits lg\n  case l of\n    E.LogMessage _ (E.ChainEvent (E.TxnValidation (Index.FailPhase1 _ msg))) -> \n      case msg ^? L._CardanoLedgerValidationError of\n        Just err -> hasProperMsg err\n        Nothing -> hasExceededTxLimits lg\n    E.LogMessage _ (E.ChainEvent (E.TxnValidation (Index.FailPhase2 _ msg _))) -> \n      case msg ^? L._CardanoLedgerValidationError of\n        Just err -> hasProperMsg err\n        Nothing -> hasExceededTxLimits lg\n    E.LogMessage _ (E.TxBalanceMsg (E.ValidationFailed _ _ msg _)) -> \n      case msg ^? L._CardanoLedgerValidationError of\n        Just err -> hasProperMsg err\n        Nothing -> hasExceededTxLimits lg\n    _otherLogMsg -> hasExceededTxLimits lg\n\n-- not :: Maybe String -> Maybe String\n-- not (Just _) = Nothing\n-- not Nothing = Just \"\"\n\n-- hasFailedTransaction :: EmulatorPredicate\n-- hasFailedTransaction = fmap Test.Prelude.not . hasNoFailedTransactions\n\n-------------------------------------------------\n-- Helper Functions\n-------------------------------------------------\ntoReferenceScript :: Maybe PV2.SerialisedScript -> C.ReferenceScript C.BabbageEra\ntoReferenceScript = C.toCardanoReferenceScript . fmap toVersionedLedgerScript\n\ntoVersionedMintingPolicy :: PV2.SerialisedScript -> L.Versioned L.MintingPolicy\ntoVersionedMintingPolicy = wrapVersionedLedgerScript L.MintingPolicy . toVersionedLedgerScript\n\ntoVersioned :: a -> L.Versioned a\ntoVersioned x = L.Versioned x L.PlutusV2\n\ntoCardanoApiAddress :: PV2.Address -> L.CardanoAddress\ntoCardanoApiAddress = unsafeFromRight . C.toCardanoAddressInEra E.testnet\n\ntoRedeemer :: PV2.ToData a => a -> L.Redeemer\ntoRedeemer = L.Redeemer . PV2.dataToBuiltinData . PV2.toData\n\ntoDatum :: PV2.ToData a => a -> L.Datum\ntoDatum = L.Datum . PV2.dataToBuiltinData . PV2.toData\n\ntoCardanoValue :: PV2.Value -> C.Value\ntoCardanoValue = unsafeFromRight . LV.toCardanoValue\n\nutxoValue :: L.Lovelace -> PV2.Value -> C.Value\nutxoValue lovelace v = LV.lovelaceToValue lovelace <> unsafeFromRight (LV.toCardanoValue v)\n\n-- | Find the TxOutRef for the first UTxO with a specific value.\ntxOutRefWithValue :: (E.MonadEmulator m) => C.Value -> m TxOutRef\ntxOutRefWithValue value = do\n  state <- get\n  let xs = Map.toList $ C.unUTxO $ state ^. E.esChainState . E.index\n      findTxId v ((ref,o):ys)\n        | PV2.txOutValue (LTx.fromCardanoTxOutToPV2TxInfoTxOut' o) == LV.fromCardanoValue v = ref\n        | otherwise = findTxId v ys\n      findTxId _ _ = error \"Test.Prelude.txOutRefWithValue error\"\n  return $ LTx.fromCardanoTxIn $ findTxId value xs\n\n-- | Find the TxOutRef for the first UTxO with a reference script.\ntxOutRefWithReferenceScript :: (E.MonadEmulator m) => PV2.ScriptHash -> m TxOutRef\ntxOutRefWithReferenceScript hash = do\n  state <- get\n  let xs = Map.toList $ C.unUTxO $ state ^. E.esChainState . E.index\n      findTxId h ((ref,o):ys)\n        | PV2.txOutReferenceScript (LTx.fromCardanoTxOutToPV2TxInfoTxOut' o) == Just h = ref\n        | otherwise = findTxId h ys\n      findTxId _ _ = error \"Test.Prelude.txOutRefWithValue error\"\n  return $ LTx.fromCardanoTxIn $ findTxId hash xs\n\n-- | Find all TxOutRefs and their datums located at a specific address.\ntxOutRefsAndDatumsAtAddress \n  :: forall a m. (E.MonadEmulator m, PV2.FromData a) \n  => L.CardanoAddress \n  -> m [(TxOutRef,Maybe a)]\ntxOutRefsAndDatumsAtAddress addr = do\n  state <- get\n  let xs = Map.toList $ C.unUTxO $ state ^. E.esChainState . E.index\n      addr' = L.toPlutusAddress addr\n      findTxId [] = []\n      findTxId ((ref,o):ys) =\n        let out = LTx.fromCardanoTxOutToPV2TxInfoTxOut' o\n        in if PV2.txOutAddress out == addr'\n           then (LTx.fromCardanoTxIn ref, convertFromData @a $ PV2.txOutDatum out) : findTxId ys\n           else findTxId ys\n  return $ findTxId xs\n\nconvertFromData :: forall d . PV2.FromData d => PV2.OutputDatum -> Maybe d\nconvertFromData datum = case datum of\n  PV2.NoOutputDatum -> Nothing\n  PV2.OutputDatumHash _ -> Nothing\n  PV2.OutputDatum (PV2.Datum scriptData) ->\n    PV2.fromBuiltinData @d $ scriptData\n\ntoCardanoApiKeyHash :: PV2.PubKeyHash -> Either LTx.ToCardanoError (C.Hash C.PaymentKey)\ntoCardanoApiKeyHash (PV2.PubKeyHash bs) =\n  let bsx = PV2.fromBuiltin bs\n      tg = \"toCardanoApiKeyHash (\" <> show (B.length bsx) <> \" bytes)\"\n   in LTx.tag tg $ LTx.deserialiseFromRawBytes (C.AsHash C.AsPaymentKey) bsx\n\ngrouped :: Int -> [a] -> [[a]]\ngrouped _ [] = []\ngrouped n xs = \n  let (m,ms) = splitAt n xs \n  in m : grouped n ms\n\ntestTraceLastLogs :: Int -> E.EmulatorM a -> IO ()\ntestTraceLastLogs n trace = \n  let (_,(_,lg)) = E.runEmulatorM E.defaultOptions trace\n  in print $ vsep $ toList $ fmap pretty $ Seq.reverse $ Seq.take n $ Seq.reverse lg\n\ntestTrace :: E.EmulatorM a -> IO ()\ntestTrace trace = do\n    let (r,(st,lg)) = E.runEmulatorM E.defaultOptions trace\n    case r of\n      Left err -> print err\n      Right _ -> do \n        let (res1, _, _) = \n              runRWS (runExceptT (hasNoFailedTransactions lg)) (E.params E.defaultOptions) st\n        case res1 of\n          Left err -> print err\n          Right (Just msg) -> putStrLn msg\n          Right Nothing ->\n            print $ vsep $ prettyBalances $ Map.toList $ AM.values $ st ^. E.esAddressMap\n  where\n    prettyValue :: (PV2.CurrencySymbol,PV2.TokenName,Integer) -> Pretty.Doc ann\n    prettyValue (\"\",\"\",i) = pretty $ show i <> \" lovelace\"\n    prettyValue (curr,name,i) = pretty $ show i <> \" \" <> show curr <> \".\" <> show name \n\n    prettyBalances :: [(L.CardanoAddress,C.Value)] -> [Pretty.Doc ann]\n    prettyBalances ys =\n      let go sc [] = []\n          go sc ((addr,val):xs) = \n            if addr == refScriptAddress then \n              vsep [ \"RefAddress\"\n                   , Pretty.indent 4 $ Pretty.align $ vsep $ \n                      map prettyValue $ flattenValue $ LV.fromCardanoValue val\n                   ] : go sc xs\n            else \n              case L.toPlutusAddress addr of\n                PV2.Address (PV2.PubKeyCredential _) _ -> go sc xs\n                PV2.Address (PV2.ScriptCredential _) _ ->\n                  vsep [ \"SwapAddress\" <> pretty @Int sc\n                       , Pretty.indent 4 $ Pretty.align $ vsep $ \n                          map prettyValue $ flattenValue $ LV.fromCardanoValue val\n                       ] : go (sc + 1) xs\n      in go 1 ys\n", "output": "The provided Haskell code is a part of a test framework for Cardano smart contracts, specifically for testing Plutus scripts using an emulator. This code is from a file named `Test/Prelude.hs` and is structured to facilitate the creation, execution, and validation of transactions in a simulated Cardano environment. Let's break down the key components and their purposes:\n\n### Language Extensions and Module Declaration\n\n- **Language Extensions**: The code uses several GHC language extensions like `DerivingStrategies`, `OverloadedStrings`, `RecordWildCards`, `StrictData`, and `ScopedTypeVariables` to enhance the Haskell language capabilities for this module.\n- **Module Declaration**: The module is named `Test.Prelude` and exports various types, functions, and re-exports from other modules to be used in testing.\n\n### Core Test Framework\n\n1. **Data Types**:\n   - **`TokenMint`**: Represents the minting or burning of native tokens. It includes the tokens to be minted, a redeemer, a minting policy, and an optional reference to a transaction output.\n   - **`Output`**: Describes a transaction output, including the address, value, datum, and reference script.\n   - **`InputDatum`**: Specifies the type of datum associated with an input, either inline or by hash.\n   - **`SpendWitness`**: Represents the witness required to spend an input, which can be a public key, a Plutus script, or a reference to a Plutus script.\n   - **`Input`**: Represents a transaction input, including its reference and witness.\n   - **`StakeWitness`**: Similar to `SpendWitness`, but for staking operations.\n   - **`Withdrawal`**: Represents a withdrawal from a reward address, including the credential, amount, and witness.\n   - **`Certificate` and `CertificateAction`**: Used for staking certificates, indicating registration or unregistration actions.\n   - **`TransactionParams`**: Encapsulates all parameters needed to construct a transaction, including tokens, inputs, outputs, reference inputs, extra key witnesses, withdrawals, and certificates.\n\n2. **Functions**:\n   - **`emptyTxParams`**: Provides an empty set of transaction parameters.\n   - **`transact`**: Constructs and submits a transaction using the provided parameters. It handles minting, inputs, outputs, withdrawals, and certificates, and uses the emulator to simulate the transaction.\n\n### Basic Configs\n\n- **`refScriptAddress`**: Defines a reference script address using an always-succeeding validator.\n- **`testTokenSymbol`**: Defines a test token symbol using an always-succeeding minting policy.\n\n### EmulatorPredicates\n\nThese functions are used to define test cases and assertions for the emulator:\n\n- **`mustSucceed`**: Asserts that a transaction must succeed without any failed transactions.\n- **`mustExceedTxLimits`**: Asserts that a transaction must exceed certain limits, such as size or execution units.\n- **`scriptMustFail`**: Asserts that a transaction must fail due to a script error.\n- **`scriptMustFailWithError`**: Asserts that a transaction must fail with a specific script error.\n\n### Helper Functions\n\nThese functions assist in various tasks related to transaction construction and analysis:\n\n- **`toReferenceScript`**: Converts a serialized script to a reference script.\n- **`toVersionedMintingPolicy`**: Wraps a serialized script as a versioned minting policy.\n- **`toCardanoApiAddress`**: Converts a Plutus address to a Cardano API address.\n- **`toRedeemer` and `toDatum`**: Convert data to redeemer and datum formats, respectively.\n- **`utxoValue`**: Combines lovelace and token values into a Cardano value.\n- **`txOutRefWithValue` and `txOutRefWithReferenceScript`**: Find transaction output references based on value or reference script.\n- **`txOutRefsAndDatumsAtAddress`**: Retrieves transaction output references and their datums at a specific address.\n- **`grouped`**: Splits a list into groups of a specified size.\n- **`testTraceLastLogs` and `testTrace`**: Functions for debugging and printing emulator logs.\n\n### Re-exports\n\nThe module re-exports several functions and types from other modules, such as `E.runEmulatorM`, `E.defaultOptions`, and `PV2.OutputDatum`, to make them available for use in tests.\n\nOverall, this code provides a comprehensive framework for testing Cardano smart contracts in an emulator, allowing developers to simulate transactions, validate outcomes, and ensure the correctness of their Plutus scripts.", "file_path": "no-swaps/test/Test/Prelude.hs", "file": "Prelude.hs"}
{"instruction": "Explain the following smart contract code:", "input": "from parameterized import parameterized\n\nfrom uplc import ast as uplc, eval as uplc_eval\nfrom ..utils import eval_uplc\n\n\n@parameterized.expand(\n    [\n        [[0, 1]],\n        [[0]],\n        [[0, 1, 2]],\n        [[b\"hello\", 0]],\n    ]\n)\ndef test_integrity_check(xs):\n    source_code = \"\"\"\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Union\nfrom pycardano import Datum as Anything, PlutusData\nfrom opshin.std.integrity import check_integrity\n\n@dataclass()\nclass B(PlutusData):\n    CONSTR_ID = 1\n    foobar: int\n    bar: int\n\ndef validator(x: B) -> None:\n    check_integrity(x)\n\"\"\"\n    obj = uplc.PlutusConstr(\n        1,\n        [\n            uplc.PlutusInteger(x) if isinstance(x, int) else uplc.PlutusByteString(x)\n            for x in xs\n        ],\n    )\n    try:\n        eval_uplc(source_code, obj)\n    except Exception as e:\n        print(e)\n        res = False\n    else:\n        res = True\n    assert res == (len(xs) == 2 and all(isinstance(x, int) for x in xs))\n\n\n@parameterized.expand(\n    [\n        [0],\n        [1],\n        [2],\n    ]\n)\ndef test_integrity_check_list(bar_constr):\n    source_code = \"\"\"\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Union\nfrom pycardano import Datum as Anything, PlutusData\nfrom opshin.std.integrity import check_integrity\n\n@dataclass()\nclass A(PlutusData):\n    CONSTR_ID = 1\n    \n@dataclass()\nclass C(PlutusData):\n    CONSTR_ID = 0\n\n@dataclass()\nclass B(PlutusData):\n    CONSTR_ID = 1\n    bar: Union[A, C]\n\ndef validator(x: B) -> None:\n    check_integrity(x)\n\"\"\"\n    obj = uplc.PlutusConstr(\n        1,\n        [uplc.PlutusConstr(bar_constr, [])],\n    )\n    try:\n        eval_uplc(source_code, obj)\n    except:\n        res = False\n    else:\n        res = True\n    assert res == (bar_constr in (0, 1))\n\n\n@parameterized.expand(\n    [\n        [[0, 1], [1, 1, 1]],\n        [[b\"hello\"], [1, 1]],\n        [[0, 1, 2], [1, 0]],\n    ]\n)\ndef test_integrity_check_list(foobar, bar_constrs):\n    source_code = \"\"\"\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Union\nfrom pycardano import Datum as Anything, PlutusData\nfrom opshin.std.integrity import check_integrity\n\n@dataclass()\nclass A(PlutusData):\n    CONSTR_ID = 1\n\n@dataclass()\nclass B(PlutusData):\n    CONSTR_ID = 1\n    foobar: List[int]\n    bar: List[A]\n\ndef validator(x: B) -> None:\n    check_integrity(x)\n\"\"\"\n    obj = uplc.PlutusConstr(\n        1,\n        [\n            uplc.PlutusList(\n                [\n                    (\n                        uplc.PlutusInteger(x)\n                        if isinstance(x, int)\n                        else uplc.PlutusByteString(x)\n                    )\n                    for x in foobar\n                ]\n            ),\n            uplc.PlutusList([uplc.PlutusConstr(c, []) for c in bar_constrs]),\n        ],\n    )\n    try:\n        eval_uplc(source_code, obj)\n    except:\n        res = False\n    else:\n        res = True\n    assert res == (\n        all(isinstance(x, int) for x in foobar) and all(c == 1 for c in bar_constrs)\n    )\n\n\n@parameterized.expand(\n    [\n        [[0, 1, 2], [1, 1, 1]],\n        # check for incorrect type in keys\n        [[b\"hello\", 1], [1, 1]],\n        # check for incorrect type in values\n        [[1, 2], [1, b\"hello\"]],\n    ]\n)\ndef test_integrity_check_dict(keys, values):\n    source_code = \"\"\"\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Union\nfrom pycardano import Datum as Anything, PlutusData\nfrom opshin.std.integrity import check_integrity\n\n@dataclass()\nclass B(PlutusData):\n    CONSTR_ID = 1\n    foobar: Dict[int, int]\n\ndef validator(x: B) -> None:\n    check_integrity(x)\n\"\"\"\n    obj = uplc.PlutusConstr(\n        1,\n        [\n            uplc.PlutusMap(\n                {\n                    (\n                        uplc.PlutusInteger(x)\n                        if isinstance(x, int)\n                        else uplc.PlutusByteString(x)\n                    ): (\n                        uplc.PlutusInteger(y)\n                        if isinstance(y, int)\n                        else uplc.PlutusByteString(y)\n                    )\n                    for x, y in zip(keys, values)\n                },\n            ),\n        ],\n    )\n    try:\n        eval_uplc(source_code, obj)\n    except:\n        res = False\n    else:\n        res = True\n    assert res == (\n        all(isinstance(x, int) for x in keys + values) and len(set(keys)) == len(keys)\n    )\n\n\ndef test_integrity_check_rename():\n    source_code = \"\"\"\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Union\nfrom pycardano import Datum as Anything, PlutusData\nfrom opshin.std.integrity import check_integrity as integ\n\n@dataclass()\nclass B(PlutusData):\n    CONSTR_ID = 1\n    foobar: int\n\ndef validator(x: B) -> None:\n    integ(x)\n\"\"\"\n    obj = uplc.PlutusConstr(\n        1,\n        [uplc.PlutusInteger(1)],\n    )\n    eval_uplc(source_code, obj)\n\n\n# TODO implement better way to check for uniqueness test in dict keys\n", "output": "This code is a set of unit tests for a Cardano smart contract, specifically testing the integrity of data structures using the `check_integrity` function from the `opshin.std.integrity` module. The tests are written in Python and use the `parameterized` library to run multiple test cases with different inputs. The tests are designed to ensure that the data structures conform to expected types and constraints.\n\nHere's a detailed breakdown of each part of the code:\n\n### Imports\n\n- `parameterized`: A library that allows parameterized testing, enabling the same test to run with different inputs.\n- `uplc`: A module for working with Untyped Plutus Core (UPLC), which is the low-level language used for Cardano smart contracts.\n- `eval_uplc`: A utility function presumably defined elsewhere in the codebase, used to evaluate UPLC code.\n\n### Test Functions\n\n1. **`test_integrity_check`**\n\n   This test checks the integrity of a `PlutusData` object with a constructor ID of 1 and two integer fields (`foobar` and `bar`). The test is parameterized with different lists of integers and byte strings. The `check_integrity` function is expected to ensure that the object has exactly two integer fields.\n\n   - **Input**: Lists of integers and/or byte strings.\n   - **Expected Result**: The test passes if the list has exactly two integers.\n\n2. **`test_integrity_check_list`**\n\n   This test checks the integrity of a `PlutusData` object with a constructor ID of 1 and a field `bar` that can be either of type `A` or `C`. The test is parameterized with different constructor IDs for `bar`.\n\n   - **Input**: Constructor IDs (0, 1, or 2).\n   - **Expected Result**: The test passes if `bar` is of type `A` or `C` (constructor ID 0 or 1).\n\n3. **`test_integrity_check_list` (overloaded)**\n\n   This test checks the integrity of a `PlutusData` object with a constructor ID of 1 and two fields: `foobar` (a list of integers) and `bar` (a list of `A` objects). The test is parameterized with lists of integers and constructor IDs.\n\n   - **Input**: Lists of integers for `foobar` and constructor IDs for `bar`.\n   - **Expected Result**: The test passes if all elements in `foobar` are integers and all elements in `bar` have constructor ID 1.\n\n4. **`test_integrity_check_dict`**\n\n   This test checks the integrity of a `PlutusData` object with a constructor ID of 1 and a dictionary `foobar` with integer keys and values. The test is parameterized with lists of keys and values.\n\n   - **Input**: Lists of keys and values (integers or byte strings).\n   - **Expected Result**: The test passes if all keys and values are integers and all keys are unique.\n\n5. **`test_integrity_check_rename`**\n\n   This test checks the integrity of a `PlutusData` object with a constructor ID of 1 and a single integer field `foobar`. The `check_integrity` function is aliased as `integ`.\n\n   - **Input**: A single integer.\n   - **Expected Result**: The test passes if the object is correctly constructed with an integer field.\n\n### Summary\n\nThese tests are designed to ensure that the `check_integrity` function correctly validates the structure and types of `PlutusData` objects. The tests cover various data structures, including lists and dictionaries, and check for correct types, field counts, and uniqueness of dictionary keys. The use of parameterized tests allows for efficient testing of multiple scenarios with different inputs.", "file_path": "opshin/tests/test_std/test_integrity.py", "file": "test_integrity.py"}
{"instruction": "Explain the following smart contract code:", "input": "from typing import Optional\nfrom enum import Enum, auto\n\nfrom ..util import CompilingNodeTransformer\nfrom ..typed_ast import *\n\n\"\"\"\nChecks that there was an import of dataclass if there are any class definitions\n\"\"\"\n\n\n@dataclass(frozen=True, unsafe_hash=True)\nclass HashType(ClassType):\n    \"\"\"A pseudo class that is the result of python hash functions that need a 'digest' call\"\"\"\n\n    def attribute_type(self, attr) -> \"Type\":\n        if attr == \"digest\":\n            return InstanceType(FunctionType(frozenlist([]), ByteStringInstanceType))\n        raise NotImplementedError(\"HashType only has attribute 'digest'\")\n\n    def attribute(self, attr) -> plt.AST:\n        if attr == \"digest\":\n            return plt.Lambda([\"self\"], plt.Var(\"self\"))\n        raise NotImplementedError(\"HashType only has attribute 'digest'\")\n\n    def __ge__(self, other):\n        return isinstance(other, HashType)\n\n\nHashInstanceType = InstanceType(HashType())\n\n\nclass PythonHashlib(Enum):\n    sha256 = auto()\n    sha3_256 = auto()\n    blake2b = auto()\n\n\nPythonHashlibTypes = {\n    PythonHashlib.sha256: InstanceType(\n        FunctionType(\n            frozenlist([ByteStringInstanceType]),\n            HashInstanceType,\n        )\n    ),\n    PythonHashlib.sha3_256: InstanceType(\n        FunctionType(\n            frozenlist([ByteStringInstanceType]),\n            HashInstanceType,\n        )\n    ),\n    PythonHashlib.blake2b: InstanceType(\n        FunctionType(\n            frozenlist([ByteStringInstanceType]),\n            HashInstanceType,\n        )\n    ),\n}\n\nPythonHashlibImpls = {\n    PythonHashlib.sha256: force_params(\n        plt.Lambda([\"x\"], plt.Lambda([\"_\"], plt.Sha2_256(plt.Var(\"x\"))))\n    ),\n    PythonHashlib.sha3_256: force_params(\n        plt.Lambda([\"x\"], plt.Lambda([\"_\"], plt.Sha3_256(plt.Var(\"x\"))))\n    ),\n    PythonHashlib.blake2b: force_params(\n        plt.Lambda([\"x\"], plt.Lambda([\"_\"], plt.Blake2b_256(plt.Var(\"x\"))))\n    ),\n}\n\n\nclass RewriteImportHashlib(CompilingNodeTransformer):\n    step = \"Resolving imports and usage of hashlib\"\n\n    imports_hashlib = False\n\n    def visit_ImportFrom(self, node: ImportFrom) -> typing.List[AST]:\n        if node.module != \"hashlib\":\n            return node\n        additional_assigns = []\n        for n in node.names:\n            imported_fun = None\n            for h in PythonHashlib:\n                if h.name == n.name:\n                    imported_fun = h\n            assert (\n                imported_fun is not None\n            ), f\"Unsupported function import from hashlib '{n.name}\"\n            typ = PythonHashlibTypes[imported_fun]\n            imported_name = n.name if n.asname is None else n.asname\n            additional_assigns.append(\n                TypedAssign(\n                    targets=[TypedName(id=imported_name, typ=typ, ctx=Store())],\n                    value=RawPlutoExpr(typ=typ, expr=PythonHashlibImpls[imported_fun]),\n                )\n            )\n        return additional_assigns\n", "output": "This Cardano smart contract code is part of a system that processes and rewrites Python code to be compatible with a specific execution environment, likely related to smart contracts on the Cardano blockchain. The code focuses on handling imports from Python's `hashlib` module, specifically for cryptographic hash functions. Let's break down the code in detail:\n\n### Imports and Dependencies\n\n- **Typing and Enum**: The code uses Python's `typing` module for type annotations and `Enum` for defining a set of named constants.\n- **Dataclass**: The `dataclass` decorator is used to create immutable and hashable class types.\n- **Custom Modules**: The code imports `CompilingNodeTransformer` from a utility module and various types from a `typed_ast` module, which likely provides an abstract syntax tree (AST) representation with type information.\n\n### HashType Class\n\n- **Purpose**: `HashType` is a pseudo-class representing the result of Python hash functions that require a `digest` call.\n- **Attributes**: It defines an `attribute_type` method that specifies the type of the `digest` attribute, which is a function returning a `ByteStringInstanceType`.\n- **Methods**: The `attribute` method returns a lambda function for the `digest` attribute, and the `__ge__` method checks if another object is an instance of `HashType`.\n\n### Hash Instance Type\n\n- **HashInstanceType**: This is an instance of `HashType`, representing a specific type of hash object.\n\n### PythonHashlib Enum\n\n- **Purpose**: Defines constants for supported hash functions: `sha256`, `sha3_256`, and `blake2b`.\n\n### PythonHashlibTypes Dictionary\n\n- **Purpose**: Maps each hash function in `PythonHashlib` to its corresponding type. Each type is a function that takes a `ByteStringInstanceType` and returns a `HashInstanceType`.\n\n### PythonHashlibImpls Dictionary\n\n- **Purpose**: Maps each hash function to its implementation using lambda expressions. These implementations use placeholder functions (`plt.Sha2_256`, `plt.Sha3_256`, `plt.Blake2b_256`) to represent the actual hash computations.\n\n### RewriteImportHashlib Class\n\n- **Purpose**: A transformer class that processes Python AST nodes to handle imports from the `hashlib` module.\n- **Attributes**: \n  - `step`: Describes the transformation step.\n  - `imports_hashlib`: A flag indicating whether `hashlib` has been imported.\n- **Methods**:\n  - `visit_ImportFrom`: This method processes `ImportFrom` nodes in the AST. If the module being imported is `hashlib`, it checks each imported name against the `PythonHashlib` enum. If a match is found, it creates a `TypedAssign` node that assigns the appropriate type and implementation to the imported name. This effectively rewrites the import to use the custom hash function implementations defined earlier.\n\n### Summary\n\nThis code is part of a system that transforms Python code to be compatible with a specific execution environment, likely for smart contracts on Cardano. It specifically handles imports from the `hashlib` module, providing custom implementations for certain hash functions (`sha256`, `sha3_256`, `blake2b`). The transformation ensures that these functions are correctly typed and implemented in the target environment, allowing for secure and efficient cryptographic operations.", "file_path": "opshin/opshin/rewrite/rewrite_import_hashlib.py", "file": "rewrite_import_hashlib.py"}
{"instruction": "Explain the following smart contract code:", "input": "module Test.Plutip.Tools.DebugCli (\n  debugCli,\n  utxoAtAddress,\n) where\n\nimport Cardano.Launcher.Node (nodeSocketFile)\nimport Data.ByteString.Lazy.Char8 qualified as BS\nimport GHC.IO.Exception (ExitCode (ExitSuccess))\nimport System.Environment (getEnvironment)\nimport System.Exit (ExitCode (ExitFailure))\nimport System.Process.Typed (\n  proc,\n  readProcess,\n  setEnv,\n )\nimport Test.Plutip.Internal.Types (ClusterEnv, nodeSocket)\n\n-- | Call `cardano-cli` as external process.\n-- `cardano-cli` must be available in shell\ndebugCli ::\n  ClusterEnv ->\n  [String] ->\n  IO BS.ByteString\ndebugCli cEnv args = do\n  env <- getEnvironment\n  let socket = nodeSocketFile $ nodeSocket cEnv\n      process =\n        setEnv ((\"CARDANO_NODE_SOCKET_PATH\", socket) : env) $\n          proc \"cardano-cli\" args\n  (st, out, err) <- readProcess process\n  pure $ case st of\n    ExitSuccess -> out\n    ExitFailure _ -> err\n\n-- | Get UTxOs at address using `cardano-cli` as external process.\n-- `cardano-cli` must be available in shell\nutxoAtAddress :: ClusterEnv -> String -> IO ()\nutxoAtAddress ce addr = do\n  res <- debugCli ce [\"query\", \"utxo\", \"--mainnet\", \"--address\", addr]\n  BS.putStrLn $ \"UTxO at \" <> BS.pack addr <> \": \" <> res\n", "output": "The provided Haskell code is part of a module designed to interact with the Cardano blockchain using the `cardano-cli` command-line tool. This module, `Test.Plutip.Tools.DebugCli`, provides utilities to execute `cardano-cli` commands and retrieve UTxO (Unspent Transaction Outputs) information for a given address. Let's break down the code in detail:\n\n### Module and Imports\n\n```haskell\nmodule Test.Plutip.Tools.DebugCli (\n  debugCli,\n  utxoAtAddress,\n) where\n```\n\n- **Module Declaration**: The module is named `Test.Plutip.Tools.DebugCli` and it exports two functions: `debugCli` and `utxoAtAddress`.\n\n```haskell\nimport Cardano.Launcher.Node (nodeSocketFile)\nimport Data.ByteString.Lazy.Char8 qualified as BS\nimport GHC.IO.Exception (ExitCode (ExitSuccess))\nimport System.Environment (getEnvironment)\nimport System.Exit (ExitCode (ExitFailure))\nimport System.Process.Typed (\n  proc,\n  readProcess,\n  setEnv,\n )\nimport Test.Plutip.Internal.Types (ClusterEnv, nodeSocket)\n```\n\n- **Imports**:\n  - `Cardano.Launcher.Node`: Provides functionality to get the node socket file path.\n  - `Data.ByteString.Lazy.Char8`: Used for handling lazy byte strings, which are suitable for I/O operations.\n  - `GHC.IO.Exception` and `System.Exit`: Used for handling process exit codes.\n  - `System.Environment`: Used to get the current environment variables.\n  - `System.Process.Typed`: Provides functions to create and manage system processes.\n  - `Test.Plutip.Internal.Types`: Imports `ClusterEnv`, which likely contains environment configuration for a Cardano cluster.\n\n### `debugCli` Function\n\n```haskell\ndebugCli ::\n  ClusterEnv ->\n  [String] ->\n  IO BS.ByteString\ndebugCli cEnv args = do\n  env <- getEnvironment\n  let socket = nodeSocketFile $ nodeSocket cEnv\n      process =\n        setEnv ((\"CARDANO_NODE_SOCKET_PATH\", socket) : env) $\n          proc \"cardano-cli\" args\n  (st, out, err) <- readProcess process\n  pure $ case st of\n    ExitSuccess -> out\n    ExitFailure _ -> err\n```\n\n- **Purpose**: This function executes the `cardano-cli` command with the provided arguments and returns the output as a lazy `ByteString`.\n- **Parameters**:\n  - `cEnv`: A `ClusterEnv` object that contains the environment configuration for the Cardano node.\n  - `args`: A list of strings representing the arguments to pass to `cardano-cli`.\n- **Process**:\n  1. **Get Environment**: Retrieves the current environment variables.\n  2. **Socket Path**: Extracts the node socket file path from the `ClusterEnv`.\n  3. **Process Setup**: Configures the process to run `cardano-cli` with the specified arguments and sets the `CARDANO_NODE_SOCKET_PATH` environment variable.\n  4. **Execute Process**: Runs the process and captures the exit status, standard output, and standard error.\n  5. **Return Output**: Returns the standard output if the process succeeds, otherwise returns the error output.\n\n### `utxoAtAddress` Function\n\n```haskell\nutxoAtAddress :: ClusterEnv -> String -> IO ()\nutxoAtAddress ce addr = do\n  res <- debugCli ce [\"query\", \"utxo\", \"--mainnet\", \"--address\", addr]\n  BS.putStrLn $ \"UTxO at \" <> BS.pack addr <> \": \" <> res\n```\n\n- **Purpose**: Queries the UTxOs at a specified address on the Cardano mainnet and prints the result.\n- **Parameters**:\n  - `ce`: A `ClusterEnv` object for the Cardano node environment.\n  - `addr`: A string representing the Cardano address to query.\n- **Process**:\n  1. **Call `debugCli`**: Uses `debugCli` to execute the `cardano-cli query utxo` command with the `--mainnet` flag and the specified address.\n  2. **Print Result**: Outputs the UTxO information to the console, prefixed with the address.\n\n### Summary\n\nThis module provides a simple interface to interact with the Cardano blockchain using `cardano-cli`. It abstracts the process of setting up the environment and executing commands, making it easier to query blockchain data, such as UTxOs at a specific address. The use of `ClusterEnv` suggests that this code is intended to be used in a testing or development environment where a Cardano node is running.", "file_path": "plutip/src/Test/Plutip/Tools/DebugCli.hs", "file": "DebugCli.hs"}
{"instruction": "Explain the following smart contract code:", "input": "module Main (main) where\n\nimport Spec.Integration qualified as Integration\n\nimport Spec.Test.Plutip.BotPlutusInterface qualified as BotInterface\nimport Test.Tasty (defaultMain, testGroup)\n\nmain :: IO ()\nmain =\n  defaultMain $\n    testGroup\n      \"tests\"\n      -- FIXME: both `Integration.test` and `BotInterface.test`\n      -- start own cluster to run tests, probably, need better solution in future\n      [ Integration.test\n      , BotInterface.test\n      ]\n", "output": "This Haskell code is a test suite for Cardano smart contracts, specifically using the Plutus framework. Let's break down the code step by step:\n\n### Module Declaration\n\n```haskell\nmodule Main (main) where\n```\n\nThis line declares a Haskell module named `Main` and specifies that it exports the `main` function. The `main` function is the entry point for a Haskell program.\n\n### Imports\n\n```haskell\nimport Spec.Integration qualified as Integration\nimport Spec.Test.Plutip.BotPlutusInterface qualified as BotInterface\nimport Test.Tasty (defaultMain, testGroup)\n```\n\n- **`import Spec.Integration qualified as Integration`**: This imports the `Spec.Integration` module and qualifies it with the alias `Integration`. This means that any functions or values from this module must be prefixed with `Integration.` when used.\n\n- **`import Spec.Test.Plutip.BotPlutusInterface qualified as BotInterface`**: Similar to the previous import, this imports the `Spec.Test.Plutip.BotPlutusInterface` module and qualifies it with the alias `BotInterface`.\n\n- **`import Test.Tasty (defaultMain, testGroup)`**: This imports specific functions from the `Test.Tasty` library, which is a Haskell testing framework. `defaultMain` is used to run the tests, and `testGroup` is used to group multiple tests together.\n\n### Main Function\n\n```haskell\nmain :: IO ()\nmain =\n  defaultMain $\n    testGroup\n      \"tests\"\n      -- FIXME: both `Integration.test` and `BotInterface.test`\n      -- start own cluster to run tests, probably, need better solution in future\n      [ Integration.test\n      , BotInterface.test\n      ]\n```\n\n- **`main :: IO ()`**: This specifies the type of the `main` function. It is an `IO` action that returns `()` (unit), which is typical for a Haskell program's main function.\n\n- **`defaultMain`**: This function is part of the Tasty testing framework. It takes a `TestTree` (a data structure representing a collection of tests) and runs it.\n\n- **`testGroup \"tests\" [...]`**: This creates a group of tests with the label \"tests\". The tests within this group are specified in the list that follows.\n\n- **`[ Integration.test, BotInterface.test ]`**: This is a list of tests to be run. `Integration.test` and `BotInterface.test` are presumably test suites or individual tests defined in their respective modules. \n\n### Comment\n\n```haskell\n-- FIXME: both `Integration.test` and `BotInterface.test`\n-- start own cluster to run tests, probably, need better solution in future\n```\n\nThis comment indicates a known issue or limitation in the current setup. Both `Integration.test` and `BotInterface.test` start their own Cardano cluster to run tests. This might be inefficient or problematic, and the comment suggests that a better solution is needed in the future. This could involve sharing a single cluster instance between tests to save resources and time.\n\n### Summary\n\nThis code sets up a test suite for Cardano smart contracts using the Plutus framework. It imports necessary modules, defines a main function that runs a group of tests using the Tasty framework, and includes a comment about a potential improvement in the test setup. The tests are likely related to integration testing and interfacing with the Plutus smart contract environment.", "file_path": "plutip/test/Main.hs", "file": "Main.hs"}
{"instruction": "Explain the following smart contract code:", "input": "#!opshin\n\n\ndef validator(n: int) -> int:\n    # Tuple assignment works\n    a, b = 3, n\n    # control flow via if, for and while\n    if b < 5:\n        print(\"add\")\n        a += 5\n    while b < 5:\n        b += 1\n    for i in range(2):\n        print(\"loop\", i)\n\n    # sha256, sha3_256 and blake2b\n    from hashlib import sha256 as hsh\n\n    x = hsh(b\"123\").digest()\n\n    # bytestring slicing, assertions\n    assert x[1:3] == b\"e\" + b\"\\xa4\", \"Hash is wrong\"\n\n    # create lists, check their length, add up integers\n    y = [1, 2]\n    return a + len(x) + len(y) if y[0] == 1 else 0\n", "output": "This Cardano smart contract code is written in Opshin, a Python-like language for writing smart contracts on the Cardano blockchain. Let's break down the code step by step:\n\n### Function Definition\n\n```python\ndef validator(n: int) -> int:\n```\n\n- The function `validator` takes a single integer argument `n` and returns an integer. This function is likely intended to be used as a validator script in a Cardano smart contract.\n\n### Tuple Assignment\n\n```python\na, b = 3, n\n```\n\n- This line demonstrates tuple unpacking in Python. It assigns the value `3` to `a` and the value of the input parameter `n` to `b`.\n\n### Control Flow: If Statement\n\n```python\nif b < 5:\n    print(\"add\")\n    a += 5\n```\n\n- If `b` (which is initially `n`) is less than 5, the code prints \"add\" and increments `a` by 5.\n\n### Control Flow: While Loop\n\n```python\nwhile b < 5:\n    b += 1\n```\n\n- This loop increments `b` until it is no longer less than 5. If `b` starts at 5 or more, this loop does nothing.\n\n### Control Flow: For Loop\n\n```python\nfor i in range(2):\n    print(\"loop\", i)\n```\n\n- This loop iterates twice (for `i` values 0 and 1) and prints \"loop\" followed by the current value of `i`.\n\n### Hashing\n\n```python\nfrom hashlib import sha256 as hsh\nx = hsh(b\"123\").digest()\n```\n\n- The code imports the `sha256` hashing function from Python's `hashlib` module and aliases it as `hsh`.\n- It then computes the SHA-256 hash of the byte string `b\"123\"` and stores the resulting hash (a bytes object) in `x`.\n\n### Bytestring Slicing and Assertions\n\n```python\nassert x[1:3] == b\"e\" + b\"\\xa4\", \"Hash is wrong\"\n```\n\n- This line checks that the second and third bytes of the hash `x` are equal to the bytes `b\"e\\xa4\"`.\n- If this condition is not met, the assertion will fail, and the message \"Hash is wrong\" will be raised as an error.\n\n### List Operations and Conditional Return\n\n```python\ny = [1, 2]\nreturn a + len(x) + len(y) if y[0] == 1 else 0\n```\n\n- A list `y` is created with elements `[1, 2]`.\n- The function returns the sum of `a`, the length of `x` (which is the length of the SHA-256 hash, typically 32 bytes), and the length of `y` (which is 2) if the first element of `y` is `1`.\n- If `y[0]` is not `1`, the function returns `0`.\n\n### Summary\n\nThis smart contract function demonstrates various Python features such as tuple unpacking, control flow with `if`, `while`, and `for` loops, hashing with SHA-256, bytestring slicing, assertions, and list operations. The function's behavior is determined by the input `n` and the hardcoded values and conditions within the function. The function's primary purpose seems to be educational, showcasing different language features rather than implementing a specific business logic.", "file_path": "opshin/examples/showcase.py", "file": "showcase.py"}
{"instruction": "Explain the following smart contract code:", "input": "{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main (main) where\n\nimport Cardano.Api.SerialiseTextEnvelope (textEnvelopeToJSON, writeFileTextEnvelope)\nimport qualified Cardano.Api.Shelley as Script\nimport Codec.Serialise (serialise)\nimport Control.Monad (forM_, void)\nimport qualified Data.ByteString.Lazy as BSL\nimport qualified Data.ByteString.Short as SBS\nimport Data.Text.Lazy (Text)\nimport qualified Data.Text.Lazy as T\nimport Data.Text.Lazy.Encoding (decodeLatin1)\nimport qualified Data.Text.Lazy.IO as TIO\nimport Indigo.Contracts.CDP.OnChain (cdpCreatorScriptCTL, cdpScriptCTL, iAssetPolicyScriptCTL)\nimport Indigo.Contracts.Collector.OnChain (collectorScriptCTL)\nimport Indigo.Contracts.Governance.Execute.OnChain (executeScriptCTL)\nimport Indigo.Contracts.Governance.Gov.OnChain (govScriptCTL)\nimport Indigo.Contracts.Governance.Poll.OnChain (pollManagerScriptCTL, pollScriptCTL)\nimport Indigo.Contracts.Governance.VersionRegistry.OnChain (versionRecordTokenPolicyScriptCTL, versionRegistryScriptCTL)\nimport Indigo.Contracts.Liquidity.OnChain (liquidityScriptCTL)\nimport Indigo.Contracts.Oracle.OnChain (oracleScriptCTL)\nimport Indigo.Contracts.StabilityPool.OnChain (stabilityPoolScriptCTL)\nimport Indigo.Contracts.Staking.OnChain (stakingScriptCTL)\nimport Indigo.Contracts.Treasury.OnChain (treasuryScriptCTL)\nimport Indigo.Data.Token (authTokenCTL)\nimport Options.Applicative (ParserInfo, execParser, fullDesc, help, helper, info, long, metavar, progDesc, showDefault, strOption, switch, value)\nimport Options.Applicative.Common (Parser)\nimport Plutus.V2.Ledger.Api (Script)\nimport System.Directory (createDirectoryIfMissing)\nimport System.FilePath ((</>))\n\ndata CliOptions = CliOptions\n  { optsFolder :: FilePath,\n    optsOutputFfisFlag :: Bool\n  }\n\ncliOptionsParser :: Parser CliOptions\ncliOptionsParser =\n  CliOptions\n    <$> strOption\n      ( long \"out\"\n          <> metavar \"FOLDER\"\n          <> showDefault\n          <> value \"scripts\"\n          <> help \"Folder for saving scripts\"\n      )\n    <*> switch\n      ( long \"export-purescript-ffis\"\n          <> showDefault\n          <> help\n            \"Whether to serialise the scripts as Purescript's FFI \\\n            \\modules for use in offchain\"\n      )\n\nopts :: ParserInfo CliOptions\nopts =\n  info\n    cliOptionsParser\n    (fullDesc <> progDesc \"Serialise scripts to a FOLDER\")\n\n-- | Convert a 'Script' to a 'cardano-api' script\ntoCardanoApiScript :: Script -> Script.Script Script.PlutusScriptV2\ntoCardanoApiScript =\n  Script.PlutusScript Script.PlutusScriptV2\n    . Script.PlutusScriptSerialised\n    . SBS.toShort\n    . BSL.toStrict\n    . serialise\n\nsaveScriptRepr :: FilePath -> Script -> IO ()\nsaveScriptRepr filename script = void $ writeFileTextEnvelope filename Nothing $ toCardanoApiScript script\n\nsaveFfiRepr :: FilePath -> Text -> Script -> IO ()\nsaveFfiRepr filename varName script = TIO.writeFile filename fileContents\n  where\n    scriptJson :: Text\n    scriptJson = decodeLatin1 $ textEnvelopeToJSON Nothing $ toCardanoApiScript script\n    fileContents :: Text\n    fileContents =\n      \"/* Automatically generated by serialise-contract executable in smart-contracts */\\n\"\n        <> varName\n        <> \" = \"\n        <> scriptJson\n        <> \";\\n\"\n        <> \"exports._\"\n        <> varName\n        <> \" = JSON.stringify(\"\n        <> varName\n        <> \");\\n\"\n\n-- Note: does not include `mkUpgradeMintingPolicyScriptCTL`\nscripts :: [(FilePath, Script)]\nscripts =\n  [ -- CDP\n    (\"cdp.plutus\", cdpScriptCTL),\n    (\"cdp_creator.plutus\", cdpCreatorScriptCTL),\n    (\"iasset_policy.plutus\", iAssetPolicyScriptCTL),\n    -- Collector\n    (\"collector.plutus\", collectorScriptCTL),\n    -- Governance.Execute\n    (\"execute.plutus\", executeScriptCTL),\n    -- Governance.Gov\n    (\"gov.plutus\", govScriptCTL),\n    -- Governance.Poll\n    (\"poll.plutus\", pollScriptCTL),\n    (\"poll_manager.plutus\", pollManagerScriptCTL),\n    -- Governance.VersionRegistry\n    (\"version_record_token_policy.plutus\", versionRecordTokenPolicyScriptCTL),\n    (\"version_registry.plutus\", versionRegistryScriptCTL),\n    -- Liquidity\n    (\"liquidity.plutus\", liquidityScriptCTL),\n    -- Oracle\n    (\"oracle.plutus\", oracleScriptCTL),\n    -- StabilityPool\n    (\"stability_pool.plutus\", stabilityPoolScriptCTL),\n    -- Staking\n    (\"staking.plutus\", stakingScriptCTL),\n    -- Treasury\n    (\"treasury.plutus\", treasuryScriptCTL),\n    -- Auth token policy\n    (\"auth_token_policy.plutus\", authTokenCTL)\n  ]\n\n-- Equivalent to association map above, but used for creating the Purescript\n-- FFI modules used by the bots.\nscriptsFfi :: [(FilePath, Text, Script)]\nscriptsFfi =\n  [ -- CDP\n    (\"CDPValidator.js\", \"cdpValidator\", cdpScriptCTL),\n    (\"CDPCreatorValidator.js\", \"cdpCreatorValidator\", cdpCreatorScriptCTL),\n    (\"IAssetToken.js\", \"iAssetTokenPolicy\", iAssetPolicyScriptCTL),\n    -- Collector\n    (\"CollectorValidator.js\", \"collectorValidator\", collectorScriptCTL),\n    -- Governance.Execute\n    (\"ExecuteValidator.js\", \"executeValidator\", executeScriptCTL),\n    -- Governance.Gov\n    (\"GovernanceValidator.js\", \"governanceValidator\", govScriptCTL),\n    -- Governance.Poll\n    (\"PollValidator.js\", \"pollValidator\", pollScriptCTL),\n    (\"PollManagerValidator.js\", \"pollManagerValidator\", pollManagerScriptCTL),\n    -- Governance.VersionRegistry\n    (\"VersionRecordToken.js\", \"versionRecordTokenPolicy\", versionRecordTokenPolicyScriptCTL),\n    (\"VersionRegistry.js\", \"versionRegistryValidator\", versionRegistryScriptCTL),\n    -- Liquidity\n    (\"LiquidityValidator.js\", \"liquidityValidator\", liquidityScriptCTL),\n    -- Oracle\n    (\"OracleValidator.js\", \"oracleValidator\", oracleScriptCTL),\n    -- StabilityPool\n    (\"StabilityPoolValidator.js\", \"stabilityPoolValidator\", stabilityPoolScriptCTL),\n    -- Staking\n    (\"StakingValidator.js\", \"stakingValidator\", stakingScriptCTL),\n    -- Treasury\n    (\"TreasuryValidator.js\", \"treasuryValidator\", treasuryScriptCTL),\n    -- Auth token policy\n    (\"AuthToken.js\", \"authTokenPolicy\", authTokenCTL)\n  ]\n\nmain :: IO ()\nmain = do\n  CliOptions {optsFolder, optsOutputFfisFlag} <- execParser opts\n  createDirectoryIfMissing False optsFolder\n  if optsOutputFfisFlag\n    then forM_ scriptsFfi $ \\(jsFilename, varName, script) -> do\n      let path = optsFolder </> jsFilename\n      putStrLn $ \"Saving \" ++ path\n      saveFfiRepr path varName script\n    else forM_ scripts $ \\(plutusFilename, script) -> do\n      let path = optsFolder </> plutusFilename\n      putStrLn $ \"Saving \" ++ path\n      saveScriptRepr path script\n", "output": "This Haskell code is a Cardano smart contract serialization tool. It is designed to serialize various Plutus scripts used in the Indigo protocol and save them to files. The tool can output these scripts in two formats: as raw Plutus scripts or as JavaScript Foreign Function Interface (FFI) modules for use in off-chain applications. Let's break down the code in detail:\n\n### Language Extensions and Module Declaration\n\n```haskell\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main (main) where\n```\n\n- **NamedFieldPuns**: Allows for more convenient syntax when working with record fields.\n- **OverloadedStrings**: Enables string literals to be interpreted as different string types.\n- **module Main (main) where**: Declares the `Main` module and exports the `main` function.\n\n### Imports\n\nThe code imports several modules:\n\n- **Cardano.Api.SerialiseTextEnvelope**: Functions for serializing scripts to JSON and writing them to files.\n- **Cardano.Api.Shelley**: Provides types and functions related to Cardano scripts.\n- **Codec.Serialise**: Used for serializing data.\n- **Control.Monad**: Provides utility functions for monadic operations.\n- **Data.ByteString.Lazy/Short**: ByteString operations for handling binary data.\n- **Data.Text.Lazy**: Lazy text operations.\n- **Indigo.Contracts**: Imports various on-chain scripts from the Indigo protocol.\n- **Options.Applicative**: For command-line option parsing.\n- **Plutus.V2.Ledger.Api**: Provides the `Script` type for Plutus scripts.\n- **System.Directory/FilePath**: For file and directory operations.\n\n### Data Types and Parsers\n\n```haskell\ndata CliOptions = CliOptions\n  { optsFolder :: FilePath,\n    optsOutputFfisFlag :: Bool\n  }\n```\n\n- **CliOptions**: A record type to hold command-line options, including the output folder and a flag to determine if FFI modules should be generated.\n\n```haskell\ncliOptionsParser :: Parser CliOptions\n```\n\n- **cliOptionsParser**: Defines how to parse command-line options into a `CliOptions` record.\n\n```haskell\nopts :: ParserInfo CliOptions\n```\n\n- **opts**: Wraps the parser with additional information like descriptions.\n\n### Script Serialization Functions\n\n```haskell\ntoCardanoApiScript :: Script -> Script.Script Script.PlutusScriptV2\n```\n\n- **toCardanoApiScript**: Converts a Plutus `Script` to a `cardano-api` script, suitable for serialization.\n\n```haskell\nsaveScriptRepr :: FilePath -> Script -> IO ()\n```\n\n- **saveScriptRepr**: Saves a serialized script to a file using the `cardano-api` text envelope format.\n\n```haskell\nsaveFfiRepr :: FilePath -> Text -> Script -> IO ()\n```\n\n- **saveFfiRepr**: Saves a script as a JavaScript FFI module. It serializes the script to JSON and writes it to a file with a specific format for use in JavaScript.\n\n### Script Lists\n\n```haskell\nscripts :: [(FilePath, Script)]\n```\n\n- **scripts**: A list of tuples, each containing a file path and a corresponding Plutus script. These are the scripts to be serialized as `.plutus` files.\n\n```haskell\nscriptsFfi :: [(FilePath, Text, Script)]\n```\n\n- **scriptsFfi**: Similar to `scripts`, but includes a variable name for each script. These are used to generate JavaScript FFI modules.\n\n### Main Function\n\n```haskell\nmain :: IO ()\n```\n\n- **main**: The entry point of the program. It parses command-line options, creates the output directory if it doesn't exist, and then serializes the scripts. Depending on the `optsOutputFfisFlag`, it either saves the scripts as `.plutus` files or as JavaScript FFI modules.\n\n### Execution Flow\n\n1. **Parse Command-Line Options**: Uses `execParser` to parse options into a `CliOptions` record.\n2. **Create Output Directory**: Ensures the specified output directory exists.\n3. **Serialize Scripts**: Iterates over the list of scripts. If `optsOutputFfisFlag` is true, it saves scripts as JavaScript FFI modules; otherwise, it saves them as `.plutus` files.\n\nThis tool is essential for developers working with the Indigo protocol, as it automates the process of preparing Plutus scripts for deployment and integration with off-chain systems.", "file_path": "indigo-smart-contracts/serialise/Main.hs", "file": "Main.hs"}
{"instruction": "Explain the following smart contract code:", "input": "import copy\nimport datetime\nimport secrets\nimport time\nfrom typing import Optional\n\nimport fire\nimport pycardano\nfrom opshin.ledger.api_v2 import (\n    ScriptCredential,\n    NoOutputDatum,\n    SomeOutputDatumHash,\n)\nfrom opshin.std.builtins import sha2_256\nfrom opshin.std.math import bytes_big_from_unsigned_int\nfrom opshin.std.fractions import floor_fraction, ceil_fraction\nfrom pycardano import (\n    TransactionBuilder,\n    TransactionOutput,\n    Redeemer,\n    DeserializeException,\n    Value,\n    Withdrawals,\n    Address,\n    UTxO,\n)\nfrom steak_protocol.onchain.stakepool.stakepool import (\n    InteractWithPool,\n    PoolState,\n)\nfrom steak_protocol.offchain.util import (\n    sorted_utxos,\n    with_min_lovelace,\n    STAKE_CHAIN_AUTH_NFT,\n    amount_of_token_in_value,\n    token_from_string,\n    asset_from_token,\n    custom_sign_message,\n    commit_hash_secrets,\n    write_ahead_hash_secrets,\n    all_committed_hash_secrets,\n    ContractVersion,\n    VERSION_0,\n    VERSION_1,\n)\nfrom steak_protocol.onchain.stakechain import stakechain_v0, stakechain_v1\nfrom steak_protocol.onchain.stakeholder.stakeholder import UpdateStake\nfrom steak_protocol.onchain.types import (\n    StakeChainV0State,\n    StakeChainV1State,\n    CoreChainState,\n    StakeHolderState,\n    ProducerState,\n)\nfrom steak_protocol.onchain.util import scale_fraction\nfrom steak_protocol.utils import get_signing_info, network, context\nfrom steak_protocol.utils.contracts import get_contract, get_ref_utxo\nfrom steak_protocol.utils.network import show_tx\nfrom steak_protocol.utils.to_script_context import (\n    to_tx_out_ref,\n    to_address,\n)\n\n\ndef compute_current_slot(genesis_time: int, slot_length: int) -> int:\n    current_time = int(datetime.datetime.now().timestamp() * 1000)\n    return (current_time - genesis_time) // slot_length\n\n\ndef compute_validity_interval(genesis_time: int, slot_length: int) -> tuple[int, int]:\n    suggested_slot = compute_current_slot(genesis_time, slot_length)\n    min_acceptable_lower_bound = genesis_time + slot_length * suggested_slot\n    max_acceptable_upper_bound = min_acceptable_lower_bound + slot_length\n    return min_acceptable_lower_bound, max_acceptable_upper_bound\n\n\ndef main(\n    name: str = \"admin\",\n    stakechain_auth_nft: str = STAKE_CHAIN_AUTH_NFT,\n    stakepool_id: str = \"3\u756a\",\n    producer_message_hash_hex: Optional[str] = None,\n    # number of seconds of validity for the transaction\n    # closer to 60 -> more likely to hit an invalid slot from stakechain view\n    # closer to 0 -> harder to be included in the cardano chain\n    tx_validity_width: int = 40,\n    # how frequently to retry in case of failure (failure is the default)\n    retry_interval: int = 5,\n    # amount of time to wait before committing hash secrets\n    # lower values may lead to more frequent necessecity to recover the pool\n    # higher values may lead to more frequent missed blocks\n    commit_interval: int = 120,\n    stakechain_version=VERSION_1,\n):\n    while True:\n        try:\n            mine(\n                name=name,\n                stakechain_auth_nft=stakechain_auth_nft,\n                pool_id=stakepool_id,\n                producer_message_hash_hex=producer_message_hash_hex,\n                tx_validity_width=tx_validity_width,\n                commit_interval=commit_interval,\n                stakechain_version=stakechain_version,\n            )\n        except KeyboardInterrupt:\n            break\n        except Exception as e:\n            print(e)\n            print(\"Press Ctrl+C to stop. Trying again in 5 seconds...\")\n        else:\n            print(\"Block mined! Trying again in 5 seconds...\")\n        time.sleep(retry_interval)\n\n\ndef mine(\n    name: str = \"admin\",\n    stakechain_auth_nft: str = STAKE_CHAIN_AUTH_NFT,\n    pool_id: str = \"1\u756a\",\n    producer_message_hash_hex: Optional[str] = None,\n    tx_validity_width: int = 40,\n    commit_interval: int = 120,\n    stakechain_version: ContractVersion = VERSION_0,\n):\n    _, payment_skey, payment_address = get_signing_info(name, network=network)\n\n    stakechain_script, _, stakechain_address = get_contract(\n        \"stakechain_\" + stakechain_version\n    )\n    stakeholder_script, _, stakeholder_address = get_contract(\"stakeholder\")\n    stakechain_auth_nft = token_from_string(stakechain_auth_nft)\n    stakepool_script, stakepool_script_hash, _ = get_contract(\"stakepool\")\n\n    stakechain_utxo = None\n    stakechain_state = None\n    for u in context.utxos(stakechain_address):\n        if amount_of_token_in_value(stakechain_auth_nft, u.output.amount) == 0:\n            continue\n        try:\n            if stakechain_version == VERSION_0:\n                stakechain_state = StakeChainV0State.from_cbor(u.output.datum.cbor)\n            elif stakechain_version == VERSION_1:\n                stakechain_state = StakeChainV1State.from_cbor(u.output.datum.cbor)\n            else:\n                continue\n        except DeserializeException:\n            continue\n        stakechain_utxo = u\n        break\n    assert stakechain_utxo is not None, \"No stake chain state found\"\n\n    stakecoin = stakechain_state.params.stake_coin\n    assert stakechain_state.params.stakeholder_address == to_address(\n        stakeholder_address\n    ), \"Wrong stakeholder address\"\n\n    stakeholder_secretss = all_committed_hash_secrets(pool_id)\n    all_stakeholder_secret_hashes = [\n        [sha2_256(x) for x in stakeholder_secrets]\n        for stakeholder_secrets in stakeholder_secretss\n    ]\n    # prepare stake holder utxo\n    stakeholder_utxo = None\n    stakeholder_state = None\n    steakholder_secrets_match = None\n    for u in context.utxos(stakeholder_address):\n        try:\n            stakeholder_state = StakeHolderState.from_cbor(u.output.datum.cbor)\n            if (\n                stakeholder_state.params.chain_auth_nft == stakechain_auth_nft\n                and stakeholder_state.params.stakechain_id == pool_id.encode()\n            ):\n                for i, stakeholder_secret_hashes in enumerate(\n                    all_stakeholder_secret_hashes\n                ):\n                    if stakeholder_state.committed_hashes == stakeholder_secret_hashes:\n                        steakholder_secrets_match = stakeholder_secretss[i]\n                        break\n            if steakholder_secrets_match is not None:\n                stakeholder_utxo = u\n                break\n        except DeserializeException:\n            continue\n        except AttributeError:\n            continue\n    assert (\n        stakeholder_utxo is not None\n    ), \"No stake holder state found. Correct secrets and pool name?\"\n    stakeholder_secrets = steakholder_secrets_match\n\n    own_index_in_stakeholder_list = (\n        stakechain_state.holder_state.stake_holder_ids.index(\n            stakeholder_state.params.stakechain_id\n        )\n    )\n\n    current_slot_number = compute_current_slot(\n        stakechain_state.params.genesis_time, stakechain_state.params.slot_length\n    )\n    elected_slot_leader = 0  # just assume we are the leader and try to submit\n    new_core_chain_state = CoreChainState(\n        block_number=stakechain_state.chain_state.block_number + 1,\n        block_hash=sha2_256(\n            bytes_big_from_unsigned_int(elected_slot_leader)\n            + stakechain_state.chain_state.to_cbor()\n            + stakechain_state.producer_state.producer_signature\n        ),\n        slot_number=current_slot_number,\n    )\n    slot_leader_sig = custom_sign_message(\n        stakeholder_secrets[0], new_core_chain_state.to_cbor()\n    )\n\n    producer_message = (\n        NoOutputDatum()\n        if producer_message_hash_hex is None\n        else SomeOutputDatumHash(datum_hash=bytes.fromhex(producer_message_hash_hex))\n    )\n    new_stakechain_state_type = (\n        StakeChainV0State if stakechain_version == VERSION_0 else StakeChainV1State\n    )\n    new_stakechain_state = new_stakechain_state_type(\n        params=stakechain_state.params,\n        holder_state=stakechain_state.holder_state,\n        chain_state=new_core_chain_state,\n        producer_state=ProducerState(\n            producer_signature=slot_leader_sig,\n            auxiliary=producer_message,\n            prev_producer_state_hash=sha2_256(\n                stakechain_state.producer_state.to_cbor()\n            ),\n        ),\n        skip_holders=0,\n        spent_for=to_tx_out_ref(stakechain_utxo.input),\n    )\n\n    stakeholder_is_pool = isinstance(stakeholder_state.params.owner, ScriptCredential)\n    if stakeholder_is_pool:\n        pool_state = PoolState.from_cbor(stakeholder_state.aux.datum.to_cbor())\n        guarantee_reward_fraction = pool_state.params.guaranteed_reward_fraction\n\n    payment_utxos = context.utxos(payment_address)\n    all_input_utxos = sorted_utxos(payment_utxos + [stakechain_utxo, stakeholder_utxo])\n    stakeholder_utxo_index = all_input_utxos.index(stakeholder_utxo)\n    stakechain_utxo_index = all_input_utxos.index(stakechain_utxo)\n\n    stakechain_script = get_ref_utxo(stakechain_script, context)\n    stakeholder_script = get_ref_utxo(stakeholder_script, context)\n    all_ref_input_utxos = sorted_utxos(\n        [stakeholder_utxo]\n        + [\n            u\n            for u in [stakechain_script, stakeholder_script, stakepool_script]\n            if isinstance(u, UTxO)\n        ]\n    )\n    stakeholder_ref_utxo_index = all_ref_input_utxos.index(stakeholder_utxo)\n\n    mining_redeemer_type = (\n        stakechain_v0.MineBlockUpdateStake\n        if stakechain_version == VERSION_0\n        else stakechain_v1.MineBlockUpdateStake\n    )\n    mining_redeemer = Redeemer(\n        mining_redeemer_type(\n            old_state_index=stakechain_utxo_index,\n            new_state_index=0,\n            producing_holder_ref_utxo_index=stakeholder_ref_utxo_index,\n            elected_slot_leader=elected_slot_leader,\n            aux=producer_message,\n            slot_leader_secret=stakeholder_secrets[0],\n            slot_leader_sig=slot_leader_sig,\n            old_stake_index=stakeholder_utxo_index,\n            new_stake_index=1,\n            stake_index_in_holder_list=own_index_in_stakeholder_list,\n        )\n    )\n\n    new_stakeholder_state = copy.deepcopy(stakeholder_state)\n    new_stakeholder_secrets = stakeholder_secrets[1:] + [secrets.token_bytes(32)]\n    new_stakeholder_state.committed_hashes = stakeholder_secret_hashes[1:] + [\n        sha2_256(new_stakeholder_secrets[-1])\n    ]\n\n    txbuilder = TransactionBuilder(context)\n    for u in payment_utxos:\n        txbuilder.add_input(u)\n    txbuilder.reference_inputs.add(stakeholder_utxo)\n    txbuilder.add_script_input(\n        stakechain_utxo,\n        stakechain_script,\n        None,\n        mining_redeemer,\n    )\n    txbuilder.add_script_input(\n        stakeholder_utxo,\n        stakeholder_script,\n        None,\n        Redeemer(\n            UpdateStake(\n                own_input_index=stakeholder_utxo_index,\n                chain_input_index=stakechain_utxo_index,\n                own_output_index=1,\n            )\n        ),\n    )\n\n    if stakeholder_is_pool:\n        txbuilder.withdrawals = Withdrawals(\n            {\n                bytes(\n                    Address(\n                        staking_part=stakepool_script_hash,\n                        network=network,\n                    )\n                ): 0\n            }\n        )\n        txbuilder.add_withdrawal_script(\n            stakepool_script,\n            Redeemer(\n                InteractWithPool(\n                    own_input_index=stakeholder_utxo_index,\n                    own_output_index=1,\n                    chain_input_index=stakechain_utxo_index,\n                    chain_output_index=0,\n                )\n            ),\n        )\n\n    # determine new value\n    prev_reserve_amount = amount_of_token_in_value(\n        stakecoin, stakechain_utxo.output.amount\n    )\n    amount_to_be_distributed = floor_fraction(\n        scale_fraction(prev_reserve_amount, stakechain_state.params.fraction_per_block)\n    )\n    desired_new_value = stakechain_utxo.output.amount.multi_asset - asset_from_token(\n        stakecoin, amount_to_be_distributed\n    )\n    if stakeholder_is_pool:\n        amount_to_pool = ceil_fraction(\n            scale_fraction(amount_to_be_distributed, guarantee_reward_fraction)\n        )\n    else:\n        amount_to_pool = amount_to_be_distributed\n\n    # update holder weight in case of pool\n    new_stakechain_state.holder_state.stake_holder_weights[\n        own_index_in_stakeholder_list\n    ] += amount_to_pool\n\n    txbuilder.add_output(\n        TransactionOutput(\n            stakechain_address,\n            amount=Value(\n                coin=stakechain_utxo.output.amount.coin, multi_asset=desired_new_value\n            ),\n            datum=new_stakechain_state,\n        )\n    )\n    txbuilder.add_output(\n        with_min_lovelace(\n            TransactionOutput(\n                stakeholder_address,\n                amount=Value(\n                    multi_asset=stakeholder_utxo.output.amount.multi_asset\n                    + asset_from_token(stakecoin, amount_to_pool),\n                ),\n                datum=new_stakeholder_state,\n            ),\n            context,\n        )\n    )\n    txbuilder.validity_start = context.last_block_slot + 1\n    txbuilder.ttl = txbuilder.validity_start + tx_validity_width\n    txbuilder.auxiliary_data = pycardano.AuxiliaryData(\n        data=pycardano.AlonzoMetadata(\n            metadata=pycardano.Metadata(\n                {\n                    674: {\"msg\": [\"Mine Block\"]},\n                }\n            )\n        )\n    )\n    txbuilder.collaterals = sorted(\n        payment_utxos, key=lambda x: x.output.amount.coin, reverse=True\n    )[:3]\n    tx = txbuilder.build_and_sign(\n        signing_keys=[payment_skey],\n        change_address=payment_address,\n    )\n\n    # MODIFY THESE STEPS AT YOUR OWN RISK, may lead to need to recover the pool secrets\n    write_ahead_hash_secrets(pool_id, new_stakeholder_secrets)\n    context.submit_tx(tx)\n    show_tx(tx)\n    print(\"Checking if tx made it to the chain... DO NOT ABORT\")\n    time.sleep(commit_interval)\n    assert (\n        context.utxo_by_tx_id(tx.id.payload.hex(), 0) is not None\n    ), \"Transaction not found, aborting\"\n    # END OF DANGER ZONE\n    commit_hash_secrets(pool_id, new_stakeholder_secrets)\n    return tx, new_stakechain_state\n\n\nif __name__ == \"__main__\":\n    fire.Fire(main)\n", "output": "This Cardano smart contract code is part of a larger system called the STEAKProtocol, specifically focusing on the \"stakechain\" mining process. The code is written in Python and utilizes several libraries, including `pycardano` for Cardano blockchain interactions and `opshin` for smart contract operations. Let's break down the code in detail:\n\n### Imports\n\n- **Standard Libraries**: \n  - `copy`, `datetime`, `secrets`, `time` for various utility functions.\n  - `Optional` from `typing` for type hinting.\n\n- **Third-Party Libraries**:\n  - `fire`: A library for creating CLIs.\n  - `pycardano`: A library for interacting with the Cardano blockchain.\n  - `opshin`: A library for working with Cardano smart contracts.\n\n- **STEAKProtocol Specific Imports**:\n  - Various modules from `steak_protocol` for interacting with on-chain and off-chain components of the protocol.\n\n### Key Functions\n\n#### `compute_current_slot`\n\nThis function calculates the current slot number based on the genesis time and slot length. It uses the current timestamp to determine how many slots have passed since the genesis time.\n\n#### `compute_validity_interval`\n\nThis function calculates a validity interval for a transaction, providing a range of acceptable slots for the transaction to be considered valid.\n\n### Main Functionality\n\n#### `main`\n\nThis is the entry point of the script when executed. It continuously attempts to mine a block by calling the `mine` function. If an exception occurs, it waits for a specified retry interval before trying again. The function can be interrupted with a keyboard interrupt (Ctrl+C).\n\n#### `mine`\n\nThis function performs the actual mining process. Here's a breakdown of its steps:\n\n1. **Setup and Initialization**:\n   - Retrieves signing information and contract details.\n   - Identifies the UTXOs (Unspent Transaction Outputs) associated with the stakechain and stakeholder addresses.\n\n2. **State Verification**:\n   - Verifies the state of the stakechain and stakeholder by deserializing the datum from the UTXOs.\n   - Ensures the correct stakeholder address and secrets are used.\n\n3. **Slot and Leader Election**:\n   - Computes the current slot number and assumes the current node is the slot leader.\n   - Constructs a new core chain state with an incremented block number and a new block hash.\n\n4. **Transaction Construction**:\n   - Prepares a new stakechain state and stakeholder state.\n   - Constructs a transaction using `TransactionBuilder`, adding inputs, outputs, and script inputs.\n   - Handles withdrawals if the stakeholder is a pool.\n\n5. **Value Distribution**:\n   - Calculates the amount to be distributed and updates the holder weights if the stakeholder is a pool.\n\n6. **Transaction Signing and Submission**:\n   - Signs the transaction with the payment signing key.\n   - Submits the transaction to the Cardano network and verifies its inclusion in the blockchain.\n\n7. **Secret Management**:\n   - Manages the secrets used for signing and ensures they are committed after the transaction is confirmed.\n\n### Key Concepts\n\n- **Stakechain and Stakeholder**: These are components of the STEAKProtocol, representing the chain of stakes and individual stakeholders, respectively.\n- **UTXO Model**: The code heavily relies on the UTXO model, which is fundamental to Cardano's blockchain.\n- **Smart Contracts**: The code interacts with smart contracts deployed on the Cardano blockchain, using scripts and datums to manage state transitions.\n- **Transaction Building**: The `TransactionBuilder` is used to construct and sign transactions, a critical part of interacting with the blockchain.\n\n### Conclusion\n\nThis code is a sophisticated implementation of a mining process within the STEAKProtocol, leveraging Cardano's blockchain features. It involves complex interactions with smart contracts, state management, and transaction handling, all orchestrated to maintain the protocol's stakechain. The use of Python and libraries like `pycardano` and `opshin` facilitates these operations, providing a high-level interface to the underlying blockchain mechanics.", "file_path": "STEAKProtocol/steak_protocol/offchain/stakechain/mine.py", "file": "mine.py"}
{"instruction": "Explain the following smart contract code:", "input": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE OverloadedRecordDot #-}\n{-# LANGUAGE PolyKinds #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}\n{-# OPTIONS_GHC -Wno-missing-import-lists #-}\n\nmodule LiquidityEvent.LiquidityTokenHolder where\n\nimport GHC.Stack (HasCallStack)\nimport Plutarch (Config (Config), TracingMode (DoTracing))\nimport Plutarch.Api.V1 (PCredential (..))\nimport Plutarch.Api.V1.Value (padaToken, padaSymbol, plovelaceValueOf, pnoAdaValue, pnormalize, pvalueOf, pforgetPositive)\nimport Plutarch.Api.V1.Value qualified as Value \nimport Plutarch.Api.V2 (\n  AmountGuarantees (Positive),\n  KeyGuarantees (Sorted),\n  PAddress (..),\n  PCurrencySymbol,\n  PMintingPolicy,\n  POutputDatum (POutputDatum),\n  PPOSIXTime (..),\n  PPubKeyHash,\n  PScriptContext,\n  PScriptHash,\n  PScriptPurpose (PMinting, PSpending),\n  PTokenName (..),\n  PTxInInfo (..),\n  PTxInfo (..),\n  PTxOut,\n  PTxOutRef,\n  PValidator,\n  PValue (..),\n )\nimport Plutarch.Bool (pand')\nimport Plutarch.DataRepr (\n  DerivePConstantViaData (..),\n  PDataFields,\n )\nimport Plutarch.Extra.Interval (pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum, ptryFromInlineDatum)\nimport \"liqwid-plutarch-extra\" Plutarch.Extra.TermCont (\n  pletC,\n  pletFieldsC,\n  pmatchC,\n  ptraceC,\n  ptryFromC,\n )\nimport Plutarch.Lift (PConstantDecl, PUnsafeLiftDecl (..))\nimport Plutarch.List (pfoldl')\nimport Plutarch.Num ((#+))\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce, punsafeDowncast)\nimport PlutusLedgerApi.V2\nimport PlutusTx qualified\nimport Types.Constants (projectTokenHolderTN, rewardFoldTN, commitFoldTN)\nimport PriceDiscoveryEvent.Utils (\n  pand'List,\n  pcond,\n  pelemAt',\n  phasInput,\n  pheadSingleton,\n  ptryLookupValue,\n  pfindCurrencySymbolsByTokenName,\n  ptryOwnInput, pmustFind, ptryOwnOutput, (#>)\n )\nimport Types.LiquiditySet ( PLiquiditySetNode, PLiquidityHolderDatum(..), PProxyTokenHolderDatum(..) )\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PLiquidityFoldDatum)\nimport Plutarch.Builtin (pforgetData)\nimport qualified Plutarch.Monadic as P\nimport qualified Plutarch.Api.V1 as V1\nimport Plutarch.Api.V2.Tx (POutputDatum(POutputDatumHash))\n\npmustFindDatum ::\n  Term s (V1.PDatumHash :--> V1.PMap 'V1.Unsorted V1.PDatumHash V1.PDatum :--> PData)\npmustFindDatum =\n  phoistAcyclic $ plam $ \\datumHash datums ->\n    (pfix #$ plam $ \\self datumList ->\n      (pelimList\n        ( \\datumTuple datumTuples ->\n            pif\n              (datumHash #== (pfromData (pfstBuiltin # datumTuple)))\n              (pforgetData $ psndBuiltin # datumTuple) \n              (self # datumTuples)\n        )\n        perror\n        datumList)\n    ) \n    # (pto datums) \n\ndata PLiquidityHolderMintAct (s :: S)\n  = PMintHolder (Term s (PDataRecord '[]))\n  | PBurnHolder (Term s (PDataRecord '[]))\n  deriving stock (Generic)\n  deriving anyclass (PlutusType, PIsData)\n\ninstance DerivePlutusType PLiquidityHolderMintAct where\n  type DPTStrat _ = PlutusTypeData\n\ninstance PTryFrom PData PLiquidityHolderMintAct \n\ninstance PTryFrom PData (PAsData PLiquidityHolderMintAct)\n\npmintLiquidityTokenHolder :: Term s (PTxOutRef :--> PMintingPolicy)\npmintLiquidityTokenHolder = phoistAcyclic $ \n  plam $ \\oref redm ctx ->\n    let red = punsafeCoerce @_ @_ @PLiquidityHolderMintAct redm \n     in pmatch red $ \\case \n          PMintHolder _ -> popaque $ pmintTokenHolder # oref # ctx \n          PBurnHolder _ -> popaque $ pburnTokenHolder # ctx \n\npburnTokenHolder :: Term s (PScriptContext :--> PUnit)\npburnTokenHolder = phoistAcyclic $ \n  plam $ \\ctx -> unTermCont $ do\n    contextFields <- pletFieldsC @'[\"txInfo\", \"purpose\"] ctx\n    PMinting policy <- pmatchC contextFields.purpose\n    ownPolicyId <- pletC $ pfield @\"_0\" # policy\n\n    info <- pletFieldsC @'[\"mint\"] contextFields.txInfo\n    tkPairs <- pletC $ ptryLookupValue # ownPolicyId # info.mint\n    tkPair <- pletC (pheadSingleton # tkPairs)\n    let numMinted = psndBuiltin # tkPair \n    pure $\n      pif ( pfromData numMinted #== -1 ) (pconstant ()) perror \n\npmintTokenHolder :: Term s (PTxOutRef :--> PScriptContext :--> PUnit)\npmintTokenHolder = phoistAcyclic $ \n  plam $ \\oref ctx -> unTermCont $ do\n    contextFields <- pletFieldsC @'[\"txInfo\", \"purpose\"] ctx\n    PMinting policy <- pmatchC contextFields.purpose\n    ownPolicyId <- pletC $ pfield @\"_0\" # policy\n\n    info <- pletFieldsC @'[\"inputs\", \"outputs\", \"mint\"] contextFields.txInfo\n    tkPairs <- pletC $ ptryLookupValue # ownPolicyId # (pnormalize # info.mint)\n    tkPair <- pletC (pheadSingleton # tkPairs)\n\n    let holderOutput = pmustFind @PBuiltinList # plam(\\out -> 1 #<= pvalueOf # (pfield @\"value\" # out) # pfromData ownPolicyId # projectTokenHolderTN) # info.outputs \n    POutputDatum ((pfield @\"outputDatum\" #) -> holderOutputDatum) <- pmatchC (pfield @\"datum\" # holderOutput)\n\n    let numMinted = psndBuiltin # tkPair \n        tkMinted = pfstBuiltin # tkPair \n        expectedDatum = pforgetData $ pdata $ pcon $ PLiquidityHolderDatum $ pdcons @\"lpTokenName\" # (pconstantData \"\") #$ pdcons @\"totalCommitted\" # pconstantData 0 #$ pdcons @\"totalLPTokens\" # pconstantData 0 # pdnil \n        mintChecks = \n          pand'List\n            [ pfromData numMinted #== 1\n            , projectTokenHolderTN #== pfromData tkMinted\n            , phasInput # info.inputs # oref \n            , expectedDatum #== pfromData (pto holderOutputDatum)\n            ] \n    pure $\n      pif ( mintChecks ) (pconstant ()) perror \n\ndata PLiquidityHolderAct (s :: S)\n  = PAddCollected (Term s (PDataRecord '[]))\n  | PForwardToV1 (Term s (PDataRecord '[]))\n  | PBeginRewards (Term s (PDataRecord '[]))\n  deriving stock (Generic)\n  deriving anyclass (PlutusType, PIsData)\n\ninstance DerivePlutusType PLiquidityHolderAct where\n  type DPTStrat _ = PlutusTypeData\n\nproxyTokenHolderAddress :: Term _ PAddress\nproxyTokenHolderAddress = pfromData $ pconstantData (Address (ScriptCredential \"a5b38cc78899b452d48205198a5e457b6f92f50866f4abff82bab11a\") Nothing)\n\npliquidityTokenHolder :: Term s (PAsData PAddress :--> PAsData PCurrencySymbol :--> PAsData PCurrencySymbol :--> PData :--> PData :--> PScriptContext :--> POpaque)\npliquidityTokenHolder = phoistAcyclic $ plam $ \\proxyTokenHolderAddress rewardsCS commitCS datum redeemer ctx ->\n  let red = punsafeCoerce @_ @_ @PLiquidityHolderAct redeemer \n      dat = punsafeCoerce @_ @_ @PLiquidityHolderDatum datum \n   in pmatch red $ \\case \n        PAddCollected _ -> paddCollected # pfromData (pfield @\"totalCommitted\" # dat) # commitCS # ctx \n        PForwardToV1 _ -> pforwardToProxy # pfromData proxyTokenHolderAddress # dat # ctx \n        PBeginRewards _ -> pbeginRewards # rewardsCS # ctx\n\npforwardToProxy :: Term s (PAddress :--> PLiquidityHolderDatum :--> PScriptContext :--> POpaque)\npforwardToProxy = phoistAcyclic $ plam $ \\proxyTokenHolderAddress ownDatum ctx -> P.do \n  ctxF <- pletFields @'[\"txInfo\", \"purpose\"] ctx \n  infoF <- pletFields @'[\"inputs\", \"outputs\", \"datums\"] ctxF.txInfo\n  PSpending ((pfield @\"_0\" #) -> ownRef) <- pmatch ctxF.purpose\n  let ownInput = ptryOwnInput # infoF.inputs # ownRef\n  ownInputF <- pletFields @'[\"address\", \"value\"] ownInput\n\n  ownDatF <- pletFields @'[\"totalCommitted\", \"totalLPTokens\", \"lpTokenName\"] ownDatum\n  let proxyOutput = \n        ( pmustFind @PBuiltinList\n            # plam (\\out -> pfield @\"address\" # out #== proxyTokenHolderAddress)\n            # infoF.outputs \n        )\n  proxyOutputF <- pletFields @[\"value\", \"datum\"] proxyOutput\n  (POutputDatumHash ((pfield @\"datumHash\" #) -> datumHash)) <- pmatch proxyOutputF.datum \n  let proxyDatum =  punsafeCoerce @_ @_ @PProxyTokenHolderDatum $ pmustFindDatum # datumHash # infoF.datums\n  proxyDatumF <- pletFields @[\"totalCommitted\", \"returnAddress\"] proxyDatum\n  let forwardToProxyChecks = \n          pand'List\n            [ ptraceIfFalse \"cgz\" $ pfromData ownDatF.totalCommitted #> pconstant 0\n            , ptraceIfFalse \"retAddr\" $ proxyDatumF.returnAddress #== ownInputF.address\n            , ptraceIfFalse \"totCom\" $ proxyDatumF.totalCommitted #== ownDatF.totalCommitted\n            , ptraceIfFalse \"totLP\" $ pfromData ownDatF.totalLPTokens #== pconstant 0\n            , ptraceIfFalse \"tn\" $ pfromData ownDatF.lpTokenName #== pconstant \"\"\n            , ptraceIfFalse \"val\" $ proxyOutputF.value #== ownInputF.value \n            ] \n  pif forwardToProxyChecks (popaque $ pconstant ()) perror \n\npbeginRewards :: Term s (PAsData PCurrencySymbol :--> PScriptContext :--> POpaque)\npbeginRewards = phoistAcyclic $ plam $ \\rewardsCS ctx -> unTermCont $ do \n  ctxF <- pletFieldsC @'[\"txInfo\", \"purpose\"] ctx \n  infoF <- pletFieldsC @'[\"inputs\", \"mint\"] ctxF.txInfo\n\n  PSpending ((pfield @\"_0\" #) -> ownRef) <- pmatchC ctxF.purpose\n  let ownInput = ptryOwnInput # infoF.inputs # ownRef\n  ownInputF <- pletFieldsC @'[\"value\"] ownInput\n  \n  mintedValue <- pletC (pnormalize # infoF.mint) \n  let possibleCSs = pfindCurrencySymbolsByTokenName # ownInputF.value # projectTokenHolderTN \n      pthCS = pheadSingleton # possibleCSs\n      tkhPairs = ptryLookupValue # pthCS # mintedValue\n      tkhPair = (pheadSingleton # tkhPairs)\n      thkMinted = psndBuiltin # tkhPair \n\n  let rewardPair = pheadSingleton #$ ptryLookupValue # rewardsCS # mintedValue\n      rewardTkMinted = psndBuiltin # rewardPair \n  \n  pure $\n    pif ( pfromData rewardTkMinted #== 1 #&& pfromData thkMinted #== -1) (popaque $ pconstant ()) perror \n\npaddCollected :: Term s (PInteger :--> PAsData PCurrencySymbol :--> PScriptContext :--> POpaque)\npaddCollected = phoistAcyclic $ plam $ \\ownInputTotalCommitted commitCS ctx -> unTermCont $ do \n  ctxF <- pletFieldsC @'[\"txInfo\", \"purpose\"] ctx \n  infoF <- pletFieldsC @'[\"inputs\", \"outputs\", \"mint\"] ctxF.txInfo\n  mintedValue <- pletC (pnormalize # infoF.mint) \n  PSpending ((pfield @\"_0\" #) -> ownRef) <- pmatchC ctxF.purpose\n  txInputs <- pletC infoF.inputs\n  let ownInput = ptryOwnInput # txInputs # ownRef\n  ownInputF <- pletFieldsC @'[\"value\", \"address\"] ownInput\n  PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatchC (pfield @\"credential\" # ownInputF.address)\n\n  let commitInp = \n        pfield @\"resolved\" #\n          ( pmustFind @PBuiltinList\n              # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # pfromData commitCS # commitFoldTN #== 1)\n              # txInputs \n          )\n  commitInputF <- pletFieldsC @'[\"value\", \"datum\"] commitInp \n  let commitDatum = punsafeCoerce @_ @_ @PLiquidityFoldDatum $ (ptryFromInlineDatum # commitInputF.datum) \n  commitDatF <- pletFieldsC @'[\"currNode\", \"committed\"] commitDatum\n  \n  let ownOutput = ptryOwnOutput # infoF.outputs # ownValHash\n  ownOutputF <- pletFieldsC @'[\"value\", \"datum\"] ownOutput  \n  \n  (POutputDatum ownOutDatum) <- pmatchC ownOutputF.datum\n  ownOutDatF <- pletFieldsC @'[\"totalCommitted\", \"totalLPTokens\", \"lpTokenName\"] (pfromPDatum @PLiquidityHolderDatum # (pfield @\"outputDatum\" # ownOutDatum))\n  let commitTkPair = (pheadSingleton #$ ptryLookupValue # commitCS # mintedValue)\n      commitTkBurned = (pfromData $ psndBuiltin # commitTkPair) #== -1\n      collectedAda = Value.psingleton # padaSymbol # padaToken # commitDatF.committed\n      addCollectedChecks = \n          pand'List\n            [ ptraceIfFalse \"acburn\" commitTkBurned \n            , ptraceIfFalse \"acvalue\" $ pforgetPositive ownOutputF.value #== (pforgetPositive ownInputF.value <> collectedAda)\n            , ptraceIfFalse \"actotcom\" $ pfromData ownOutDatF.totalCommitted #== pfromData commitDatF.committed\n            , ptraceIfFalse \"actotlp\" $ pfromData ownOutDatF.totalLPTokens #== 0 \n            , ptraceIfFalse \"aclpName\" $ pfromData ownOutDatF.lpTokenName #== pconstant \"\"\n            , ptraceIfFalse \"ac\" $ ownInputTotalCommitted #== 0\n            ] \n  pure $\n    pif addCollectedChecks (popaque $ pconstant ()) perror ", "output": "The provided Haskell code is a Cardano smart contract written using the Plutarch library, which is a domain-specific language (DSL) for writing Plutus smart contracts. This contract is part of a module named `LiquidityEvent.LiquidityTokenHolder` and is designed to handle operations related to liquidity token holders in a decentralized finance (DeFi) context. Let's break down the code and its components:\n\n### Language Extensions and Options\n\n- **Language Extensions**: The code uses several GHC language extensions such as `AllowAmbiguousTypes`, `OverloadedRecordDot`, `PolyKinds`, `ScopedTypeVariables`, `TemplateHaskell`, and `UndecidableInstances`. These extensions enable advanced type system features and syntactic conveniences.\n- **GHC Options**: The code suppresses warnings for incomplete pattern matches and missing import lists.\n\n### Module and Imports\n\n- **Module Declaration**: The module is named `LiquidityEvent.LiquidityTokenHolder`.\n- **Imports**: The code imports various modules from Plutarch, Plutus, and other libraries. These imports provide necessary types and functions for working with Plutus smart contracts, such as transaction contexts, minting policies, and value manipulations.\n\n### Key Data Types and Functions\n\n1. **`pmustFindDatum` Function**:\n   - This function retrieves a datum from a map of datums using a given datum hash. It iterates over the list of datum tuples and returns the corresponding datum if the hash matches.\n\n2. **`PLiquidityHolderMintAct` Data Type**:\n   - This is a custom data type representing actions related to minting or burning liquidity holder tokens. It has two constructors: `PMintHolder` and `PBurnHolder`.\n\n3. **`pmintLiquidityTokenHolder` Function**:\n   - This function defines a minting policy for liquidity token holders. It checks the redeemer to determine whether to mint or burn tokens and calls the appropriate function (`pmintTokenHolder` or `pburnTokenHolder`).\n\n4. **`pburnTokenHolder` Function**:\n   - This function handles the burning of liquidity holder tokens. It checks that exactly one token is burned by verifying the minting value in the transaction context.\n\n5. **`pmintTokenHolder` Function**:\n   - This function handles the minting of liquidity holder tokens. It performs several checks, such as ensuring the correct number of tokens are minted, verifying the presence of an input reference, and checking the expected datum.\n\n6. **`PLiquidityHolderAct` Data Type**:\n   - This data type represents actions that can be performed by a liquidity holder, such as adding collected funds, forwarding to a proxy, or beginning rewards.\n\n7. **`pliquidityTokenHolder` Function**:\n   - This function is the main validator for liquidity token holders. It matches the redeemer to determine the action to perform and calls the corresponding function (`paddCollected`, `pforwardToProxy`, or `pbeginRewards`).\n\n8. **`pforwardToProxy` Function**:\n   - This function handles forwarding liquidity to a proxy address. It checks various conditions to ensure the transaction is valid, such as verifying the total committed amount and the return address.\n\n9. **`pbeginRewards` Function**:\n   - This function initiates the rewards process. It checks that the correct tokens are minted and burned as part of the transaction.\n\n10. **`paddCollected` Function**:\n    - This function adds collected funds to the liquidity holder. It verifies that the correct amount of tokens is burned and that the output value matches the expected value after adding collected ADA.\n\n### Summary\n\nThe code defines a smart contract for managing liquidity token holders in a DeFi application on the Cardano blockchain. It includes minting and burning policies, as well as actions for managing liquidity, forwarding to proxies, and beginning rewards. The contract uses Plutarch to define these operations in a type-safe and composable manner, leveraging the Plutus platform's capabilities for secure and efficient smart contract execution.", "file_path": "iscovery/src/LiquidityEvent/LiquidityTokenHolder.hs", "file": "LiquidityTokenHolder.hs"}
{"instruction": "Explain the following smart contract code:", "input": "-- SPDX-License-Identifier: BUSL-1.1\n\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Indigo.Contracts.Liquidity.OnChain\n  ( validateLiquidity,\n    liquidityValidator,\n    liquidityAddress,\n    liquidityScriptCTL,\n    untypedLiquidityValidatorHash,\n  )\nwhere\n\nimport Indigo.Contracts.Liquidity.Common\nimport Indigo.Utils.Helpers qualified as Helpers\nimport Indigo.Utils.Spooky qualified as Spooky\nimport Ledger qualified\nimport Plutus.Script.Utils.V2.Address qualified as Address\nimport Plutus.Script.Utils.V2.Scripts qualified as Scripts\nimport Plutus.Script.Utils.V2.Typed.Scripts.Validators (UntypedValidator)\nimport Plutus.V2.Ledger.Api qualified as V2\nimport PlutusTx qualified\nimport PlutusTx.Prelude hiding (divide)\n\n{-# INLINEABLE validateLiquidity #-}\nvalidateLiquidity :: LiquidityDatum -> () -> Spooky.ScriptContext -> Bool\nvalidateLiquidity LiquidityPosition {owner} _ ctx =\n  traceIfFalse \"Must be signed by owner\" (Spooky.txSignedBy info owner)\n  where\n    info :: Spooky.TxInfo\n    info = Spooky.scriptContextTxInfo ctx\n\nliquidityValidator :: V2.Validator\nliquidityValidator =\n  V2.mkValidatorScript compiledUntypedValidateLiquidity\n\ncompiledUntypedValidateLiquidity :: PlutusTx.CompiledCode UntypedValidator\ncompiledUntypedValidateLiquidity =\n  Helpers.optimizeUPLC $$(PlutusTx.compile [||wrap||])\n  where\n    wrap = Spooky.mkUntypedValidator validateLiquidity\n\nuntypedLiquidityValidator :: V2.Validator\nuntypedLiquidityValidator =\n  V2.mkValidatorScript compiledUntypedValidateLiquidity\n\nuntypedLiquidityValidatorHash :: V2.ValidatorHash\nuntypedLiquidityValidatorHash = Scripts.validatorHash untypedLiquidityValidator\n\n-- serialised for ue in CTL\nliquidityScriptCTL :: V2.Script\nliquidityScriptCTL = V2.fromCompiledCode compiledUntypedValidateLiquidity\n\nliquidityAddress :: Ledger.Address\nliquidityAddress = Address.mkValidatorAddress liquidityValidator\n", "output": "This Cardano smart contract code is written in Haskell and is part of the Indigo project, specifically dealing with liquidity management. Let's break down the code and understand its components and functionality:\n\n### Module and Imports\n\n- **Module Declaration**: The module is named `Indigo.Contracts.Liquidity.OnChain`. It exports several functions and values related to liquidity validation and addresses.\n  \n- **Imports**: The code imports various modules, including:\n  - `Indigo.Contracts.Liquidity.Common`: Presumably contains common definitions related to liquidity.\n  - `Indigo.Utils.Helpers` and `Indigo.Utils.Spooky`: These are likely utility modules for helper functions and handling specific data types or operations.\n  - `Ledger`, `Plutus.Script.Utils.V2.Address`, `Plutus.Script.Utils.V2.Scripts`, and `Plutus.V2.Ledger.Api`: These are part of the Plutus framework, providing tools for working with addresses, scripts, and the ledger API.\n  - `PlutusTx` and `PlutusTx.Prelude`: Used for compiling Plutus scripts and providing Prelude functions tailored for Plutus.\n\n### Key Components\n\n1. **`validateLiquidity` Function**:\n   - **Type Signature**: `validateLiquidity :: LiquidityDatum -> () -> Spooky.ScriptContext -> Bool`\n   - **Purpose**: This function validates a liquidity position by ensuring that the transaction is signed by the owner of the liquidity position.\n   - **Parameters**:\n     - `LiquidityDatum`: Contains data about the liquidity position, including the `owner`.\n     - `()`: A placeholder for additional data, not used here.\n     - `Spooky.ScriptContext`: Provides context about the transaction being validated.\n   - **Logic**: \n     - Extracts the transaction information from the context.\n     - Checks if the transaction is signed by the owner using `Spooky.txSignedBy`.\n     - Uses `traceIfFalse` to provide a debug message if the condition fails.\n\n2. **`liquidityValidator`**:\n   - **Type**: `V2.Validator`\n   - **Purpose**: Creates a Plutus validator script from the compiled untyped validator code.\n   - **Implementation**: Uses `V2.mkValidatorScript` with `compiledUntypedValidateLiquidity`.\n\n3. **`compiledUntypedValidateLiquidity`**:\n   - **Type**: `PlutusTx.CompiledCode UntypedValidator`\n   - **Purpose**: Holds the compiled code for the untyped validator.\n   - **Implementation**: \n     - Uses Template Haskell (`$$(PlutusTx.compile [||wrap||])`) to compile the `wrap` function.\n     - `wrap` is defined using `Spooky.mkUntypedValidator` to convert `validateLiquidity` into an untyped validator.\n\n4. **`untypedLiquidityValidator` and `untypedLiquidityValidatorHash`**:\n   - **`untypedLiquidityValidator`**: Another instance of the validator script, similar to `liquidityValidator`.\n   - **`untypedLiquidityValidatorHash`**: Computes the hash of the untyped validator, which is useful for referencing the validator in transactions.\n\n5. **`liquidityScriptCTL`**:\n   - **Type**: `V2.Script`\n   - **Purpose**: Provides a serialized version of the compiled validator script for use in CTL (Contract Template Language).\n\n6. **`liquidityAddress`**:\n   - **Type**: `Ledger.Address`\n   - **Purpose**: Generates the on-chain address for the liquidity validator, allowing it to be referenced in transactions.\n   - **Implementation**: Uses `Address.mkValidatorAddress` with `liquidityValidator`.\n\n### Summary\n\nThis code defines a smart contract for validating liquidity positions on the Cardano blockchain. The core functionality ensures that any transaction involving a liquidity position must be signed by its owner. The contract is compiled into a Plutus script, which can be deployed and interacted with on the blockchain. The module provides various utilities for working with the validator, including its address and hash, which are essential for integrating the contract into larger systems.", "file_path": "indigo-smart-contracts/src/Indigo/Contracts/Liquidity/OnChain.hs", "file": "OnChain.hs"}
{"instruction": "Explain the following smart contract code:", "input": "{-# LANGUAGE DisambiguateRecordFields #-}\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE ViewPatterns #-}\n\nmodule Spec.StabilityPool.Test (tests) where\n\nimport Control.Arrow (Arrow (second))\nimport Control.Lens (Bifunctor (bimap), over)\nimport Control.Monad.State.Strict (State, execState, get, put)\nimport Data.Map qualified as Map\nimport Indigo.Contracts.StabilityPool.Common\n  ( adjustAccountHelper,\n    liquidateHelper,\n  )\nimport Indigo.Contracts.StabilityPool.Common hiding\n  ( StabilityPoolScript,\n    adjustAccountHelper,\n    epochToScaleToSum,\n    liquidateHelper,\n  )\nimport Indigo.Data.Decimal\n  ( OnChainDecimal (OnChainDecimal, getOnChainInt),\n    decimalUnit,\n  )\nimport Options (SuiteOptions, setupTestBenchmarkSuite)\nimport PlutusTx.Prelude\nimport Test.Tasty\nimport Test.Tasty.HUnit\nimport Prelude qualified as P\n\nepsilon :: Integer\nepsilon = 6\n\ncompareWithEps ::\n  (HasCallStack, P.Integral a, Ord a, P.Show a) => a -> a -> Assertion\ncompareWithEps actual expected =\n  if P.toInteger (actual P.- expected) <= epsilon\n    then P.pure ()\n    else\n      P.error\n        ( \"\\nExpected: \"\n            <> P.show expected\n            <> \"\\nActual: \"\n            <> P.show actual\n        )\n\ntype UserUid = Integer\n\ndata SPState = SPState\n  { sPoolSnapshot :: StabilityPoolSnapshot,\n    epochToScaleToSum :: EpochToScaleToSum,\n    accountsSnapshotsWithRewards ::\n      Map.Map UserUid (StabilityPoolSnapshot, Integer)\n  }\n  deriving (P.Show)\n\ntests :: SuiteOptions -> TestTree\ntests suiteOpts =\n  testGroup\n    \"Stability pool snapshot tests\"\n    ( setupTestBenchmarkSuite\n        suiteOpts\n        [ testCase \"Example scenario from readme\" exampleReadmeScenario,\n          testCase\n            \"Depositors with equal initial deposit withdraw correct compounded\\\n            \\ deposit and ADA Gain after one liquidation\"\n            t2,\n          testCase\n            \"Depositors with equal initial deposit withdraw correct compounded\\\n            \\ deposit and ADA Gain after two identical liquidations\"\n            t3,\n          testCase\n            \"Depositors with equal initial deposit withdraw correct compounded\\\n            \\ deposit and ADA Gain after three identical liquidations\"\n            t4,\n          testCase\n            \"Depositors with equal initial deposit withdraw correct compounded\\\n            \\ deposit and ADA Gain after two liquidations of increasing iAsset\"\n            t5,\n          testCase\n            \"Depositors with equal initial deposit withdraw correct compounded\\\n            \\ deposit and ADA Gain after three liquidations\\\n            \\ of increasing iAsset\"\n            t6,\n          testCase\n            \"Depositors with varying deposits withdraw correct compounded\\\n            \\ deposit and ADA Gain after two identical liquidations\"\n            t7,\n          testCase\n            \"Depositors with varying deposits withdraw correct compounded\\\n            \\ deposit and ADA Gain after three identical liquidations\"\n            t8,\n          testCase\n            \"Depositors with varying deposits withdraw correct compounded\\\n            \\ deposit and ADA Gain after three varying liquidations\"\n            t9,\n          testCase\n            \"A, B, C Deposit -> 2 liquidations -> D deposits -> 1 liquidation.\\\n            \\ All deposits and liquidations = 100 iAsset.  A, B, C, D withdraw\\\n            \\ correct iAsset deposit and ADA Gain\"\n            t10,\n          testCase\n            \"Pool-emptying liquidation increases epoch by one, resets\\\n            \\ scaleFactor to 0, and resets P to 1e18\"\n            t11,\n          testCase \"Deposit spans one scale factor change\" t12,\n          testCase\n            \"Several deposits of varying amounts span one scale factor change\"\n            t13,\n          testCase\n            \"Several deposits of 10000 iAsset span 2 scale factor change\"\n            t14,\n          testCase\n            \"Depositors withdraw correct compounded deposit after\\\n            \\ liquidation empties the pool\"\n            t15,\n          testCase\n            \"Small liquidated coll/debt, large deposits and ADA price\"\n            t16,\n          testCase \"Checking rewards over multiple scales\" t17,\n          testCase\n            \"Deposit decreases below 1e9th of the initial deposit,\\\n            \\deposit becomes 0\"\n            t18,\n          testCase \"New test case\" tNewCase\n        ]\n        []\n    )\n\ninitState :: SPState\ninitState =\n  SPState\n    { sPoolSnapshot = initSPSnapshot,\n      epochToScaleToSum = initEpochToScaleToSumMap,\n      accountsSnapshotsWithRewards = Map.empty\n    }\n\nliquidate :: Integer -> Integer -> State SPState ()\nliquidate burn reward = do\n  st@SPState {sPoolSnapshot, epochToScaleToSum} <- get\n  let (newSPSnapshot, newEpochToScaleToSum) = liquidateHelper sPoolSnapshot epochToScaleToSum burn reward\n  put (st {sPoolSnapshot = newSPSnapshot, epochToScaleToSum = newEpochToScaleToSum})\n\naccountAdjust :: HasCallStack => (Integer, OnChainDecimal) -> State SPState ()\naccountAdjust (userId, toSPInteger . getOnChainInt -> depositAdjustment) = do\n  st@SPState {sPoolSnapshot, epochToScaleToSum, accountsSnapshotsWithRewards} <- get\n  put\n    st\n      { sPoolSnapshot =\n          sPoolSnapshot\n            { snapshotD = spTruncate (snapshotD sPoolSnapshot |+| depositAdjustment)\n            },\n        accountsSnapshotsWithRewards =\n          Map.insertWith\n            ( \\_ (snap, reward) ->\n                bimap\n                  (over snapshotDLens (|+| depositAdjustment))\n                  (\\(Just a) -> a + reward)\n                  (adjustAccountHelper sPoolSnapshot snap epochToScaleToSum)\n            )\n            userId\n            (sPoolSnapshot {snapshotD = depositAdjustment}, 0)\n            accountsSnapshotsWithRewards\n      }\n\nspDeposits :: [(Integer, OnChainDecimal)] -> State SPState ()\nspDeposits newDeposits = do\n  SPState {accountsSnapshotsWithRewards} <- get\n  if Map.size accountsSnapshotsWithRewards P.== 0\n    then mapM_ accountAdjust newDeposits\n    else mapM_ accountAdjust (filter (\\(_, deposit) -> deposit /= 0) newDeposits)\n\nclose :: HasCallStack => Integer -> State SPState ()\nclose userUid = do\n  s@SPState {sPoolSnapshot, epochToScaleToSum, accountsSnapshotsWithRewards} <- get\n  let Just (snap, rew) = Map.lookup userUid accountsSnapshotsWithRewards\n      (newAccountSnapshot, Just reward) =\n        adjustAccountHelper\n          sPoolSnapshot\n          snap\n          epochToScaleToSum\n      sPoolSnapshot' = over snapshotDLens (|-| snapshotD newAccountSnapshot) sPoolSnapshot\n  put\n    s\n      { sPoolSnapshot = sPoolSnapshot' {snapshotD = spTruncate (snapshotD sPoolSnapshot')},\n        accountsSnapshotsWithRewards =\n          Map.insert\n            userUid\n            (newAccountSnapshot {snapshotD = toSPInteger 0}, rew + reward)\n            accountsSnapshotsWithRewards\n      }\n\n-- | This is used to update reward but to let accounts unchanged so we can make assertions.\nallClaimRewards :: HasCallStack => State SPState ()\nallClaimRewards = do\n  s@SPState {sPoolSnapshot, epochToScaleToSum, accountsSnapshotsWithRewards} <- get\n  put\n    s\n      { accountsSnapshotsWithRewards =\n          Map.map\n            ( \\(snap, reward') ->\n                second\n                  (\\(Just a) -> a + reward')\n                  (adjustAccountHelper sPoolSnapshot snap epochToScaleToSum)\n            )\n            accountsSnapshotsWithRewards\n      }\n\n-- | This mirrors the example from Liquity's readme:\n-- https://github.com/liquity/dev#stability-pool-example\nexampleReadmeScenario :: Assertion\nexampleReadmeScenario = afterT1Liquidation >> afterT2Liquidation\n  where\n    afterT1Liquidation :: Assertion\n    afterT1Liquidation =\n      let SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC)])} =\n            execState\n              (spDeposits (zip [0 ..] [100, 200, 300]) >> liquidationT1 >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt 75)\n            >> ( accRewardA\n                   `compareWithEps` getOnChainInt (OnChainDecimal 26_666_666)\n               )\n            >> ( fromSPInteger (snapshotD accSnapB)\n                   `compareWithEps` getOnChainInt 150\n               )\n            >> ( accRewardB\n                   `compareWithEps` getOnChainInt (OnChainDecimal 53_333_333)\n               )\n            >> ( fromSPInteger (snapshotD accSnapC)\n                   `compareWithEps` getOnChainInt 225\n               )\n            >> (accRewardC `compareWithEps` getOnChainInt 80)\n\n    afterT2Liquidation :: Assertion\n    afterT2Liquidation =\n      let SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC)])} =\n            execState\n              (spDeposits (zip [0 ..] [100, 200, 300]) >> liquidationT1 >> liquidationT2 >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt (OnChainDecimal 37_500_000))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 67_500_000))\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt 75)\n            >> (accRewardB `compareWithEps` getOnChainInt 135)\n            >> ( fromSPInteger (snapshotD accSnapC)\n                   `compareWithEps` getOnChainInt (OnChainDecimal 112_500_000)\n               )\n            >> ( accRewardC\n                   `compareWithEps` getOnChainInt (OnChainDecimal 202_500_000)\n               )\n\n    liquidationT1 :: State SPState ()\n    liquidationT1 = liquidate (150 * decimalUnit) (160 * decimalUnit)\n\n    liquidationT2 :: State SPState ()\n    liquidationT2 = liquidate (225 * decimalUnit) (245 * decimalUnit)\n\n-- | Depositors with equal initial deposit withdraw correct compounded deposit\n-- and ADA Gain after one liquidation\n-- 1. 3 Identical SP Deposits occur of 10k\n-- 2. A liquidation of a CDP with 10k iAsset and 100 ADA occurs.\n-- 3. Each depositor expects to have 6666.666666 iAsset available\n-- with 33.333333 ADA available as reward,\nt2 :: Assertion\nt2 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC)])} =\n            execState\n              (spDeposits (zip [0 ..] [10_000, 10_000, 10_000]) >> liquidation >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt (OnChainDecimal 6_666_666_666))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 33_333_333))\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt (OnChainDecimal 6_666_666_666))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 33_333_333))\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 6_666_666_666))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 33_333_333))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 666_666)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation :: State SPState ()\n    liquidation = liquidate (10_000 * decimalUnit) (100 * decimalUnit)\n\n-- | Depositors with equal initial deposit withdraw correct compounded deposit\n-- and ADA Gain after two identical liquidations\n-- 1. 3 Identical SP Deposits occur of 10k\n-- 2. Two equal liquidations of a CDP with 10k iAsset and 100 ADA occurs.\n-- 3. Each depositor expects to have 3333.333333 iAsset available\n-- with 66.666666 ADA available as reward,\nt3 :: Assertion\nt3 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC)])} =\n            execState\n              (spDeposits (zip [0 ..] [10_000, 10_000, 10_000]) >> liquidation >> liquidation >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt (OnChainDecimal 3333_333_333))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 66_666_666))\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt (OnChainDecimal 3333_333_333))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 66_666_666))\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 3333_333_333))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 66_666_666))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 333_333)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation :: State SPState ()\n    liquidation = liquidate (10_000 * decimalUnit) (100 * decimalUnit)\n\n-- | Depositors with equal initial deposit withdraw correct compounded\n-- deposit and ADA Gain after three identical liquidations\n-- 1. 3 Identical SP Deposits occur of 10k\n-- 2. Three equal liquidations of a CDP with 10k iAsset and 100 ADA occurs.\n-- 3. Each depositor expects to have 6666.666666 iAsset available\n-- with 33.333333 ADA available as reward,\nt4 :: Assertion\nt4 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC)])} =\n            execState\n              (spDeposits (zip [0 ..] [10_000, 10_000, 10_000]) >> liquidation >> liquidation >> liquidation >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt (OnChainDecimal 0))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 100_000_000))\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt (OnChainDecimal 0))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 100_000_000))\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 0))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 100_000_000))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 1_000_000)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 1)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation :: State SPState ()\n    liquidation = liquidate (10_000 * decimalUnit) (100 * decimalUnit)\n\n-- | Depositors with equal initial deposit withdraw correct compounded\n-- deposit and ADA Gain after two liquidations of increasing iAsset\n-- 1. 3 Identical SP Deposits occur of 10k\n-- 2. Liquidation of a CDP with 5k iAsset and 500 ADA occurs.\n-- 3. Liquidation of a CDP with 7k iAsset and 700 ADA occurs.\n-- 4. Each depositor expects to have 6000 iAsset available\n-- with 40 ADA available as reward,\nt5 :: Assertion\nt5 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC)])} =\n            execState\n              (spDeposits (zip [0 ..] [10_000, 10_000, 10_000]) >> liquidation1 >> liquidation2 >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt (OnChainDecimal 6000_000_000))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 40_000_000))\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt (OnChainDecimal 6000_000_000))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 40_000_000))\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 6000_000_000))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 40_000_000))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 600_000)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation1 :: State SPState ()\n    liquidation1 = liquidate (5_000 * decimalUnit) (50 * decimalUnit)\n\n    liquidation2 :: State SPState ()\n    liquidation2 = liquidate (7_000 * decimalUnit) (70 * decimalUnit)\n\n-- | Depositors with equal initial deposit withdraw correct compounded\n-- deposit and ADA Gain after three liquidations of increasing iAsset\n-- 1. 3 Identical SP Deposits occur of 10k\n-- 2. Liquidation of a CDP with 5k iAsset and 500 ADA occurs.\n-- 3. Liquidation of a CDP with 6k iAsset and 600 ADA occurs.\n-- 4. Liquidation of a CDP with 7k iAsset and 700 ADA occurs.\n-- 5. Each depositor expects to have 4000 iAsset available\n-- with 60 ADA available as reward,\nt6 :: Assertion\nt6 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC)])} =\n            execState\n              (spDeposits (zip [0 ..] [10_000, 10_000, 10_000]) >> liquidation1 >> liquidation2 >> liquidation3 >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt (OnChainDecimal 4000_000_000))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 60_000_000))\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt (OnChainDecimal 4000_000_000))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 60_000_000))\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 4000_000_000))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 60_000_000))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 400_000)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation1 :: State SPState ()\n    liquidation1 = liquidate (5_000 * decimalUnit) (50 * decimalUnit)\n\n    liquidation2 :: State SPState ()\n    liquidation2 = liquidate (6_000 * decimalUnit) (60 * decimalUnit)\n\n    liquidation3 :: State SPState ()\n    liquidation3 = liquidate (7_000 * decimalUnit) (70 * decimalUnit)\n\n-- | Depositors with varying deposits withdraw correct compounded deposit\n-- and ADA Gain after two identical liquidations\n-- 1. SP Deposits occur of 10k, 20k, and 30k\n-- 2. Two liquidations with 10k iAsset and 100 ADA occurs.\n-- 4. Depositor 1 = [6666.666666 deposit, 33.333333 ADA],\n-- Depositor 2 = [13333.333333 deposit, 66.666666 ADA],\n-- Depositor 3 = [20000 deposit, 100 ADA]\nt7 :: Assertion\nt7 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC)])} =\n            execState\n              (spDeposits (zip [0 ..] [10_000, 20_000, 30_000]) >> liquidation >> liquidation >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt (OnChainDecimal 6666_666_666))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 33_333_333))\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt (OnChainDecimal 13333_333_333))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 66_666_666))\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 20000_000_000))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 100_000_000))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 666_666)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation :: State SPState ()\n    liquidation = liquidate (10_000 * decimalUnit) (100 * decimalUnit)\n\n-- | Depositors with varying deposits withdraw correct compounded deposit\n-- and ADA Gain after three identical liquidations\n-- 1. SP Deposits occur of 10k, 20k, and 30k\n-- 2. Three equal liquidations with 10k iAsset and 100 ADA occurs.\n-- 3. Depositor 1 = [5000 deposit, 50 ADA],\n-- Depositor 2 = [10000 deposit, 100 ADA],\n-- Depositor 3 = [20000 deposit, 150 ADA]\nt8 :: Assertion\nt8 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC)])} =\n            execState\n              (spDeposits (zip [0 ..] [10_000, 20_000, 30_000]) >> liquidation >> liquidation >> liquidation >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt (OnChainDecimal 5000_000_000))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 50_000_000))\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt (OnChainDecimal 10000_000_000))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 100_000_000))\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 15000_000_000))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 150_000_000))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 500_000)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation :: State SPState ()\n    liquidation = liquidate (10_000 * decimalUnit) (100 * decimalUnit)\n\n-- | Depositors with varying deposits withdraw correct compounded deposit\n-- and ADA Gain after three varying liquidations\n-- 1. 3 SP Deposits occur of 2k, 456k, and 13.1k\n-- 2. Three liquidations: [207000 iAsset, 2160 ADA],\n-- [5000 iAsset, 50 ADA], [46700 iAsset, 500 ADA]\n-- 3. Depositor 1 = [5000 deposit, 50 ADA],\n-- Depositor 2 = [10000 deposit, 100 ADA],\n-- Depositor 3 = [20000 deposit, 150 ADA]\nt9 :: Assertion\nt9 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC)])} =\n            execState\n              (spDeposits (zip [0 ..] [2_000, 456_000, 13_100]) >> liquidation1 >> liquidation2 >> liquidation3 >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt (OnChainDecimal 901_719_380))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 11_504_988))\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt (OnChainDecimal 205_592_018_679))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 2_623_137_332))\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 5_906_261_940))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 75_357_673))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 450_859)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation1 :: State SPState ()\n    liquidation1 = liquidate (207_000 * decimalUnit) (2_160 * decimalUnit)\n\n    liquidation2 :: State SPState ()\n    liquidation2 = liquidate (5_000 * decimalUnit) (50 * decimalUnit)\n\n    liquidation3 :: State SPState ()\n    liquidation3 = liquidate (46_700 * decimalUnit) (500 * decimalUnit)\n\n-- | A, B, C Deposit -> 2 liquidations -> D deposits -> 1 liquidation.\n-- All deposits and liquidations = 100 iAsset.\n-- A, B, C, D withdraw correct iAsset deposit and ADA Gain\n-- 1. 3 SP Deposits occur of 10k\n-- 2. Two liquidations of 10k iAsset and 100 ADA\n-- 3. Additional deposit of 10k iAsset\n-- 4. Liquidation of 10k iAsset and 100 ADA\n-- 3. Depositor 1 = [5000 deposit, 50 ADA],\n-- Depositor 2 = [10000 deposit, 100 ADA],\n-- Depositor 3 = [20000 deposit, 150 ADA]\nt10 :: Assertion\nt10 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC), (accSnapD, accRewardD)]} =\n            execState\n              (spDeposits (zip [0 ..] [10_000, 10_000, 10_000, 0]) >> liquidation >> liquidation >> spDeposits (zip [0 ..] [0, 0, 0, 10_000]) >> liquidation >> allClaimRewards)\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt (OnChainDecimal 1666_666_666))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 83_333_332))\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt (OnChainDecimal 1666_666_666))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 83_333_332))\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 1666_666_666))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 83_333_332))\n            >> (fromSPInteger (snapshotD accSnapD) `compareWithEps` getOnChainInt (OnChainDecimal 5000_000_000))\n            >> (accRewardD `compareWithEps` getOnChainInt (OnChainDecimal 49_999_999))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 500_000)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation :: State SPState ()\n    liquidation = liquidate (10_000 * decimalUnit) (100 * decimalUnit)\n\n-- | Pool-emptying liquidation increases epoch by one, resets scaleFactor\n-- to 0, and resets P to 1e18\nt11 :: Assertion\nt11 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState =\n            execState\n              (spDeposits (zip [0 ..] [10_000, 10_000, 0, 0]) >> liquidation >> liquidation >> spDeposits (zip [0 ..] [0, 0, 10_000, 10_000]) >> liquidation >> liquidation >> allClaimRewards)\n              initState\n       in (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 1_000_000)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 2)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation :: State SPState ()\n    liquidation = liquidate (10_000 * decimalUnit) (100 * decimalUnit)\n\n-- | Deposit spans one scale factor change: Single depositor withdraws correct compounded deposit and ADA Gain after one liquidation\n\n-- 1. A deposits 10_000\n-- 2. L1 brings P close to boundary, i.e. 9e-9:\n-- liquidate 9999.99991 iAsset and 100 ADA\n-- 3. A withdraws all\n-- 4. B deposits 10_000\n-- 5. L2 of 9900 iAsset and 60 ADA, should bring P slightly\n-- past boundary i.e. 1e-9 -> 1e-10\nt12 :: Assertion\nt12 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB)]} =\n            execState\n              ( spDeposits (zip [0 ..] [10_000, 0])\n                  >> liquidation1\n                  >> close 0\n                  >> spDeposits (zip [0 ..] [0, 10_000])\n                  >> liquidation2\n                  >> allClaimRewards\n              )\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` 0)\n            >> (accRewardA `compareWithEps` getOnChainInt 100)\n            >> ( fromSPInteger (snapshotD accSnapB)\n                   `compareWithEps` getOnChainInt 100\n               )\n            >> (accRewardB `compareWithEps` getOnChainInt 60)\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 90_000)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 1)\n\n    liquidation1 :: State SPState ()\n    liquidation1 = liquidate 9999_999_910 (100 * decimalUnit)\n\n    liquidation2 :: State SPState ()\n    liquidation2 = liquidate (9_900 * decimalUnit) (60 * decimalUnit)\n\n-- | Several deposits of varying amounts span one scale factor change. Depositors withdraws correct compounded deposit and ADA Gain after one liquidation\n-- 1. A make deposit 10_000 iAsset\n-- 2. L1 brings P to 1e-5*P. L1:  9999.9 iAsset and 100 ADA\n-- 3. A withdraws all\n-- 4. B,C D make deposit 10_000, 20_000, 30_000\n-- 5. L2 decreases P again by 1e-5, over boundary. L2: 59_999.4\n-- (near to the 60_000 iAsset total deposits)\nt13 :: Assertion\nt13 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = map snd . Map.toList -> [(_, _), (accSnapB, accRewardB), (accSnapC, accRewardC), (accSnapD, accRewardD)]} =\n            execState\n              ( spDeposits (zip [0 ..] [10_000, 0, 0, 0])\n                  >> liquidation1\n                  >> close 0\n                  >> spDeposits (zip [0 ..] [0, 10_000, 20_000, 30_000])\n                  >> liquidation2\n                  >> allClaimRewards\n              )\n              initState\n       in (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt (OnChainDecimal 100_000))\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 200_000))\n            >> (fromSPInteger (snapshotD accSnapD) `compareWithEps` getOnChainInt (OnChainDecimal 300_000))\n            >> (accRewardB `compareWithEps` getOnChainInt 100)\n            >> (accRewardC `compareWithEps` getOnChainInt 200)\n            >> (accRewardD `compareWithEps` getOnChainInt 300)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 1)\n\n    liquidation1 :: State SPState ()\n    liquidation1 = liquidate 9999_900_000 (100 * decimalUnit)\n\n    liquidation2 :: State SPState ()\n    liquidation2 = liquidate 59999_400_000 (600 * decimalUnit)\n\n-- | Several deposits of 10000 iAsset span one scale factor change. Depositors withdraws correct compounded deposit and ADA Gain after one liquidation\n-- 1. A make deposit 10_000\n-- 2. L1 brings P to 0.0001P. L1:  9999.9 iAsset, 100 ADA\n-- 3. B makes deposit 9999.9, brings SP to 10k\n-- 4. L2 decreases P by(~1e-5)P. L2:  9999.9 iAsset, 100 ADA\n-- 5. C makes deposit 9999.9, brings SP to 10k\n-- 6. L3 decreases P by(~1e-5)P. L3:  9999.9 iAsset, 100 ADA\n-- 7. D makes deposit 9999.9, brings SP to 10k\n-- 8. L4 decreases P by(~1e-5)P. L4:  9999.9 iAsset, 100 ADA\nt14 :: Assertion\nt14 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC), (accSnapD, accRewardD)]} =\n            execState\n              ( spDeposits (zip [0 ..] [10_000, 0, 0, 0])\n                  >> liquidation\n                  >> spDeposits (zip [0 ..] [0, depositAmt, 0, 0])\n                  >> liquidation\n                  >> spDeposits (zip [0 ..] [0, 0, depositAmt, 0])\n                  >> liquidation\n                  >> spDeposits (zip [0 ..] [0, 0, 0, depositAmt])\n                  >> liquidation\n                  >> allClaimRewards\n              )\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` 0)\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` 0)\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` 0)\n            >> (fromSPInteger (snapshotD accSnapD) `compareWithEps` getOnChainInt (OnChainDecimal 99_999))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 100_000_999))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 99_999_999))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 99_999_999))\n            >> (accRewardD `compareWithEps` getOnChainInt (OnChainDecimal 99_998_999))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 10_000)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 2)\n\n    -- 9999.9 iassets\n    depositAmt :: OnChainDecimal\n    depositAmt = OnChainDecimal 9999_900_000\n\n    liquidation :: State SPState ()\n    liquidation = liquidate (getOnChainInt depositAmt) (100 * decimalUnit)\n\n-- | Depositors withdraw correct compounded deposit after liquidation\n-- empties the pool\n-- 1. A, B deposit 10000\n-- 2. L1 cancels 20000, 200\n-- 3. C, D, E deposit 10000, 20000, 30000\n-- 4. L2 cancels 10000, 100\nt15 :: Assertion\nt15 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB), (accSnapC, accRewardC), (accSnapD, accRewardD), (accSnapE, accRewardE)]} =\n            execState\n              ( spDeposits (zip [0 ..] [10_000, 10_000, 0, 0, 0])\n                  >> liquidation1\n                  >> spDeposits (zip [0 ..] [0, 0, 10_000, 20_000, 30_000])\n                  >> liquidation2\n                  >> allClaimRewards\n              )\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` 0)\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` 0)\n            >> (fromSPInteger (snapshotD accSnapC) `compareWithEps` getOnChainInt (OnChainDecimal 8_333_333_333))\n            >> (fromSPInteger (snapshotD accSnapD) `compareWithEps` getOnChainInt (OnChainDecimal 16_666_666_666))\n            >> (fromSPInteger (snapshotD accSnapE) `compareWithEps` getOnChainInt (OnChainDecimal 25_000_000_000))\n            >> (accRewardA `compareWithEps` getOnChainInt (OnChainDecimal 100_000_000))\n            >> (accRewardB `compareWithEps` getOnChainInt (OnChainDecimal 100_000_000))\n            >> (accRewardC `compareWithEps` getOnChainInt (OnChainDecimal 16_666_666))\n            >> (accRewardD `compareWithEps` getOnChainInt (OnChainDecimal 33_333_333))\n            >> (accRewardE `compareWithEps` getOnChainInt (OnChainDecimal 49_999_999))\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 833_333)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 1)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation1 :: State SPState ()\n    liquidation1 = liquidate (20_000 * decimalUnit) (200 * decimalUnit)\n\n    liquidation2 :: State SPState ()\n    liquidation2 = liquidate (10_000 * decimalUnit) (100 * decimalUnit)\n\n-- | Small liquidated coll/debt, large deposits and ADA price\nt16 :: Assertion\nt16 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = map snd . Map.toList -> [(accSnapA, accRewardA), (accSnapB, accRewardB)]} =\n            execState\n              ( spDeposits (zip [0 ..] [product (P.replicate 20 10), product (P.replicate 20 10)])\n                  >> liquidation\n                  >> allClaimRewards\n              )\n              initState\n       in (fromSPInteger (snapshotD accSnapA) `compareWithEps` getOnChainInt 99_999_999_999_999_997_500)\n            >> (fromSPInteger (snapshotD accSnapB) `compareWithEps` getOnChainInt 99_999_999_999_999_997_500)\n            >> (accRewardA `compareWithEps` 0)\n            >> (accRewardB `compareWithEps` 0)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n\n    liquidation :: State SPState ()\n    liquidation = liquidate (5_000 * decimalUnit) 5\n\nt17 :: Assertion\nt17 = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = map snd . Map.toList -> [(_, accRewardA), (_, accRewardB), (_, accRewardC), (_, accRewardD), (_, accRewardE)]} =\n            execState\n              ( spDeposits (zip [0 ..] [10_000, 0, 0, 0, 0])\n                  >> liquidation\n                  >> spDeposits (zip [0 ..] [0, amt, 0, 0, 0])\n                  >> liquidation\n                  >> spDeposits (zip [0 ..] [0, 0, amt, 0, 0])\n                  >> liquidation\n                  >> spDeposits (zip [0 ..] [0, 0, 0, amt, 0])\n                  >> liquidation\n                  >> spDeposits (zip [0 ..] [0, 0, 0, 0, amt])\n                  >> liquidation\n                  >> allClaimRewards\n              )\n              initState\n       in (accRewardA `compareWithEps` 1_000_010_000_100)\n            >> (accRewardB `compareWithEps` 1_000_000_000_000)\n            >> (accRewardC `compareWithEps` 1_000_000_000_000)\n            >> (accRewardD `compareWithEps` 999_999_999_900)\n            >> (accRewardE `compareWithEps` 999_990_000_000)\n            >> (fromSPIntegerToOCD (snapshotP (sPoolSnapshot spState)) `compareWithEps` OnChainDecimal 100_000_000_000)\n            >> (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 2)\n\n    amt :: OnChainDecimal\n    amt = OnChainDecimal 9999_900_000\n\n    liquidation :: State SPState ()\n    liquidation = liquidate (getOnChainInt amt) (1_000_000 * decimalUnit)\n\n-- | Check that when deposit decreases below 1e9th of the initial deposit, deposit becomes 0.\nt18 :: Assertion\nt18 = case1 >> case2\n  where\n    case1 :: Assertion\n    case1 =\n      let SPState\n            { accountsSnapshotsWithRewards =\n                map snd . Map.toList -> [(accSnapA, _)]\n            } =\n              execState\n                ( spDeposits (zip [0 ..] [10_000])\n                    >> liquidation1\n                    >> allClaimRewards\n                )\n                initState\n       in (fromSPInteger (snapshotD accSnapA) @?= 0)\n\n    case2 :: Assertion\n    case2 =\n      let SPState\n            { accountsSnapshotsWithRewards =\n                map snd . Map.toList -> [(accSnapA, _)]\n            } =\n              execState\n                ( spDeposits (zip [0 ..] [10_000])\n                    >> liquidation2\n                    >> allClaimRewards\n                )\n                initState\n       in (fromSPInteger (snapshotD accSnapA) @?= 1_000)\n\n    liquidation1 :: State SPState ()\n    liquidation1 = liquidate 9999_999_999 (100 * decimalUnit)\n\n    liquidation2 :: State SPState ()\n    liquidation2 = liquidate 9999_999_000 (100 * decimalUnit)\n\n-- | Test case with rounding issue\n-- 1. U1 Opens Stability Pool Account - 6_250_000\n-- 2. U2 Opens Stability Pool Account - 12_500_000\n-- 3. Liquidate 6_250_000\n-- 4. U2 Closes\ntNewCase :: Assertion\ntNewCase = afterLiquidation\n  where\n    afterLiquidation :: Assertion\n    afterLiquidation =\n      let spState@SPState {accountsSnapshotsWithRewards = (map snd . Map.toList -> [(_, _), (_, _)])} =\n            execState\n              (spDeposits (zip [0 ..] [625, 1250]) >> l1 >> close 1 >> close 0)\n              initState\n       in (snapshotEpoch (sPoolSnapshot spState) @?= 0)\n            >> (snapshotScale (sPoolSnapshot spState) @?= 0)\n            >> (snapshotD (sPoolSnapshot spState) @?= toSPInteger 0)\n\n    l1 :: State SPState ()\n    l1 = liquidate (625 * decimalUnit) (100 * decimalUnit)\n", "output": "The provided Haskell code is a test suite for a Cardano smart contract related to a Stability Pool, which is part of a decentralized finance (DeFi) protocol. The Stability Pool is a mechanism used to maintain the stability of a cryptocurrency by managing deposits and liquidations. This test suite is designed to verify the correct behavior of the Stability Pool under various scenarios.\n\n### Key Components of the Code\n\n1. **Imports and Language Extensions**:\n   - The code uses several Haskell language extensions and imports various modules, including `Control.Monad.State.Strict` for state management, `Data.Map` for map operations, and `Test.Tasty` for organizing tests.\n\n2. **Data Types**:\n   - `SPState`: Represents the state of the Stability Pool, including the current snapshot of the pool, a mapping of epochs to scales and sums, and a map of user accounts with their snapshots and rewards.\n\n3. **Constants**:\n   - `epsilon`: A small integer used for comparison with a margin of error, ensuring that floating-point operations are handled with some tolerance.\n\n4. **Helper Functions**:\n   - `compareWithEps`: Compares two values with a tolerance defined by `epsilon`.\n   - `liquidate`: Simulates the liquidation process, updating the state of the Stability Pool.\n   - `accountAdjust`: Adjusts a user's account in the Stability Pool based on a deposit adjustment.\n   - `spDeposits`: Handles multiple deposits into the Stability Pool.\n   - `close`: Closes a user's account, updating the state and rewards.\n   - `allClaimRewards`: Updates rewards for all accounts without changing their state.\n\n5. **Test Cases**:\n   - The `tests` function organizes a suite of test cases using `Test.Tasty`. Each test case simulates a specific scenario involving deposits, liquidations, and withdrawals in the Stability Pool.\n   - Example scenarios include:\n     - `exampleReadmeScenario`: Mirrors an example from Liquity's documentation, testing the behavior of the pool after specific liquidations.\n     - `t2` to `t18`: Various test cases that simulate different deposit and liquidation scenarios, checking the correctness of compounded deposits and ADA gains.\n     - `tNewCase`: A test case addressing a rounding issue, ensuring that the pool behaves correctly when handling specific deposit and liquidation amounts.\n\n### Detailed Explanation of a Few Test Cases\n\n- **`t2`**: Tests the scenario where three identical deposits are made, followed by a liquidation. It checks if each depositor receives the correct compounded deposit and ADA gain.\n  - Deposits: 10,000 iAsset each.\n  - Liquidation: 10,000 iAsset and 100 ADA.\n  - Expected Result: Each depositor should have 6,666.666666 iAsset and 33.333333 ADA as a reward.\n\n- **`t10`**: Tests a more complex scenario where three deposits are made, followed by two liquidations, an additional deposit, and another liquidation. It checks the final state of each depositor.\n  - Initial Deposits: 10,000 iAsset each for three users.\n  - Liquidations: Two liquidations of 10,000 iAsset and 100 ADA each.\n  - Additional Deposit: 10,000 iAsset by a new user.\n  - Final Liquidation: 10,000 iAsset and 100 ADA.\n  - Expected Result: Each initial depositor should have 1,666.666666 iAsset and 83.333332 ADA, while the new depositor should have 5,000 iAsset and 49.999999 ADA.\n\n- **`t11`**: Tests the behavior of the pool when a liquidation empties it, ensuring that the epoch increases, the scale factor resets, and the parameter `P` resets to 1e18.\n\n### Conclusion\n\nThis test suite is comprehensive, covering a wide range of scenarios to ensure the Stability Pool's functionality is robust and behaves as expected under different conditions. The use of state management and precise arithmetic operations is crucial for simulating the complex interactions within a DeFi protocol.", "file_path": "indigo-smart-contracts/tests/Spec/StabilityPool/Test.hs", "file": "Test.hs"}
{"instruction": "Explain the following smart contract code:", "input": "{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE StrictData #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE RecordWildCards #-}\n\nmodule CardanoSwaps.OneWaySwap\n  (\n    -- * On-Chain Data Types\n    SwapDatum(..)\n  , SwapRedeemer(..)\n  , BeaconRedeemer(..)\n\n    -- * Contracts\n  , swapScript\n  , swapValidatorHash\n  , beaconScript\n  , beaconCurrencySymbol\n    \n    -- * Beacon Names\n  , genPairBeaconName\n  , genOfferBeaconName\n  , genAskBeaconName\n\n    -- * Datums\n  , genSwapDatum  \n  ) where\n\nimport qualified PlutusTx\nimport qualified PlutusTx.Prelude as PlutusTx\nimport GHC.Generics (Generic)\nimport qualified Data.Map as Map\nimport Data.Aeson\nimport qualified Plutus.Script.Utils.Scripts as PV2\nimport qualified PlutusLedgerApi.V2 as PV2\n\nimport CardanoSwaps.Utils\nimport CardanoSwaps.Blueprints\n\n-------------------------------------------------\n-- On-Chain Data Types\n-------------------------------------------------\ndata SwapDatum = SwapDatum\n  { beaconId :: CurrencySymbol -- ^ `CurrencySymbol` for the `beaconScript`.\n  , pairBeacon :: TokenName -- ^ The pair beacon's `TokenName` for this trading pair.\n  , offerId :: CurrencySymbol -- ^ The `CurrencySymbol` for the offer asset.\n  , offerName :: TokenName -- ^ The `TokenName` for the offer asset.\n  , offerBeacon :: TokenName -- ^ The offer beacon's `TokenName`.\n  , askId :: CurrencySymbol -- ^ The `CurrencySymbol` for the ask asset.\n  , askName :: TokenName -- ^ The `TokenName` for the ask asset.\n  , askBeacon :: TokenName -- ^ The ask beacon's `TokenName`.\n  , swapPrice :: PlutusRational -- ^ The price to take the offer asset as a fraction (Ask/Offer).\n  , prevInput :: Maybe TxOutRef -- ^ The corresponding swap input's output reference.\n  } deriving (Generic,Show,Eq)\n\ninstance ToJSON SwapDatum where\n  toJSON SwapDatum{..} = \n    object [ \"beacon_id\" .= show beaconId\n           , \"pair_beacon\" .= showTokenName pairBeacon\n           , \"offer_id\" .= show offerId\n           , \"offer_name\" .= showTokenName offerName\n           , \"offer_beacon\" .= showTokenName offerBeacon\n           , \"ask_id\" .= show askId\n           , \"ask_name\" .= showTokenName askName\n           , \"ask_beacon\" .= showTokenName askBeacon\n           , \"price\" .= swapPrice \n           , \"prev_input\" .= prevInput\n           ]\n\ndata SwapRedeemer\n  -- | Spend the swap as the owner using the beacon script as a minting policy.\n  = SpendWithMint\n  -- | Spend the swap as the owner using the beacon script as a staking validator. This is only\n  -- for when no beacons need to be minted or burned in the transaction.\n  | SpendWithStake\n  -- | Take the offer asset and deposit the ask asset.\n  | Swap\n  deriving (Generic,Show)\n\ndata BeaconRedeemer\n  -- | Execute the beacon script as a minting policy. Used anytime beacons must be minted or burned.\n  = CreateOrCloseSwaps\n  -- | Execute the beacon script as a staking validtor. Used anytime beacons do not need to be\n  -- minted or burned.\n  | UpdateSwaps\n  deriving (Generic,Show)\n\nPlutusTx.unstableMakeIsData ''SwapDatum\nPlutusTx.unstableMakeIsData ''SwapRedeemer\nPlutusTx.unstableMakeIsData ''BeaconRedeemer\n\n-------------------------------------------------\n-- Contracts\n-------------------------------------------------\nswapScript :: SerialisedScript\nswapScript = parseScriptFromCBOR $ blueprints Map.! \"one_way_swap.swap_script\"\n\nswapValidatorHash :: PV2.ValidatorHash\nswapValidatorHash = PV2.ValidatorHash $ PV2.getScriptHash $ scriptHash swapScript\n\nbeaconScript :: SerialisedScript\nbeaconScript =\n  applyArguments\n    (parseScriptFromCBOR $ blueprints Map.! \"one_way_swap.beacon_script\")\n    [PlutusTx.toData swapValidatorHash]\n\nbeaconCurrencySymbol :: PV2.CurrencySymbol\nbeaconCurrencySymbol = PV2.CurrencySymbol $ PV2.getScriptHash $ scriptHash beaconScript\n\n-------------------------------------------------\n-- Beacon Names\n-------------------------------------------------\n-- | Generate the beacon asset name by hashing offer ++ ask. The policy id for\n-- ADA is set to \"00\".\n--\n-- > sha2_256 ( offerId ++ offerName ++ askId ++ askName )\ngenPairBeaconName :: OfferAsset -> AskAsset -> TokenName\ngenPairBeaconName (OfferAsset assetX) (AskAsset assetY) =\n  let ((CurrencySymbol sym1',TokenName name1),(CurrencySymbol sym2',TokenName name2)) =\n        (assetX,assetY)\n      sym1 = \n        if sym1' == \"\" \n        then unsafeToBuiltinByteString \"00\" \n        else sym1'\n      sym2 = \n        if sym2' == \"\" \n        then unsafeToBuiltinByteString \"00\" \n        else sym2'\n  in TokenName $ PlutusTx.sha2_256 $ sym1 <> name1 <> sym2 <> name2\n\n-- | Generate the beacon asset name by hashing the offer asset policy id and name. \n--\n-- > sha2_256 ( \"01\" ++ offerId ++ offerName )\ngenOfferBeaconName :: OfferAsset -> TokenName\ngenOfferBeaconName (OfferAsset (CurrencySymbol sym,TokenName name)) =\n  TokenName $ PlutusTx.sha2_256 $ unsafeToBuiltinByteString \"01\" <> sym <> name\n\n-- | Generate the beacon asset name by hashing the ask asset policy id and name.\n--\n-- > sha2_256 ( \"02\" ++ askId ++ askName )\ngenAskBeaconName :: AskAsset -> TokenName\ngenAskBeaconName (AskAsset (CurrencySymbol sym,TokenName name)) =\n  TokenName $ PlutusTx.sha2_256 $ unsafeToBuiltinByteString \"02\" <> sym <> name\n\n-------------------------------------------------\n-- Datums\n-------------------------------------------------\ngenSwapDatum :: OfferAsset -> AskAsset -> PlutusRational -> Maybe TxOutRef -> SwapDatum\ngenSwapDatum o@(OfferAsset offerCfg) a@(AskAsset askCfg) price mPrev =\n  SwapDatum\n    { beaconId = beaconCurrencySymbol\n    , pairBeacon = genPairBeaconName o a\n    , offerId = fst offerCfg\n    , offerName = snd offerCfg\n    , offerBeacon = genOfferBeaconName o\n    , askId = fst askCfg\n    , askName = snd askCfg\n    , askBeacon = genAskBeaconName a\n    , swapPrice = price\n    , prevInput = mPrev\n    }\n", "output": "This Cardano smart contract code defines a module for a one-way swap mechanism on the Cardano blockchain. The module is structured into several sections, each serving a specific purpose. Let's break down the code in detail:\n\n### Language Extensions and Module Declaration\n\n- **Language Extensions**: The code uses several Haskell language extensions:\n  - `TemplateHaskell`: Allows for metaprogramming, which is used here for generating instances of data types.\n  - `StrictData`: Ensures that all fields in data types are strictly evaluated.\n  - `OverloadedStrings`: Allows string literals to be interpreted as different types, such as `Text` or `ByteString`.\n  - `RecordWildCards`: Enables concise syntax for working with record fields.\n\n- **Module Declaration**: The module is named `CardanoSwaps.OneWaySwap` and exports several data types, functions, and constants related to the swap mechanism.\n\n### On-Chain Data Types\n\n- **`SwapDatum`**: This data type represents the state of a swap on the blockchain. It includes:\n  - `beaconId`: The `CurrencySymbol` for the beacon script.\n  - `pairBeacon`: The `TokenName` for the trading pair's beacon.\n  - `offerId` and `offerName`: The `CurrencySymbol` and `TokenName` for the offer asset.\n  - `offerBeacon`: The `TokenName` for the offer beacon.\n  - `askId` and `askName`: The `CurrencySymbol` and `TokenName` for the ask asset.\n  - `askBeacon`: The `TokenName` for the ask beacon.\n  - `swapPrice`: The price of the swap as a fraction (ask/offer).\n  - `prevInput`: An optional reference to a previous transaction output.\n\n- **`SwapRedeemer`**: This data type defines actions that can be taken on a swap:\n  - `SpendWithMint`: Spend the swap using the beacon script as a minting policy.\n  - `SpendWithStake`: Spend the swap using the beacon script as a staking validator.\n  - `Swap`: Execute the swap by taking the offer asset and depositing the ask asset.\n\n- **`BeaconRedeemer`**: This data type defines actions related to the beacon script:\n  - `CreateOrCloseSwaps`: Use the beacon script as a minting policy to create or close swaps.\n  - `UpdateSwaps`: Use the beacon script as a staking validator to update swaps.\n\n### Contracts\n\n- **`swapScript`**: A serialized script representing the swap logic, parsed from a predefined blueprint.\n\n- **`swapValidatorHash`**: The hash of the swap validator script, used to identify the script on the blockchain.\n\n- **`beaconScript`**: A serialized script for the beacon logic, with arguments applied to it. This script is used for managing beacons related to swaps.\n\n- **`beaconCurrencySymbol`**: The currency symbol derived from the beacon script's hash, used to identify the beacon tokens.\n\n### Beacon Names\n\n- **`genPairBeaconName`**: Generates a beacon name for a trading pair by hashing the concatenation of the offer and ask asset identifiers. It uses a special policy ID for ADA.\n\n- **`genOfferBeaconName`**: Generates a beacon name for the offer asset by hashing its policy ID and name, prefixed with \"01\".\n\n- **`genAskBeaconName`**: Generates a beacon name for the ask asset by hashing its policy ID and name, prefixed with \"02\".\n\n### Datums\n\n- **`genSwapDatum`**: A function to create a `SwapDatum` instance. It takes an offer asset, an ask asset, a swap price, and an optional previous transaction output reference, and constructs a `SwapDatum` with the appropriate fields filled in.\n\n### Summary\n\nThis module provides the necessary data types and functions to implement a one-way swap mechanism on the Cardano blockchain. It defines how swaps are represented, how they can be executed, and how related beacons are managed. The use of hashing and unique identifiers ensures that each swap and beacon is uniquely identifiable on the blockchain.", "file_path": "no-swaps/src/CardanoSwaps/OneWaySwap.hs", "file": "OneWaySwap.hs"}
{"instruction": "Explain the following smart contract code:", "input": "import datetime\n\nimport fire\nimport pycardano\n\nfrom muesliswap_onchain_governance.onchain.tally.tally import BoxedInt\nfrom muesliswap_onchain_governance.onchain.util import reduced_proposal_params\nfrom muesliswap_onchain_governance.utils.network import (\n    show_tx,\n    blockfrost_client,\n    context,\n)\nfrom muesliswap_onchain_governance.utils.to_script_context import to_address\nfrom opshin.prelude import Token, Nothing\nfrom pycardano import (\n    OgmiosChainContext,\n    TransactionBuilder,\n    Redeemer,\n    AuxiliaryData,\n    AlonzoMetadata,\n    Metadata,\n    TransactionOutput,\n    Value,\n)\n\nfrom muesliswap_onchain_governance.offchain.util import (\n    token_from_string,\n    asset_from_token,\n    with_min_lovelace,\n    sorted_utxos,\n    amount_of_token_in_value,\n)\nfrom muesliswap_onchain_governance.onchain.tally import tally, tally_auth_nft\nfrom muesliswap_onchain_governance.onchain.staking import (\n    staking_vote_nft,\n    staking,\n    vote_permission_nft,\n)\nfrom muesliswap_onchain_governance.utils import (\n    get_signing_info,\n    ogmios_url,\n    network,\n    kupo_url,\n)\nfrom muesliswap_onchain_governance.utils.contracts import (\n    get_contract,\n    module_name,\n    get_ref_utxo,\n)\nimport blockfrost\n\n\ndef main(\n    wallet: str = \"creator\",\n    vote_permission_cbor_hex: str = None,\n):\n    # Load script info\n    (\n        tally_script,\n        _,\n        tally_address,\n    ) = get_contract(module_name(tally), True)\n    tally_script_ref_utxo = get_ref_utxo(tally_script, context)\n    (\n        staking_script,\n        _,\n        staking_address,\n    ) = get_contract(module_name(staking), True)\n    staking_script_ref_utxo = get_ref_utxo(staking_script, context)\n    (\n        staking_vote_nft_script,\n        staking_vote_nft_policy_id,\n        _,\n    ) = get_contract(module_name(staking_vote_nft), True)\n    staking_vote_nft_ref_utxo = get_ref_utxo(staking_vote_nft_script, context)\n    (\n        _,\n        tally_auth_nft_policy_id,\n        _,\n    ) = get_contract(module_name(tally_auth_nft), True)\n    (\n        vote_permission_nft_script,\n        vote_permission_nft_policy_id,\n        _,\n    ) = get_contract(module_name(vote_permission_nft), True)\n    vote_permission_nft_ref_utxo = get_ref_utxo(vote_permission_nft_script, context)\n\n    # Get payment address\n    payment_vkey, payment_skey, payment_address = get_signing_info(\n        wallet, network=network\n    )\n\n    # find staking position with vote permission\n    staking_utxos = context.utxos(staking_address)\n    staking_utxo = None\n    for u in staking_utxos:\n        try:\n            prev_staking_datum = staking.StakingState.from_cbor(u.output.datum.cbor)\n        except Exception as e:\n            continue\n        if prev_staking_datum.params.owner == to_address(payment_address):\n            continue\n        if not u.output.amount.multi_asset.get(\n            pycardano.ScriptHash(vote_permission_nft_policy_id.payload), {}\n        ):\n            continue\n        staking_utxo = u\n        break\n    assert staking_utxo, \"Staking position with vote permission not found\"\n\n    vote_permission_nft_tk = Token(\n        vote_permission_nft_policy_id.payload,\n        list(\n            staking_utxo.output.amount.multi_asset.get(\n                pycardano.ScriptHash(vote_permission_nft_policy_id.payload), {}\n            ).keys()\n        )[0].payload,\n    )\n    # We can simply look this up because the token name is the same as the datum hash of the redeemer during minting - it is hence known to most indexers\n    if vote_permission_cbor_hex is None:\n        vote_permission_raw_cbor = blockfrost_client.script_datum_cbor(\n            vote_permission_nft_tk.token_name.hex()\n        ).cbor\n    else:\n        vote_permission_raw_cbor = bytes.fromhex(vote_permission_cbor_hex)\n    vote_permission = vote_permission_nft.VotePermissionNFTParams.from_cbor(\n        vote_permission_raw_cbor\n    )\n    assert isinstance(\n        vote_permission.redeemer, vote_permission_nft.DelegatedAddVote\n    ), \"Only add vote permissions are supported by this script\"\n    proposal_id = vote_permission.redeemer.participation.tally_params.proposal_id\n\n    tally_auth_nft_tk = (\n        vote_permission.redeemer.participation.tally_params.tally_auth_nft\n    )\n    # Select tally\n    tally_utxos = context.utxos(tally_address)\n    tally_utxo = None\n    for u in tally_utxos:\n        if not amount_of_token_in_value(tally_auth_nft_tk, u.output.amount):\n            continue\n        prev_tally_datum = tally.TallyState.from_cbor(u.output.datum.cbor)\n        if prev_tally_datum.params.proposal_id == proposal_id:\n            tally_utxo = u\n            break\n    assert tally_utxo, \"Tally with given proposal id not found\"\n\n    voting_power = vote_permission.redeemer.participation.weight\n    proposal_index = vote_permission.redeemer.participation.proposal_index\n\n    payment_utxos = context.utxos(payment_address)\n    all_inputs = sorted_utxos(\n        [tally_utxo] + [staking_utxo] + payment_utxos,\n    )\n    tally_input_index = all_inputs.index(tally_utxo)\n    staking_input_index = all_inputs.index(staking_utxo)\n\n    # generate redeemer for the tally\n    tally_redeemer = Redeemer(\n        tally.AddTallyVote(\n            proposal_index=proposal_index,\n            weight=voting_power,\n            voter_address=vote_permission.owner,\n            tally_input_index=tally_input_index,\n            tally_output_index=0,\n            staking_output_index=1,\n            staking_input_index=BoxedInt(staking_input_index),\n        )\n    )\n\n    # Make the new datum of the Tally\n    new_tally_votes = prev_tally_datum.votes.copy()\n    new_tally_votes[proposal_index] += voting_power\n    new_tally_datum = tally.TallyState(\n        params=prev_tally_datum.params,\n        votes=new_tally_votes,\n    )\n\n    # generate redeemer for the staking\n    participation = vote_permission.redeemer.participation\n    staking_redeemer = Redeemer(\n        staking.AddVote(\n            state_input_index=staking_input_index,\n            state_output_index=1,\n            participation=participation,\n        )\n    )\n    # generate the new datum for the staking\n    new_staking_participations = prev_staking_datum.participations.copy()\n    new_staking_participations.insert(0, participation)\n    new_staking_datum = staking.StakingState(\n        params=prev_staking_datum.params,\n        participations=new_staking_participations,\n    )\n\n    # generate the redeemer for the staking vote nft\n    staking_vote_nft_redeemer = Redeemer(\n        staking_vote_nft.VoteAuthRedeemer(\n            tally_input_index=tally_input_index,\n            tally_output_index=0,\n            vote_index=proposal_index,\n            staking_output_index=1,\n        )\n    )\n    staking_vote_nft_name = staking_vote_nft.staking_vote_nft_name(\n        proposal_index,\n        voting_power,\n        reduced_proposal_params(prev_tally_datum.params),\n    )\n    staking_vote_nft_tk = Token(\n        staking_vote_nft_policy_id.payload, staking_vote_nft_name\n    )\n    vote_permission_nft_redeemer = Redeemer(Nothing())\n\n    # Build the transaction\n    builder = TransactionBuilder(context)\n    builder.auxiliary_data = AuxiliaryData(\n        data=AlonzoMetadata(\n            metadata=Metadata({674: {\"msg\": [\"Vote in Tally (delegated)\"]}})\n        )\n    )\n    for u in payment_utxos:\n        builder.add_input(u)\n    builder.add_script_input(\n        tally_utxo, tally_script_ref_utxo or tally_script, None, tally_redeemer\n    )\n    builder.add_script_input(\n        staking_utxo, staking_script_ref_utxo or staking_script, None, staking_redeemer\n    )\n\n    builder.add_minting_script(\n        staking_vote_nft_ref_utxo or staking_vote_nft_script,\n        staking_vote_nft_redeemer,\n    )\n    builder.add_minting_script(\n        vote_permission_nft_ref_utxo or vote_permission_nft_script,\n        vote_permission_nft_redeemer,\n    )\n    builder.mint = asset_from_token(staking_vote_nft_tk, 1) + asset_from_token(\n        vote_permission_nft_tk, -1\n    )\n    tally_output = TransactionOutput(\n        address=tally_address,\n        amount=tally_utxo.output.amount,\n        datum=new_tally_datum,\n    )\n    builder.add_output(tally_output)\n    builder.add_output(\n        with_min_lovelace(\n            pycardano.TransactionOutput(\n                address=staking_address,\n                amount=staking_utxo.output.amount\n                + Value(multi_asset=asset_from_token(staking_vote_nft_tk, 1))\n                - Value(multi_asset=asset_from_token(vote_permission_nft_tk, 1)),\n                datum=new_staking_datum,\n            ),\n            context,\n        )\n    )\n\n    # Sign the transaction\n    signed_tx = builder.build_and_sign(\n        signing_keys=[payment_skey],\n        change_address=payment_address,\n    )\n\n    # Submit the transaction\n    context.submit_tx(signed_tx)\n\n    show_tx(signed_tx)\n    return signed_tx\n\n\nif __name__ == \"__main__\":\n    fire.Fire(main)\n", "output": "This Python script is part of the MuesliSwap on-chain governance system on the Cardano blockchain. It is designed to execute a transaction that adds a vote permission to a tally, which is part of a governance proposal. Let's break down the script step by step:\n\n### Imports\n\n- **Standard Libraries**: \n  - `datetime` for handling date and time.\n  - `fire` for creating command-line interfaces.\n  \n- **PyCardano**: A library for interacting with the Cardano blockchain.\n  \n- **MuesliSwap Governance Modules**: Various modules from the MuesliSwap governance system, including tally, staking, and utility functions.\n\n- **Opshin Prelude**: Provides types like `Token` and `Nothing`.\n\n- **Blockfrost**: A library for interacting with the Blockfrost API, which is used to query the Cardano blockchain.\n\n### Main Function\n\nThe `main` function is the entry point of the script. It takes two parameters:\n- `wallet`: The name of the wallet to use for signing the transaction.\n- `vote_permission_cbor_hex`: An optional CBOR hex string representing the vote permission.\n\n### Script Execution Steps\n\n1. **Load Script Info**: \n   - Retrieve contract scripts and their reference UTXOs for tally, staking, staking vote NFT, and vote permission NFT.\n\n2. **Get Payment Address**: \n   - Retrieve the payment verification key, signing key, and address for the specified wallet.\n\n3. **Find Staking Position with Vote Permission**:\n   - Query UTXOs at the staking address.\n   - Identify a UTXO that contains a vote permission NFT and belongs to the wallet.\n\n4. **Retrieve Vote Permission**:\n   - If `vote_permission_cbor_hex` is not provided, fetch the CBOR from Blockfrost using the token name.\n   - Deserialize the CBOR to get the vote permission parameters.\n\n5. **Select Tally**:\n   - Query UTXOs at the tally address.\n   - Find a UTXO that matches the proposal ID from the vote permission.\n\n6. **Prepare Transaction Inputs**:\n   - Collect all necessary UTXOs, including the tally and staking UTXOs, and sort them.\n\n7. **Generate Redeemers**:\n   - Create redeemers for the tally and staking scripts, which specify how the scripts should be executed.\n   - Create a redeemer for the staking vote NFT.\n\n8. **Create New Datums**:\n   - Update the tally and staking datums to reflect the new vote.\n\n9. **Build the Transaction**:\n   - Use `TransactionBuilder` to construct the transaction.\n   - Add inputs, script inputs, and minting scripts.\n   - Specify the minting of a new staking vote NFT and the burning of the vote permission NFT.\n   - Add outputs for the updated tally and staking states.\n\n10. **Sign and Submit the Transaction**:\n    - Sign the transaction with the wallet's signing key.\n    - Submit the transaction to the Cardano network.\n    - Display the transaction details.\n\n### Key Concepts\n\n- **UTXO (Unspent Transaction Output)**: Represents a portion of Cardano's accounting model, where transactions consume and produce UTXOs.\n\n- **Datum and Redeemer**: In Cardano smart contracts, a datum is data attached to a UTXO, and a redeemer is data provided when spending a UTXO.\n\n- **Minting and Burning Tokens**: The script mints a new staking vote NFT and burns the vote permission NFT as part of the transaction.\n\n- **Governance**: The script is part of a governance system where users can vote on proposals using their staking positions.\n\n### Conclusion\n\nThis script automates the process of adding a vote permission to a tally in the MuesliSwap governance system. It interacts with various on-chain scripts and constructs a transaction that updates the state of the governance proposal, reflecting the user's voting power. The use of PyCardano and Blockfrost allows for seamless interaction with the Cardano blockchain.", "file_path": "muesliswap-onchain-governance/muesliswap_onchain_governance/offchain/tally/execute_add_vote_permission.py", "file": "execute_add_vote_permission.py"}
{"instruction": "Explain the following smart contract code:", "input": "module Test.Plutip.LocalCluster (\n  BpiWallet,\n  RetryDelay,\n  addSomeWallet,\n  ada,\n  waitSeconds,\n  mkMainnetAddress,\n  cardanoMainnetAddress,\n  ledgerPaymentPkh,\n  withCluster,\n  withConfiguredCluster,\n  startCluster,\n  stopCluster,\n  plutusValueFromWallet,\n) where\n\nimport Control.Concurrent (threadDelay)\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Control.Monad.Reader (MonadReader (ask), ReaderT, ask)\nimport Data.Bifunctor (second)\nimport Data.Default (def)\nimport Data.List.NonEmpty (NonEmpty)\nimport Data.List.NonEmpty qualified as NE\nimport Ledger (Value)\nimport Numeric.Natural (Natural)\nimport Numeric.Positive (Positive)\nimport Test.Plutip.Config (PlutipConfig (extraConfig))\nimport Test.Plutip.Contract.Init (ada)\nimport Test.Plutip.Contract.Types (\n  TestWallet (twInitDistribuition),\n  TestWallets (unTestWallets),\n )\nimport Test.Plutip.Internal.BotPlutusInterface.Wallet (\n  BpiWallet,\n  addSomeWallet,\n  cardanoMainnetAddress,\n  ledgerPaymentPkh,\n  mkMainnetAddress,\n )\nimport Test.Plutip.Internal.Cluster.Extra.Types (ecSlotLength)\nimport Test.Plutip.Internal.LocalCluster (startCluster, stopCluster)\nimport Test.Plutip.Internal.Types (ClusterEnv)\nimport Test.Plutip.Tools.CardanoApi (CardanoApiError, plutusValueFromAddress)\nimport Test.Plutip.Tools.ChainIndex qualified as CI\nimport Test.Tasty (testGroup, withResource)\nimport Test.Tasty.Providers (TestTree)\n\n-- | Awaiting via `threadDelay`\nwaitSeconds :: Natural -> ReaderT ClusterEnv IO ()\nwaitSeconds n = liftIO $ threadDelay (fromEnum n * 1_000_000)\n\n-- | Spin up a local cluster and create a test group with the contracts inside it.\n-- The cluster is reused by all the test cases, but the wallets are isolated, so contracts won't\n-- depend on each other (note that time related issues might still occur).\n-- Uses default `PlutipConfig`.\n--\n-- = Usage\n-- > test :: TestTree\n-- > test =\n-- >   withCluster\n-- >     \"Tests with local cluster\"\n-- >     [ shouldSucceed \"Get utxos\" (initAda 100) $ const getUtxos\n-- >     ...\n--\n-- @since 0.2\nwithCluster ::\n  String ->\n  [(TestWallets, IO (ClusterEnv, NonEmpty BpiWallet) -> TestTree)] ->\n  TestTree\nwithCluster = withConfiguredCluster def\n\n-- | Spin up a local cluster and create a test group with the contracts inside it.\n-- The cluster is reused by all the test cases, but the wallets are isolated, so contracts won't\n-- depend on each other (note that time related issues might still occur).\n--\n-- = Usage\n-- > test :: TestTree\n-- > test =\n-- >     let myConfig = PlutipConfig ...\n-- >     withConfiguredCluster myConfig\n-- >     \"Tests with local cluster\"\n-- >     [ shouldSucceed \"Get utxos\" (initAda 100) $ const getUtxos\n-- >     ...\n--\n-- @since 0.2\nwithConfiguredCluster ::\n  PlutipConfig ->\n  String ->\n  [(TestWallets, IO (ClusterEnv, NonEmpty BpiWallet) -> TestTree)] ->\n  TestTree\nwithConfiguredCluster conf name testCases =\n  withResource (startCluster conf setup) (stopCluster . fst) $\n    \\getResource ->\n      testGroup name $\n        imap\n          (\\idx (_, toTestGroup) -> toTestGroup $ second (!! idx) . snd <$> getResource)\n          testCases\n  where\n    setup :: ReaderT ClusterEnv IO (ClusterEnv, [NonEmpty BpiWallet])\n    setup = do\n      env <- ask\n      wallets <-\n        traverse\n          (traverse addSomeWallet . fmap twInitDistribuition . unTestWallets . fst)\n          testCases\n      let waitDelay = ecSlotLength $ extraConfig conf\n      awaitFunds wallets waitDelay\n      pure (env, wallets)\n\n    awaitFunds ws delay = do\n      let lastWallet = NE.last $ last ws\n      liftIO $ putStrLn \"Waiting till all wallets will be funded to start tests...\"\n      CI.awaitWalletFunded lastWallet delay\n\ntype RetryDelay = Positive\n\nimap :: (Int -> a -> b) -> [a] -> [b]\nimap fn = zipWith fn [0 ..]\n\n-- Get total `Value` of all UTxOs at `BpiWallet` address.\nplutusValueFromWallet ::\n  MonadIO m =>\n  BpiWallet ->\n  ReaderT ClusterEnv m (Either CardanoApiError Value)\nplutusValueFromWallet bw = do\n  cEnv <- ask\n  liftIO . plutusValueFromAddress cEnv . cardanoMainnetAddress $ bw\n", "output": "The provided Haskell code is a module for testing Cardano smart contracts using a local cluster setup. It is part of a testing framework that allows developers to simulate a Cardano blockchain environment locally, which is useful for testing smart contracts without deploying them to a live network. Let's break down the key components and functions of this module:\n\n### Module and Imports\n\n- **Module Declaration**: The module is named `Test.Plutip.LocalCluster` and it exports several functions and types related to managing a local Cardano cluster and interacting with wallets.\n- **Imports**: The module imports various Haskell libraries and other modules within the project. These imports provide functionality for concurrency, monadic operations, data manipulation, and specific Cardano-related operations.\n\n### Key Types and Functions\n\n1. **Types**:\n   - `BpiWallet`: Represents a wallet in the Bot Plutus Interface (BPI) system.\n   - `RetryDelay`: A type alias for `Positive`, representing a positive natural number used for retry delays.\n\n2. **Functions**:\n\n   - **`waitSeconds`**: \n     - This function pauses execution for a specified number of seconds. It uses `threadDelay` to achieve this, converting the input from `Natural` to microseconds.\n     - `ReaderT ClusterEnv IO ()` indicates it runs in a monadic context that has access to the `ClusterEnv` environment.\n\n   - **`withCluster`**:\n     - Sets up a local Cardano cluster using default configuration (`def`).\n     - It takes a description string and a list of test cases, each associated with a set of test wallets and a function to create a `TestTree`.\n     - Internally, it calls `withConfiguredCluster` with the default configuration.\n\n   - **`withConfiguredCluster`**:\n     - Similar to `withCluster`, but allows specifying a custom `PlutipConfig`.\n     - It manages the lifecycle of the cluster, starting it with `startCluster` and stopping it with `stopCluster`.\n     - The function `setup` initializes the cluster environment and wallets, ensuring they are funded before tests run.\n     - `awaitFunds` ensures that all wallets are funded before proceeding with tests, using a delay specified in the configuration.\n\n   - **`plutusValueFromWallet`**:\n     - Retrieves the total `Value` of all UTxOs (Unspent Transaction Outputs) at a given `BpiWallet` address.\n     - It uses the `plutusValueFromAddress` function from the `CardanoApi` tools, which interacts with the Cardano blockchain to fetch UTxO data.\n\n3. **Helper Functions**:\n\n   - **`imap`**:\n     - A utility function that applies a function to each element of a list, passing the element's index as an additional argument. It is similar to `map`, but includes the index.\n\n### Usage\n\nThe module is designed to facilitate testing of smart contracts by providing a controlled environment where developers can simulate blockchain interactions. The `withCluster` and `withConfiguredCluster` functions are central to this, as they manage the setup and teardown of the local cluster, ensuring that each test case runs in isolation with its own set of wallets.\n\n### Conclusion\n\nThis module is a crucial part of a testing framework for Cardano smart contracts, providing tools to simulate a blockchain environment locally. It abstracts away the complexities of setting up and managing a Cardano cluster, allowing developers to focus on writing and testing their smart contracts.", "file_path": "plutip/src/Test/Plutip/LocalCluster.hs", "file": "LocalCluster.hs"}
{"instruction": "Explain the following smart contract code:", "input": "use aiken/bytearray\nuse aiken/dict.{Dict}\nuse aiken/hash.{Hash,Blake2b_224}\nuse aiken/list\nuse aiken/transaction/credential.{\n  Address,\n  Inline,\n  StakeCredential,\n  ScriptCredential,\n  VerificationKey,\n  VerificationKeyCredential\n  }\nuse aiken/transaction/value.{PolicyId,MintedValue}\n\nuse cardano_swaps/common/types.{AssetConfig}\n\npub fn trace_if_false(msg: String, predicate: Bool) {\n  if !predicate {\n    trace msg\n    predicate\n  } else {\n    predicate\n  }\n}\n\npub fn error_if_false(msg: String, predicate: Bool) {\n  if !predicate {\n    error msg\n  } else {\n    predicate\n  }\n}\n\n// Check that either the staking pubkey signed or the staking script was executed.\npub fn staking_credential_approves(\n  swap_addr: Address, \n  withdrawals: Dict<StakeCredential, Int>,\n  extra_signatories: List<Hash<Blake2b_224, VerificationKey>>\n) -> Bool {\n  let Address(_,staking_cred) = swap_addr\n  when staking_cred is {\n    // This is to prevent permanent locking of funds. Beacons can never be minted to an address\n    // without a valid staking credential.\n    None -> True\n\n    // If the address uses a staking pubkey, it must have signed the tx.\n    Some(Inline(VerificationKeyCredential(skey))) -> {\n      list.has(extra_signatories,skey)\n    }\n\n    // If the address uses a staking script, it must have been executed in the tx. In order for\n    // the staking credential to show up in this dictionary, it must be registered.\n    Some(svh) -> {\n      dict.has_key(withdrawals,svh)\n    }\n  }\n}\n\npub fn compare_asset_config(asset1: AssetConfig, asset2: AssetConfig) -> Ordering {\n  let AssetConfig(asset1_id,asset1_name) = asset1\n  let AssetConfig(asset2_id,asset2_name) = asset2\n  when bytearray.compare(asset1_id,asset2_id) is {\n    Less -> Less\n    Greater -> Greater\n    Equal -> bytearray.compare(asset1_name,asset2_name)\n  }\n}\n\npub fn has_beacon_script_minting_execution(\n  beacon_id: PolicyId,\n  mint: MintedValue\n) -> Bool {\n  !(value.from_minted_value(mint) |> value.tokens(_,beacon_id) |> dict.is_empty(_))\n}\n\npub fn has_beacon_script_staking_execution(\n  beacon_id: PolicyId,\n  withdrawals: Dict<StakeCredential, Int>,\n) -> Bool {\n  dict.has_key(\n    withdrawals,\n    Inline(ScriptCredential(beacon_id))\n  )\n}\n", "output": "This Cardano smart contract code is written in Aiken, a language designed for writing smart contracts on the Cardano blockchain. The code provides utility functions for handling various operations related to staking credentials, asset configuration comparison, and beacon script execution. Let's break down each part of the code:\n\n### Imports\n\nThe code begins with a series of `use` statements, which import various modules and types from the Aiken standard library and a custom library (`cardano_swaps`). These imports provide necessary functions and types for handling byte arrays, dictionaries, hashes, lists, transaction credentials, and values.\n\n### Utility Functions\n\n1. **`trace_if_false` Function:**\n   - **Purpose:** Logs a message if a given predicate (boolean condition) is false.\n   - **Parameters:**\n     - `msg`: A string message to log.\n     - `predicate`: A boolean condition.\n   - **Behavior:** If the predicate is false, it logs the message using `trace` and returns the predicate. If true, it simply returns the predicate.\n\n2. **`error_if_false` Function:**\n   - **Purpose:** Throws an error with a message if a given predicate is false.\n   - **Parameters:**\n     - `msg`: A string message for the error.\n     - `predicate`: A boolean condition.\n   - **Behavior:** If the predicate is false, it throws an error with the message. If true, it returns the predicate.\n\n### Staking Credential Approval\n\n3. **`staking_credential_approves` Function:**\n   - **Purpose:** Checks if the staking credential associated with a swap address has approved a transaction.\n   - **Parameters:**\n     - `swap_addr`: The address involved in the swap.\n     - `withdrawals`: A dictionary mapping staking credentials to withdrawal amounts.\n     - `extra_signatories`: A list of hashes representing additional signatories.\n   - **Behavior:** \n     - If the address has no staking credential, it returns `True`.\n     - If the address uses a staking public key, it checks if the key is in the list of extra signatories.\n     - If the address uses a staking script, it checks if the script's credential is in the withdrawals dictionary.\n\n### Asset Configuration Comparison\n\n4. **`compare_asset_config` Function:**\n   - **Purpose:** Compares two asset configurations.\n   - **Parameters:**\n     - `asset1`, `asset2`: Two `AssetConfig` objects to compare.\n   - **Behavior:** \n     - Compares the policy IDs of the two assets.\n     - If the policy IDs are equal, it compares the asset names.\n     - Returns an `Ordering` (`Less`, `Greater`, or `Equal`) based on the comparison.\n\n### Beacon Script Execution\n\n5. **`has_beacon_script_minting_execution` Function:**\n   - **Purpose:** Checks if a beacon script was executed during minting.\n   - **Parameters:**\n     - `beacon_id`: The policy ID of the beacon.\n     - `mint`: The minted value in the transaction.\n   - **Behavior:** \n     - Converts the minted value to a token list and checks if there are any tokens associated with the beacon ID.\n     - Returns `True` if there are tokens, indicating the script was executed.\n\n6. **`has_beacon_script_staking_execution` Function:**\n   - **Purpose:** Checks if a beacon script was executed during staking.\n   - **Parameters:**\n     - `beacon_id`: The policy ID of the beacon.\n     - `withdrawals`: A dictionary of staking credentials and withdrawal amounts.\n   - **Behavior:** \n     - Checks if the beacon script's credential is a key in the withdrawals dictionary.\n     - Returns `True` if the script's credential is present, indicating execution.\n\n### Summary\n\nThis code provides utility functions for handling staking credentials, comparing asset configurations, and verifying the execution of beacon scripts in the context of Cardano swaps. These functions are essential for ensuring that transactions meet specific conditions and that assets are correctly managed within the smart contract.", "file_path": "no-swaps/aiken/lib/cardano_swaps/common/utils.ak", "file": "utils.ak"}
{"instruction": "Explain the following smart contract code:", "input": "import ast\n\nimport importlib\nimport importlib.util\nimport pathlib\nimport typing\nimport sys\nfrom ast import *\nfrom ordered_set import OrderedSet\n\nfrom ..util import CompilingNodeTransformer\n\n\"\"\"\nChecks that there was an import of dataclass if there are any class definitions\n\"\"\"\n\n\ndef import_module(name, package=None):\n    \"\"\"An approximate implementation of import.\"\"\"\n    absolute_name = importlib.util.resolve_name(name, package)\n    try:\n        return sys.modules[absolute_name]\n    except KeyError:\n        pass\n\n    path = None\n    if \".\" in absolute_name:\n        parent_name, _, child_name = absolute_name.rpartition(\".\")\n        parent_module = import_module(parent_name)\n        path = parent_module.__spec__.submodule_search_locations\n    for finder in sys.meta_path:\n        spec = finder.find_spec(absolute_name, path)\n        if spec is not None:\n            break\n    else:\n        msg = f\"No module named {absolute_name!r}\"\n        raise ModuleNotFoundError(msg, name=absolute_name)\n    module = importlib.util.module_from_spec(spec)\n    sys.modules[absolute_name] = module\n    spec.loader.exec_module(module)\n    if path is not None:\n        setattr(parent_module, child_name, module)\n    return module\n\n\nclass RewriteLocation(CompilingNodeTransformer):\n    def __init__(self, orig_node):\n        self.orig_node = orig_node\n\n    def visit(self, node):\n        node = ast.copy_location(node, self.orig_node)\n        return super().visit(node)\n\n\nclass RewriteImport(CompilingNodeTransformer):\n    step = \"Resolving imports\"\n\n    def __init__(self, filename=None, package=None, resolved_imports=None):\n        self.filename = filename\n        self.package = package\n        self.resolved_imports = resolved_imports or OrderedSet()\n\n    def visit_ImportFrom(\n        self, node: ImportFrom\n    ) -> typing.Union[ImportFrom, typing.List[AST], None]:\n        if node.module in [\n            \"pycardano\",\n            \"typing\",\n            \"dataclasses\",\n            \"hashlib\",\n            \"opshin.bridge\",\n            \"opshin.std.integrity\",\n        ]:\n            return node\n        assert (\n            len(node.names) == 1\n        ), \"The import must have the form 'from <pkg> import *'\"\n        assert (\n            node.names[0].name == \"*\"\n        ), \"The import must have the form 'from <pkg> import *'\"\n        assert (\n            node.names[0].asname == None\n        ), \"The import must have the form 'from <pkg> import *'\"\n        # TODO set anchor point according to own package\n        if self.filename:\n            sys.path.append(str(pathlib.Path(self.filename).parent.absolute()))\n        module = import_module(node.module, self.package)\n        if self.filename:\n            sys.path.pop()\n        module_file = pathlib.Path(module.__file__)\n        if module_file.suffix == \".pyc\":\n            module_file = module_file.with_suffix(\".py\")\n        if module_file in self.resolved_imports:\n            # Import was already resolved and its names are visible\n            return None\n        self.resolved_imports.add(module_file)\n        assert (\n            module_file.suffix == \".py\"\n        ), \"The import must import a single python file.\"\n        # visit the imported file again - make sure that recursive imports are resolved accordingly\n        with module_file.open(\"r\") as fp:\n            module_content = fp.read()\n        resolved = parse(module_content, filename=module_file.name)\n        # annotate this to point to the original line number!\n        RewriteLocation(node).visit(resolved)\n        # recursively import all statements there\n        recursive_resolver = RewriteImport(\n            filename=str(module_file),\n            package=module.__package__,\n            resolved_imports=self.resolved_imports,\n        )\n        recursively_resolved: Module = recursive_resolver.visit(resolved)\n        self.resolved_imports.update(recursive_resolver.resolved_imports)\n        return recursively_resolved.body\n", "output": "The provided code is a Python script that is part of a system for rewriting and resolving imports in a specific context, likely related to the compilation or transformation of Python code for use in Cardano smart contracts. Let's break down the code in detail:\n\n### Imports and Dependencies\n\n- **Standard Library Imports:**\n  - `ast`: Provides classes and functions to interact with Python's Abstract Syntax Tree (AST).\n  - `importlib`, `importlib.util`: Used for importing modules programmatically.\n  - `pathlib`: Provides an object-oriented interface to handle filesystem paths.\n  - `typing`: Provides type hints.\n  - `sys`: Provides access to system-specific parameters and functions.\n\n- **Third-Party Imports:**\n  - `ordered_set`: Provides an ordered set data structure, which maintains the order of elements.\n\n- **Local Imports:**\n  - `CompilingNodeTransformer`: A custom class likely used for transforming AST nodes during compilation.\n\n### Function: `import_module`\n\nThis function is a custom implementation of Python's import mechanism. It attempts to import a module by its name, handling both top-level and submodules. Here's how it works:\n\n1. **Resolve the Module Name:** Uses `importlib.util.resolve_name` to get the absolute name of the module.\n2. **Check if Already Imported:** Looks in `sys.modules` to see if the module is already imported.\n3. **Handle Submodules:** If the module name contains a dot, it treats it as a submodule and attempts to import the parent module first.\n4. **Find and Load the Module:** Iterates over `sys.meta_path` to find a loader for the module and then loads it.\n5. **Cache the Module:** Once loaded, the module is stored in `sys.modules` to avoid re-importing.\n6. **Set as Attribute:** If it's a submodule, it sets the module as an attribute of the parent module.\n\n### Class: `RewriteLocation`\n\nThis class is a subclass of `CompilingNodeTransformer` and is used to copy the location (line numbers, etc.) from an original AST node to a new node. This is useful for maintaining accurate debugging and error reporting information after transformations.\n\n- **`__init__`:** Initializes with the original node.\n- **`visit`:** Copies the location from the original node to the current node and then visits the node using the superclass method.\n\n### Class: `RewriteImport`\n\nThis class is responsible for resolving imports in the AST. It is also a subclass of `CompilingNodeTransformer`.\n\n- **Attributes:**\n  - `step`: A string indicating the current step, \"Resolving imports\".\n  - `filename`: The name of the file being processed.\n  - `package`: The package context for relative imports.\n  - `resolved_imports`: An `OrderedSet` to keep track of already resolved imports to avoid duplication.\n\n- **`visit_ImportFrom`:** This method handles `from ... import ...` statements in the AST.\n  - **Allowed Modules:** If the module is one of a predefined set (e.g., `pycardano`, `typing`), it returns the node as is.\n  - **Assertions:** Ensures that the import statement is of the form `from <pkg> import *`.\n  - **Path Management:** Temporarily adds the directory of the current file to `sys.path` to resolve imports.\n  - **Module Resolution:** Uses `import_module` to import the module.\n  - **File Handling:** Ensures the module file is a Python file (`.py`) and not a compiled file (`.pyc`).\n  - **Recursive Resolution:** Reads the module file, parses it into an AST, and recursively resolves imports within it.\n  - **Return:** Returns the body of the resolved module, effectively inlining the imported module's content.\n\n### Summary\n\nThis script is part of a system that processes Python code, likely for compiling or transforming it into a form suitable for Cardano smart contracts. It focuses on resolving imports, particularly those of the form `from <pkg> import *`, by inlining the imported module's content into the current module. This approach ensures that all necessary code is available in a single context, which can be crucial for environments where dynamic imports are not feasible or desired.", "file_path": "opshin/opshin/rewrite/rewrite_import.py", "file": "rewrite_import.py"}
{"instruction": "Explain the following smart contract code:", "input": "from typing import Optional\n\nfrom ..typed_ast import (\n    TypedAssign,\n    ClassType,\n    InstanceType,\n    PolymorphicFunctionType,\n    TypeInferenceError,\n)\nfrom ..util import CompilingNodeTransformer\n\n\"\"\"\nRemove class reassignments without constructors and polymorphic function reassignments\n\nBoth of these are only present during the type inference and are discarded or generated in-place during compilation.\n\"\"\"\n\n\nclass RewriteRemoveTypeStuff(CompilingNodeTransformer):\n    step = \"Removing class and polymorphic function re-assignments\"\n\n    def visit_Assign(self, node: TypedAssign) -> Optional[TypedAssign]:\n        assert (\n            len(node.targets) == 1\n        ), \"Assignments to more than one variable not supported yet\"\n        try:\n            if isinstance(node.value.typ, ClassType):\n                try:\n                    typ = node.value.typ.constr_type()\n                except TypeInferenceError:\n                    # no constr_type is also fine\n                    return None\n            else:\n                typ = node.value.typ\n            if isinstance(typ, InstanceType) and isinstance(\n                typ.typ, PolymorphicFunctionType\n            ):\n                return None\n        except AttributeError:\n            # untyped attributes are fine too\n            pass\n        return node\n", "output": "This code is part of a transformation process for a typed abstract syntax tree (AST) in a Cardano smart contract development environment. The purpose of this transformation is to clean up certain types of assignments that are only relevant during type inference and are not needed in the final compiled code. Let's break down the code in detail:\n\n### Imports\n\n- **Optional**: A type hint indicating that a function might return a value or `None`.\n- **TypedAssign, ClassType, InstanceType, PolymorphicFunctionType, TypeInferenceError**: These are imported from a module named `typed_ast`. They represent different components and types used in the type inference process.\n- **CompilingNodeTransformer**: A utility class from the `util` module that likely provides a framework for transforming nodes in an AST.\n\n### Class: `RewriteRemoveTypeStuff`\n\nThis class inherits from `CompilingNodeTransformer`, suggesting it is designed to traverse and transform nodes in an AST.\n\n- **step**: A class attribute that describes the transformation step being performed. Here, it indicates that the transformation involves removing certain class and polymorphic function re-assignments.\n\n#### Method: `visit_Assign`\n\nThis method is designed to process assignment nodes (`TypedAssign`) in the AST. It attempts to remove certain types of assignments that are not needed after type inference.\n\n1. **Assertion**: \n   - The method asserts that each assignment node has exactly one target. This means the transformation does not support assignments to multiple variables at once (e.g., `a, b = 1, 2`).\n\n2. **Type Checking**:\n   - The method checks if the type of the value being assigned is a `ClassType`.\n   - If it is a `ClassType`, it attempts to retrieve its constructor type using `constr_type()`.\n   - If `constr_type()` raises a `TypeInferenceError`, the method returns `None`, effectively removing this assignment from the AST. This suggests that assignments to class types without a constructor are not needed.\n\n3. **Polymorphic Function Type Check**:\n   - If the type is not a `ClassType`, it checks if it is an `InstanceType` and if its type is a `PolymorphicFunctionType`.\n   - If both conditions are true, the method returns `None`, removing the assignment. This indicates that re-assignments involving polymorphic functions are also discarded.\n\n4. **AttributeError Handling**:\n   - If an `AttributeError` occurs (likely because the node's value does not have a `typ` attribute), the method allows it to pass, implying that untyped attributes are acceptable and do not need to be removed.\n\n5. **Return**:\n   - If none of the conditions for removal are met, the method returns the original node, leaving the assignment unchanged.\n\n### Summary\n\nThe `RewriteRemoveTypeStuff` class is a transformation utility that cleans up the AST by removing unnecessary assignments related to class types without constructors and polymorphic function types. These assignments are only relevant during type inference and are not needed in the final compiled code. This process helps streamline the AST, making it more efficient for subsequent compilation steps.", "file_path": "opshin/opshin/rewrite/rewrite_remove_type_stuff.py", "file": "rewrite_remove_type_stuff.py"}
{"instruction": "Explain the following smart contract code:", "input": "from opshin.std.fractions import *\n\n\ndef mul_fraction_int(a: Fraction, b: int) -> Fraction:\n    \"\"\"returns a * b\"\"\"\n    return Fraction(a.numerator * b, a.denominator)\n", "output": "This Cardano smart contract code is written in Python and is designed to work with the Opshin framework, which is used for writing smart contracts on the Cardano blockchain. The code is specifically dealing with fractions, which are a part of mathematical operations that can be useful in various financial and computational contexts within smart contracts.\n\nLet's break down the code:\n\n1. **Import Statement**:\n   ```python\n   from opshin.std.fractions import *\n   ```\n   This line imports everything from the `fractions` module within the `opshin.std` package. The `fractions` module likely provides utilities for working with fractional numbers, similar to Python's standard `fractions` module, but tailored for use in the Opshin environment.\n\n2. **Function Definition**:\n   ```python\n   def mul_fraction_int(a: Fraction, b: int) -> Fraction:\n   ```\n   This line defines a function named `mul_fraction_int` that takes two parameters:\n   - `a`: A `Fraction` object, which represents a rational number with a numerator and a denominator.\n   - `b`: An integer (`int`), which is a whole number.\n\n   The function is annotated to return a `Fraction` object.\n\n3. **Docstring**:\n   ```python\n   \"\"\"returns a * b\"\"\"\n   ```\n   This is a docstring, which is a string literal used to document the purpose of the function. It indicates that the function returns the product of the fraction `a` and the integer `b`.\n\n4. **Function Implementation**:\n   ```python\n   return Fraction(a.numerator * b, a.denominator)\n   ```\n   This line performs the actual computation. It creates and returns a new `Fraction` object. The numerator of this new fraction is the product of the numerator of `a` and the integer `b`. The denominator remains the same as that of `a`.\n\n   - `a.numerator * b`: This multiplies the numerator of the fraction `a` by the integer `b`.\n   - `a.denominator`: This keeps the denominator unchanged.\n\n   The result is a new fraction that represents the product of the original fraction `a` and the integer `b`.\n\n**Purpose and Use Case**:\n- This function is useful in scenarios where you need to scale a fraction by an integer. For example, in financial applications, you might need to multiply a fractional interest rate by a number of periods or units.\n- By keeping the denominator the same, the function ensures that the result is still a valid fraction, maintaining the precision of fractional arithmetic.\n\nOverall, this code snippet is a utility function that simplifies the multiplication of a fraction by an integer, which can be a common operation in smart contracts dealing with fractional values.", "file_path": "uada-contracts/uada/onchain/utils/ext_fraction.py", "file": "ext_fraction.py"}
{"instruction": "Explain the following smart contract code:", "input": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash\n", "output": "This Cardano smart contract code is written in Haskell using the Plutarch library, which is a domain-specific language (DSL) for writing Plutus smart contracts. The code defines a module `ErgoDex.PValidators` that provides several validators for a decentralized exchange (DEX) on the Cardano blockchain. Let's break down the code in detail:\n\n### Module and Imports\n\n```haskell\nmodule ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n```\n\n- **Module Declaration**: The module `ErgoDex.PValidators` is declared, and it exports several functions: `poolValidator`, `swapValidator`, `depositValidator`, `redeemValidator`, `validatorAddress`, and `wrapValidator`.\n\n```haskell\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n```\n\n- **Imports**: The code imports necessary modules from the Plutus Ledger API, which provides types and functions for working with scripts and addresses.\n\n```haskell\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n```\n\n- **Qualified Imports**: These imports bring in specific contract logic for deposit, pool, redeem, and swap operations from the `ErgoDex.PContracts` namespace, each aliased for easy reference.\n\n```haskell\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n```\n\n- **Plutarch Imports**: These imports bring in core Plutarch functionality, including the ability to create validators, work with script contexts, and perform unsafe operations like coercing data types.\n\n### Core Functionality\n\n#### `wrapValidator`\n\n```haskell\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n```\n\n- **Type Signature**: The `wrapValidator` function takes a validator function that operates on specific data types (`dt` and `rdmr`) and returns a wrapped version that operates on generic `PData` types.\n- **Function Logic**:\n  - `plam`: Defines a Plutarch lambda function.\n  - `punsafeCoerce`: Unsafely coerces `PData` to the expected data types (`dt` and `rdmr`).\n  - `validator # dt # rdmr # ctx`: Applies the validator to the coerced datum, redeemer, and context.\n  - `popaque`: Wraps the result in an opaque type, returning `PUnit` if true, or tracing an error if false.\n\n#### Validators\n\n```haskell\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n```\n\n- **Validator Definitions**: Each validator is created using `mkValidator`, which takes a wrapped validator function specific to each contract type (pool, swap, deposit, redeem). These functions (`PP.poolValidatorT`, `PS.swapValidatorT`, etc.) are assumed to be defined in their respective modules.\n\n#### `validatorAddress`\n\n```haskell\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash\n```\n\n- **Functionality**: This function takes a `Validator` and computes its blockchain address by first obtaining the validator's hash (`validatorHash`) and then converting it to an address (`scriptHashAddress`).\n\n### Summary\n\nThis module provides a structured way to define and wrap validators for different operations in a DEX on Cardano. The `wrapValidator` function is a key utility that ensures validators can be applied to generic data types, making them compatible with the Plutus infrastructure. Each specific validator (pool, swap, deposit, redeem) is defined by wrapping its corresponding logic from the imported modules. The `validatorAddress` function allows for easy retrieval of a validator's address on the blockchain.", "file_path": "no-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "file": "PValidators.hs"}
{"instruction": "Explain the following smart contract code:", "input": "-- SPDX-License-Identifier: BUSL-1.1\n\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Indigo.Contracts.Governance.VersionRegistry.OnChain\n  ( validateVersionRecord,\n    mintVersionRecord,\n    versionRecordTokenPolicy,\n    versionRegistryValidator,\n    versionRegistryValidatorAddress,\n    versionRegistryValidatorHash,\n    versionRecordTokenPolicyScriptCTL,\n    versionRegistryScriptCTL,\n    untypedVersionRecordMintSymbol,\n    untypedVersionRegistryValidatorHash,\n  )\nwhere\n\nimport Indigo.Contracts.Governance.VersionRegistry.Common\n  ( VersionRecord,\n    VersionRecordMintingPolicyRedeemer (AddRecord),\n    VersionRecordParams (VersionRecordParams, upgradeToken),\n    VersionRecordRedeemer,\n  )\nimport Indigo.Utils.Helpers qualified as Helpers\nimport Ledger qualified\nimport Ledger.Value qualified as Value\nimport Plutus.Script.Utils.V2.Address qualified as Address\nimport Plutus.Script.Utils.V2.Scripts qualified as PV2\nimport Plutus.Script.Utils.V2.Typed.Scripts.MonetaryPolicies\n  ( UntypedMintingPolicy,\n    mkUntypedMintingPolicy,\n  )\nimport Plutus.Script.Utils.V2.Typed.Scripts.Validators\n  ( UntypedValidator,\n    mkUntypedValidator,\n  )\nimport Plutus.V2.Ledger.Api qualified as V2\nimport PlutusTx qualified\nimport PlutusTx.Prelude\nimport Prelude (seq)\n\n{-# INLINEABLE validateVersionRecord #-}\nvalidateVersionRecord ::\n  VersionRecord ->\n  VersionRecordRedeemer ->\n  V2.ScriptContext ->\n  Bool\nvalidateVersionRecord _ _ _ = False\n\n{-# INLINEABLE mintVersionRecord #-}\nmintVersionRecord ::\n  VersionRecordParams ->\n  VersionRecordMintingPolicyRedeemer ->\n  V2.ScriptContext ->\n  Bool\nmintVersionRecord VersionRecordParams {upgradeToken} AddRecord ctx =\n  Helpers.findUniqueInputWithToken upgradeToken info `seq` True\n  where\n    info :: V2.TxInfo\n    info = V2.scriptContextTxInfo ctx\n\nversionRecordTokenPolicy :: VersionRecordParams -> V2.MintingPolicy\nversionRecordTokenPolicy params =\n  V2.mkMintingPolicyScript\n    (compiledMintVersionRecord `PlutusTx.applyCode` PlutusTx.liftCode params)\n\ncompiledMintVersionRecord ::\n  PlutusTx.CompiledCode (VersionRecordParams -> UntypedMintingPolicy)\ncompiledMintVersionRecord =\n  Helpers.optimizeUPLC\n    $$(PlutusTx.compile [||mkUntypedMintingPolicy . mintVersionRecord||])\n\ncompiledUntypedMintVersionRecord ::\n  PlutusTx.CompiledCode (BuiltinData -> UntypedMintingPolicy)\ncompiledUntypedMintVersionRecord =\n  Helpers.optimizeUPLC\n    $$( PlutusTx.compile\n          [||\n          mkUntypedMintingPolicy\n            . mintVersionRecord\n            . PlutusTx.unsafeFromBuiltinData\n          ||]\n      )\n\nuntypedVersionRecordMintPolicy :: BuiltinData -> V2.MintingPolicy\nuntypedVersionRecordMintPolicy params =\n  V2.mkMintingPolicyScript\n    ( compiledUntypedMintVersionRecord\n        `PlutusTx.applyCode` PlutusTx.liftCode params\n    )\n\nuntypedVersionRecordMintPolicyHash :: BuiltinData -> V2.MintingPolicyHash\nuntypedVersionRecordMintPolicyHash = PV2.mintingPolicyHash . untypedVersionRecordMintPolicy\n\nuntypedVersionRecordMintSymbol :: BuiltinData -> Value.CurrencySymbol\nuntypedVersionRecordMintSymbol = Value.mpsSymbol . untypedVersionRecordMintPolicyHash\n\n-- serialised for use in CTL\nversionRecordTokenPolicyScriptCTL :: V2.Script\nversionRecordTokenPolicyScriptCTL =\n  V2.fromCompiledCode compiledUntypedMintVersionRecord\n\nversionRegistryValidator :: V2.Validator\nversionRegistryValidator = V2.mkValidatorScript compiledValidateVersionRecord\n\ncompiledValidateVersionRecord :: PlutusTx.CompiledCode UntypedValidator\ncompiledValidateVersionRecord =\n  Helpers.optimizeUPLC\n    $$(PlutusTx.compile [||mkUntypedValidator validateVersionRecord||])\n\nuntypedVersionRegistryValidator :: V2.Validator\nuntypedVersionRegistryValidator = V2.mkValidatorScript compiledValidateVersionRecord\n\nuntypedVersionRegistryValidatorHash :: V2.ValidatorHash\nuntypedVersionRegistryValidatorHash = PV2.validatorHash untypedVersionRegistryValidator\n\n-- serialised for use in CTL\nversionRegistryScriptCTL :: V2.Script\nversionRegistryScriptCTL = V2.fromCompiledCode compiledValidateVersionRecord\n\nversionRegistryValidatorHash :: V2.ValidatorHash\nversionRegistryValidatorHash = PV2.validatorHash versionRegistryValidator\n\nversionRegistryValidatorAddress :: Ledger.Address\nversionRegistryValidatorAddress =\n  Address.mkValidatorAddress versionRegistryValidator\n", "output": "This Cardano smart contract code is part of the Indigo project, specifically dealing with governance and version registry functionalities. The code is written in Haskell and uses Plutus, Cardano's smart contract platform. Let's break down the key components and functionality of this code:\n\n### Modules and Imports\n\n- **Module Declaration**: The module is named `Indigo.Contracts.Governance.VersionRegistry.OnChain`. It exports several functions and values related to version registry and token policies.\n- **Imports**: The code imports various modules, including:\n  - `Indigo.Contracts.Governance.VersionRegistry.Common`: Provides common types and redeemers used in the version registry.\n  - `Indigo.Utils.Helpers`: Contains utility functions, likely for optimizing UPLC (Untyped Plutus Core) code.\n  - `Ledger`, `Ledger.Value`, `Plutus.Script.Utils`, and `Plutus.V2.Ledger.Api`: These are standard Plutus libraries for working with scripts, addresses, and values.\n\n### Key Functions and Definitions\n\n1. **`validateVersionRecord`**:\n   - This function is intended to validate a version record. However, it currently returns `False`, indicating that any transaction attempting to use this validator will fail. This might be a placeholder or a security measure until the validation logic is implemented.\n\n2. **`mintVersionRecord`**:\n   - This function is responsible for minting a version record token.\n   - It takes `VersionRecordParams`, a redeemer (`AddRecord`), and a `ScriptContext`.\n   - It checks for the presence of a unique input with a specific `upgradeToken` in the transaction context (`ctx`). If found, it returns `True`, allowing the minting to proceed.\n\n3. **`versionRecordTokenPolicy`**:\n   - This function creates a minting policy script for version record tokens using the `mintVersionRecord` function.\n   - It compiles the minting logic into a Plutus script.\n\n4. **`compiledMintVersionRecord` and `compiledUntypedMintVersionRecord`**:\n   - These are compiled versions of the minting policy, optimized using helper functions.\n   - `compiledMintVersionRecord` is used for typed minting policies, while `compiledUntypedMintVersionRecord` is for untyped policies.\n\n5. **`untypedVersionRecordMintPolicy` and `untypedVersionRecordMintPolicyHash`**:\n   - These functions create and hash an untyped minting policy from `BuiltinData`.\n\n6. **`untypedVersionRecordMintSymbol`**:\n   - This function retrieves the currency symbol for the minting policy, which is used to identify the minted tokens.\n\n7. **`versionRecordTokenPolicyScriptCTL`**:\n   - This is a serialized version of the minting policy script for use in CTL (likely a tool or framework for managing scripts).\n\n8. **`versionRegistryValidator`**:\n   - This function creates a validator script for the version registry using the `validateVersionRecord` function.\n\n9. **`compiledValidateVersionRecord`**:\n   - This is the compiled and optimized version of the `validateVersionRecord` function.\n\n10. **`untypedVersionRegistryValidator` and `untypedVersionRegistryValidatorHash`**:\n    - These provide an untyped version of the validator and its hash.\n\n11. **`versionRegistryScriptCTL`**:\n    - A serialized version of the validator script for use in CTL.\n\n12. **`versionRegistryValidatorHash` and `versionRegistryValidatorAddress`**:\n    - These provide the hash and address of the version registry validator, which are essential for interacting with the validator on the blockchain.\n\n### Summary\n\nThis code defines the on-chain logic for managing version records in the Indigo governance system. It includes functions for minting version record tokens and validating version records, although the validation logic is currently a placeholder. The code also provides utilities for creating and interacting with Plutus scripts, including serialization for use in external tools. The use of `Helpers.optimizeUPLC` suggests a focus on optimizing the performance and size of the compiled Plutus scripts.", "file_path": "indigo-smart-contracts/src/Indigo/Contracts/Governance/VersionRegistry/OnChain.hs", "file": "OnChain.hs"}
{"instruction": "Explain the following smart contract code:", "input": "import datetime\n\nimport fire\nimport pycardano\n\nfrom uada.onchain import uada, one_shot_nft, parameter_auth_nft\nfrom uada.utils.from_script_context import from_address\nfrom uada.utils.network import show_tx, context\nfrom uada.utils.to_script_context import to_address, to_tx_out_ref\nfrom opshin.prelude import Token\nfrom pycardano import (\n    OgmiosChainContext,\n    TransactionBuilder,\n    Redeemer,\n    AuxiliaryData,\n    AlonzoMetadata,\n    Metadata,\n    TransactionOutput,\n    Value,\n    Withdrawals,\n)\n\nfrom .util import (\n    token_from_string,\n    asset_from_token,\n    module_name,\n    with_min_lovelace,\n    sorted_utxos,\n    amount_of_token_in_value,\n    SAMPLE_STAKE_KEY,\n    combine_with_stake_key,\n)\nfrom ..utils import get_signing_info, ogmios_url, network, kupo_url\nfrom ..utils.contracts import get_contract, get_ref_utxo\n\n\ndef main(\n    wallet: str = \"minter\",\n    stake_key: str = SAMPLE_STAKE_KEY,\n    admin_wallet: str = \"admin\",\n):\n    # Load script info\n    (\n        uada_script,\n        uada_policy_id,\n        uada_address,\n    ) = get_contract(module_name(uada), True)\n    uada_ref_utxo = get_ref_utxo(uada_script, context)\n    (\n        one_shot_nft_script,\n        one_shot_nft_policy_id,\n        _,\n    ) = get_contract(module_name(one_shot_nft), True)\n    one_shot_nft_ref_utxo = get_ref_utxo(one_shot_nft_script, context)\n    (\n        _,\n        auth_nft_policy_id,\n        _,\n    ) = get_contract(module_name(parameter_auth_nft), True)\n\n    # Get payment address\n    payment_vkey, payment_skey, payment_address = get_signing_info(\n        wallet, network=network\n    )\n    combined_payment_address = combine_with_stake_key(payment_address, stake_key)\n\n    admin_vkey, admin_skey, admin_address = get_signing_info(\n        admin_wallet, network=network\n    )\n\n    combined_uada_address = combine_with_stake_key(uada_address, stake_key)\n    # find the uada staking position\n    uada_position_utxo = None\n    uada_position_datum = None\n    for utxo in context.utxos(combined_uada_address):\n        try:\n            uada_position_datum = uada.UAdaStakingPosition.from_cbor(\n                utxo.output.datum.cbor\n            )\n        except Exception:\n            continue\n        if uada_position_datum.policy_id != one_shot_nft_policy_id.payload:\n            continue\n        uada_position_utxo = utxo\n        break\n    assert uada_position_utxo is not None, \"No uada staking position found\"\n    amount = uada_position_utxo.output.amount.coin\n\n    payment_utxos = context.utxos(combined_payment_address)\n    # find the own input with the unique nft\n    unique_nft_utxo = None\n    for utxo in payment_utxos:\n        if utxo.output.amount.multi_asset.get(one_shot_nft_policy_id, {}).get(\n            pycardano.AssetName(uada_position_datum.token_name)\n        ):\n            unique_nft_utxo = utxo\n            break\n    assert unique_nft_utxo is not None, \"No unique nft found\"\n\n    all_utxos_sorted = sorted_utxos(payment_utxos + [uada_position_utxo])\n    unique_nft_input_index = all_utxos_sorted.index(unique_nft_utxo)\n    spending_redeemer = Redeemer(\n        uada.WithdrawUAdaStakingPosition(\n            unique_nft_input_index=unique_nft_input_index,\n        )\n    )\n\n    # find the fee parameters\n    param_utxo = None\n    auth_nft_datum = None\n    for utxo in context.utxos(admin_address):\n        if not utxo.output.amount.multi_asset.get(auth_nft_policy_id):\n            continue\n        try:\n            auth_nft_datum = uada.UAdaFeeParams.from_cbor(utxo.output.datum.cbor)\n        except Exception:\n            continue\n        param_utxo = utxo\n    assert auth_nft_datum is not None, \"No auth nft found\"\n    treasury_address = from_address(auth_nft_datum.treasury_address)\n    if isinstance(auth_nft_datum.treasury_out_datum, uada.NoOutputDatum):\n        treasury_out_datum = None\n        treasury_out_datum_hash = None\n    elif isinstance(auth_nft_datum.treasury_out_datum, uada.SomeOutputDatum):\n        treasury_out_datum = auth_nft_datum.treasury_out_datum.datum\n        treasury_out_datum_hash = pycardano.datum_hash(treasury_out_datum)\n    else:\n        treasury_out_datum = None\n        treasury_out_datum_hash = auth_nft_datum.treasury_out_datum.datum_hash\n    fee_min = auth_nft_datum.mint_fee_min\n    fee_percent = auth_nft_datum.mint_fee_percent\n    fee = uada.compute_fee(amount, fee_percent, fee_min)\n\n    all_ref_utxos_sorted = sorted_utxos(\n        [param_utxo]\n        + ([uada_ref_utxo] if uada_ref_utxo else [])\n        + ([one_shot_nft_ref_utxo] if one_shot_nft_ref_utxo else [])\n    )\n    param_utxo_index = all_ref_utxos_sorted.index(param_utxo)\n\n    uada_mint_redeemer = Redeemer(uada.Nothing())\n    uada_wdrl_redeemer = Redeemer(\n        uada.ContractInteractionRedeemer(\n            parameter_auth_nft_ref_utxo_index=param_utxo_index,\n            treasury_payout_tx_out_index=0,\n        )\n    )\n    one_shot_nft_mint_redeemer = Redeemer(-1)\n\n    uada_token = Token(\n        uada_policy_id.payload,\n        b\"uADA\",\n    )\n    unique_nft_token = Token(\n        uada_position_datum.policy_id,\n        uada_position_datum.token_name,\n    )\n\n    # Build the transaction\n    builder = TransactionBuilder(context)\n    builder.auxiliary_data = AuxiliaryData(\n        data=AlonzoMetadata(metadata=Metadata({674: {\"msg\": [\"Withdraw uADA\"]}}))\n    )\n    for u in payment_utxos:\n        builder.add_input(u)\n\n    builder.add_script_input(\n        uada_position_utxo,\n        uada_ref_utxo or uada_script,\n        None,\n        spending_redeemer,\n    )\n    builder.add_minting_script(\n        uada_ref_utxo or uada_script,\n        uada_mint_redeemer,\n    )\n    builder.add_minting_script(\n        one_shot_nft_ref_utxo or one_shot_nft_script,\n        one_shot_nft_mint_redeemer,\n    )\n    builder.mint = asset_from_token(uada_token, -amount) + asset_from_token(\n        unique_nft_token, -1\n    )\n    builder.reference_inputs.add(param_utxo)\n    if fee >= 1_000_000:\n        builder.add_output(\n            TransactionOutput(\n                address=treasury_address,\n                amount=Value(\n                    coin=fee,\n                ),\n                datum=treasury_out_datum,\n                datum_hash=treasury_out_datum_hash,\n            ),\n        )\n    builder.withdrawals = Withdrawals(\n        {\n            bytes(\n                pycardano.Address(\n                    staking_part=uada_address.payment_part, network=network\n                )\n            ): 0\n        }\n    )\n    builder.add_withdrawal_script(uada_ref_utxo or uada_script, uada_wdrl_redeemer)\n\n    # Sign the transaction\n    signed_tx = builder.build_and_sign(\n        signing_keys=[payment_skey],\n        change_address=combined_payment_address,\n    )\n\n    # Submit the transaction\n    context.submit_tx(signed_tx)\n\n    show_tx(signed_tx)\n\n\nif __name__ == \"__main__\":\n    fire.Fire(main)\n", "output": "This Cardano smart contract script is written in Python and is designed to handle the withdrawal of a specific token, referred to as \"uADA\", from a staking position. The script uses several libraries and modules, including `pycardano` for interacting with the Cardano blockchain, and `fire` for command-line interface generation. Here's a detailed breakdown of the code:\n\n### Imports\n\n- **Standard Libraries**: \n  - `datetime` is imported but not used in the script.\n  - `fire` is used to create a command-line interface for the script.\n\n- **Cardano Libraries**:\n  - `pycardano` is a library for interacting with the Cardano blockchain.\n  - `opshin.prelude` provides utility functions and classes for working with tokens.\n\n- **Custom Modules**:\n  - `uada.onchain` and `uada.utils` provide on-chain logic and utility functions specific to the uADA contract.\n  - `opsin.prelude` and `pycardano` are used for blockchain interactions and transaction building.\n\n### Main Function\n\nThe `main` function is the entry point of the script. It takes three parameters: `wallet`, `stake_key`, and `admin_wallet`, with default values provided.\n\n1. **Load Script Information**:\n   - The script retrieves contract information for `uada`, `one_shot_nft`, and `parameter_auth_nft` using the `get_contract` function. This includes the script itself, policy IDs, and addresses.\n   - Reference UTXOs (Unspent Transaction Outputs) for these contracts are also retrieved.\n\n2. **Get Payment and Admin Addresses**:\n   - The script retrieves the payment verification key, signing key, and address for both the user and the admin using `get_signing_info`.\n   - These addresses are combined with the stake key to form a combined address.\n\n3. **Find uADA Staking Position**:\n   - The script searches for a UTXO at the combined uADA address that contains a valid staking position datum. This datum is expected to match the `one_shot_nft_policy_id`.\n\n4. **Find Unique NFT**:\n   - The script searches for a UTXO in the user's payment address that contains the unique NFT associated with the staking position.\n\n5. **Retrieve Fee Parameters**:\n   - The script retrieves fee parameters from the admin's address, specifically looking for an authorization NFT. This includes the treasury address and fee details.\n\n6. **Calculate Fees**:\n   - The fee for withdrawing uADA is calculated based on the amount, a minimum fee, and a percentage fee.\n\n7. **Build the Transaction**:\n   - A `TransactionBuilder` is used to construct the transaction.\n   - Inputs are added from the user's UTXOs and the uADA staking position.\n   - Minting scripts are added to handle the burning of uADA and the unique NFT.\n   - Outputs are added for the treasury if the fee is above a certain threshold.\n   - Withdrawals are specified for the staking address.\n\n8. **Sign and Submit the Transaction**:\n   - The transaction is signed using the user's signing key.\n   - The signed transaction is submitted to the Cardano network.\n\n9. **Display Transaction**:\n   - The transaction is displayed using the `show_tx` function.\n\n### Command-Line Interface\n\nThe script uses the `fire` library to expose the `main` function as a command-line interface, allowing users to execute the script with different parameters.\n\n### Summary\n\nThis script is a comprehensive example of how to interact with the Cardano blockchain to manage a specific token's staking and withdrawal process. It involves retrieving contract and UTXO information, calculating fees, building a transaction, and submitting it to the network. The use of custom modules and utility functions suggests that this script is part of a larger framework for managing uADA tokens.", "file_path": "uada-contracts/uada/offchain/withdraw_uada.py", "file": "withdraw_uada.py"}
{"instruction": "Explain the following smart contract code:", "input": "module Main where\n\nimport Options.Applicative\n\nimport CLI.Parsers (parseCommand)\nimport CLI.Run\n\nmain :: IO ()\nmain = do\n  let preferences = prefs $ showHelpOnError <> showHelpOnEmpty\n      opts = info (parseCommand <**> helper) (fullDesc <> progDesc \"A fully p2p Cardano DEX\")\n  customExecParser preferences opts >>= runCommand\n", "output": "This Haskell code is the main entry point for a command-line application related to a Cardano decentralized exchange (DEX). Let's break down the code step by step:\n\n### Module Declaration\n\n```haskell\nmodule Main where\n```\n\nThis line declares the module name as `Main`. In Haskell, the `Main` module is special because it is the entry point of the program. When you compile and run a Haskell program, the `main` function within the `Main` module is executed.\n\n### Imports\n\n```haskell\nimport Options.Applicative\nimport CLI.Parsers (parseCommand)\nimport CLI.Run\n```\n\n- `Options.Applicative`: This is a Haskell library used for parsing command-line options. It provides utilities to define and process command-line arguments in a structured way.\n- `CLI.Parsers (parseCommand)`: This imports the `parseCommand` function from the `CLI.Parsers` module. This function is likely responsible for defining how command-line arguments are parsed.\n- `CLI.Run`: This module is imported entirely, suggesting it contains functions or definitions needed to execute the parsed commands.\n\n### Main Function\n\n```haskell\nmain :: IO ()\nmain = do\n  let preferences = prefs $ showHelpOnError <> showHelpOnEmpty\n      opts = info (parseCommand <**> helper) (fullDesc <> progDesc \"A fully p2p Cardano DEX\")\n  customExecParser preferences opts >>= runCommand\n```\n\n- `main :: IO ()`: This type signature indicates that `main` is an I/O action that returns no meaningful value (i.e., `()` is the unit type).\n\n- `do` block: This is a syntactic construct in Haskell that allows sequencing of I/O actions.\n\n- `preferences`: This is a local variable that sets preferences for the command-line parser. It uses `prefs` to configure:\n  - `showHelpOnError`: Automatically shows help text if there's an error in parsing the command-line arguments.\n  - `showHelpOnEmpty`: Shows help text if no arguments are provided.\n\n- `opts`: This variable defines the command-line options parser. It uses `info` to combine:\n  - `parseCommand <**> helper`: This expression combines the `parseCommand` parser with a helper function that automatically adds a `--help` option to the command-line interface.\n  - `fullDesc <> progDesc \"A fully p2p Cardano DEX\"`: This provides a full description of the program and a short program description. The description \"A fully p2p Cardano DEX\" is likely displayed when the user requests help.\n\n- `customExecParser preferences opts`: This function runs the command-line parser with the specified preferences and options. It returns the parsed command.\n\n- `>>= runCommand`: This is the bind operator (`>>=`) in Haskell, used for chaining monadic operations. It takes the result of `customExecParser` and passes it to `runCommand`, which is presumably a function that executes the parsed command.\n\n### Summary\n\nThis code sets up a command-line interface for a Cardano DEX application. It uses the `Options.Applicative` library to define and parse command-line arguments, providing helpful error messages and usage information. The parsed command is then executed by the `runCommand` function, which is likely defined in the `CLI.Run` module. The application is described as a \"fully p2p Cardano DEX,\" indicating its purpose as a decentralized exchange on the Cardano blockchain.", "file_path": "no-swaps/app/Main.hs", "file": "Main.hs"}
{"instruction": "Explain the following smart contract code:", "input": "import re\nfrom copy import copy\nfrom typing import Optional\nfrom enum import Enum\n\nfrom ..util import CompilingNodeTransformer\nfrom ..typed_ast import *\n\n\"\"\"\nReplaces empty lists with UPLC constants of empty lists\n\"\"\"\n\n\nclass RewriteEmptyLists(CompilingNodeTransformer):\n    step = \"Rewrite empty lists to uplc empty lists\"\n\n    def visit_List(self, node: TypedList):\n        if node.elts:\n            return node\n        return RawPlutoExpr(typ=node.typ, expr=empty_list(node.typ.typ.typ))\n\n    def visit_Constant(self, node: TypedConstant):\n        if node.value != []:\n            return node\n        return RawPlutoExpr(typ=node.typ, expr=empty_list(node.typ.typ.typ))\n", "output": "The provided code is a Python script that is part of a larger system for transforming and compiling smart contracts written in a high-level language into a lower-level representation suitable for execution on the Cardano blockchain. Specifically, this script is designed to optimize the representation of empty lists in the code by replacing them with a more efficient representation in the UPLC (Untyped Plutus Core) language, which is used by Cardano's smart contract platform.\n\nHere's a detailed breakdown of the code:\n\n### Imports\n\n- **re**: Regular expressions module, not used in this snippet but might be used elsewhere in the module.\n- **copy**: Provides the ability to create shallow copies of objects, not used in this snippet.\n- **Optional**: A type hint indicating that a variable can be of a specified type or `None`.\n- **Enum**: A module for creating enumerations, not used in this snippet.\n- **CompilingNodeTransformer**: A base class for transforming nodes in an abstract syntax tree (AST). This is likely a custom class defined elsewhere in the project.\n- **Typed AST components**: These are likely custom classes or functions (`TypedList`, `TypedConstant`, `RawPlutoExpr`, etc.) used to represent and manipulate the typed abstract syntax tree of the smart contract code.\n\n### Class: `RewriteEmptyLists`\n\nThis class inherits from `CompilingNodeTransformer`, indicating that it is designed to traverse and transform nodes in an AST.\n\n- **Purpose**: The class is specifically designed to replace empty lists in the AST with UPLC constants that represent empty lists. This is an optimization step to ensure that the compiled code is efficient and suitable for execution on the Cardano blockchain.\n\n- **Attribute `step`**: A string that describes the transformation step. This is likely used for logging or debugging purposes to indicate what transformation is being applied.\n\n#### Method: `visit_List`\n\n- **Parameters**: \n  - `node`: An instance of `TypedList`, representing a list node in the AST.\n\n- **Functionality**:\n  - The method checks if the list (`node.elts`) has any elements.\n  - If the list is not empty, it returns the node unchanged.\n  - If the list is empty, it returns a `RawPlutoExpr` object. This object represents an empty list in UPLC. The `typ` attribute of the node is preserved, and the `expr` is set to the result of `empty_list(node.typ.typ.typ)`, which is presumably a function that generates the UPLC representation of an empty list for the given type.\n\n#### Method: `visit_Constant`\n\n- **Parameters**:\n  - `node`: An instance of `TypedConstant`, representing a constant node in the AST.\n\n- **Functionality**:\n  - The method checks if the constant value (`node.value`) is an empty list.\n  - If the value is not an empty list, it returns the node unchanged.\n  - If the value is an empty list, it returns a `RawPlutoExpr` object, similar to the `visit_List` method, to represent the empty list in UPLC.\n\n### Summary\n\nThe `RewriteEmptyLists` class is a transformation utility that optimizes the representation of empty lists in the AST of a smart contract. By converting these empty lists into UPLC constants, the transformation ensures that the compiled smart contract code is more efficient and better suited for execution on the Cardano blockchain. This is part of a larger compilation and optimization process that prepares high-level smart contract code for deployment.", "file_path": "opshin/opshin/rewrite/rewrite_empty_lists.py", "file": "rewrite_empty_lists.py"}
{"instruction": "Explain the following smart contract code:", "input": "#!opshin\n\n\ndef fib(n: int) -> int:\n    if n == 0:\n        res = 0\n    elif n == 1:\n        res = 1\n    else:\n        res = fib(n - 1) + fib(n - 2)\n    return res\n\n\ndef validator(n: int) -> int:\n    return fib(n)\n", "output": "This Cardano smart contract code is written in a Python-like language called Opshin, which is used for writing smart contracts on the Cardano blockchain. The code defines a simple recursive function to calculate Fibonacci numbers and a validator function that uses this Fibonacci function. Let's break down the code:\n\n### Fibonacci Function\n\n```python\ndef fib(n: int) -> int:\n    if n == 0:\n        res = 0\n    elif n == 1:\n        res = 1\n    else:\n        res = fib(n - 1) + fib(n - 2)\n    return res\n```\n\n- **Function Definition**: The function `fib` takes an integer `n` as input and returns an integer. This function is designed to compute the nth Fibonacci number.\n  \n- **Base Cases**:\n  - If `n` is 0, the function returns 0. This is the first base case of the Fibonacci sequence.\n  - If `n` is 1, the function returns 1. This is the second base case of the Fibonacci sequence.\n\n- **Recursive Case**:\n  - For any other value of `n` (i.e., `n > 1`), the function calls itself recursively to compute the sum of the two preceding Fibonacci numbers: `fib(n - 1)` and `fib(n - 2)`.\n  - This recursive approach follows the mathematical definition of Fibonacci numbers: `F(n) = F(n-1) + F(n-2)` for `n > 1`.\n\n- **Return Statement**: The result of the computation is stored in the variable `res`, which is then returned.\n\n### Validator Function\n\n```python\ndef validator(n: int) -> int:\n    return fib(n)\n```\n\n- **Function Definition**: The `validator` function also takes an integer `n` as input and returns an integer.\n  \n- **Functionality**: This function simply calls the `fib` function with the input `n` and returns the result. Essentially, it acts as a wrapper around the `fib` function.\n\n### Purpose and Usage\n\n- **Purpose**: The primary purpose of this code is to compute Fibonacci numbers. The `validator` function is likely intended to be the entry point for the smart contract, which means it is the function that will be called when the contract is executed on the blockchain.\n\n- **Usage in Smart Contracts**: In the context of a Cardano smart contract, this code could be used to validate transactions or conditions based on Fibonacci numbers. However, due to the recursive nature of the `fib` function, it may not be efficient for large values of `n` because it can lead to a large number of recursive calls and potential stack overflow.\n\n### Considerations\n\n- **Efficiency**: Recursive Fibonacci calculations are not efficient for large `n` due to repeated calculations. An iterative approach or memoization could be used to improve performance.\n\n- **Smart Contract Limitations**: When deploying on a blockchain, computational resources are limited. Recursive functions can be costly in terms of execution time and resources, which is an important consideration for smart contract design.\n\nOverall, this code provides a basic implementation of a Fibonacci sequence calculator within a Cardano smart contract, demonstrating how recursive functions can be used in this context.", "file_path": "opshin/examples/fib_rec.py", "file": "fib_rec.py"}
{"instruction": "Explain the following smart contract code:", "input": "-- SPDX-License-Identifier: BUSL-1.1\n\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Indigo.Contracts.CDP.OnChain\n  ( validateCDPScript,\n    validateCDPCreatorScript,\n    cdpScriptAddress,\n    cdpScriptValidator,\n    mkIAssetPolicy,\n    untypedCDPScriptHash,\n    cdpCreatorScriptAddress,\n    cdpCreatorScriptValidator,\n    untypedCDPCreatorValidatorHash,\n    iAssetPolicy,\n    getIAssetInfo,\n    getIAssetPrice,\n    iAssetSymbol,\n    iAssetPolicyHash,\n    iAssetPolicyScriptCTL,\n    cdpCreatorScriptCTL,\n    cdpScriptCTL,\n    untypedIAssetPolicySymbol,\n  )\nwhere\n\nimport Indigo.Contracts.CDP.Common\nimport Indigo.Contracts.Governance.VersionRegistry.Common\n  ( validateUpgradeVersion,\n  )\nimport Indigo.Contracts.Helpers (getProtocolFeePercentage)\nimport Indigo.Contracts.Helpers qualified as ContractHelpers\nimport Indigo.Contracts.Oracle.Common\nimport Indigo.Data.Decimal (OnChainDecimal (..))\nimport Indigo.Utils.Helpers qualified as Helpers\nimport Indigo.Utils.Spooky qualified as Spooky\nimport Indigo.Utils.Spooky.Helpers qualified as Spooky.Helpers\nimport Ledger qualified\nimport Ledger.Ada qualified as Ada\nimport Ledger.Value qualified as V2\nimport Ledger.Value qualified as Value\nimport Plutus.Script.Utils.V2.Address qualified as Address\nimport Plutus.Script.Utils.V2.Scripts qualified as Scripts\nimport Plutus.Script.Utils.V2.Typed.Scripts.MonetaryPolicies\n  ( UntypedMintingPolicy,\n  )\nimport Plutus.Script.Utils.V2.Typed.Scripts.Validators\n  ( UntypedValidator,\n    mkUntypedValidator,\n  )\nimport Plutus.V2.Ledger.Api qualified as V2\nimport Plutus.V2.Ledger.Contexts qualified as Contexts\nimport PlutusTx qualified\nimport PlutusTx.Prelude hiding (fromInteger)\n\n{-# INLINEABLE getIAssetPrice #-}\ngetIAssetPrice :: OracleAssetNFT -> V2.TxInfo -> (Bool, OnChainDecimal)\ngetIAssetPrice (MkOracleAssetNFT oAssetNFT) info = (isExpired, odPrice)\n  where\n    oracleInput :: V2.TxOut\n    oracleInput = Helpers.findUniqueReferenceInputWithToken oAssetNFT info\n\n    MkOracleDatum {odPrice, odExpiration} =\n      Helpers.findInlinedDatumFromOutput oracleInput\n\n    isExpired :: Bool\n    isExpired =\n      Ledger.ivTo (V2.txInfoValidRange info) >= Ledger.upperBound odExpiration\n\n-- | This gets TxOut as a parameter since it can be also reference input.\n-- The caller decides what type of input it is.\n{-# INLINEABLE getIAssetInfo #-}\ngetIAssetInfo ::\n  V2.TxOut ->\n  (Value.TokenName, OnChainDecimal, Either OnChainDecimal OracleAssetNFT)\ngetIAssetInfo iAssetInput = (iaName, iaMinRatio, iaPrice)\n  where\n    IAssetDatum iAsset = Helpers.findInlinedDatumFromOutput iAssetInput\n\n    IAsset {iaName, iaMinRatio, iaPrice} = iAsset\n\n{-# INLINEABLE collateralAmount #-}\ncollateralAmount :: V2.TxOut -> Integer\ncollateralAmount = Ada.getLovelace . Ada.fromValue . V2.txOutValue\n\n{-# INLINEABLE validateCreate #-}\nvalidateCreate ::\n  CDPCreatorScriptParams ->\n  Ledger.PaymentPubKeyHash ->\n  Integer ->\n  Integer ->\n  V2.ScriptContext ->\n  Bool\nvalidateCreate CDPCreatorScriptParams {..} pkh minted collateral ctx =\n  traceIfFalse \"Mixed versions\" (iAssetValHash == cdpScriptHash)\n    && traceIfFalse\n      \"The transaction is not signed by cdp owner\"\n      (Contexts.txSignedBy info (Ledger.unPaymentPubKeyHash pkh))\n    && traceIfFalse\n      \"CDPCreatorNFT missing\"\n      ( Helpers.hasUnitValue\n          (Helpers.valueWithin $ Helpers.findOwnInput' ctx)\n          cdpCreatorNft\n      )\n    && traceIfFalse\n      \"CDPCreator output does not match\"\n      ( Helpers.checkOwnOutputAdaGeq @CDPCreatorDatum ctx () $\n          Helpers.unitValue cdpCreatorNft\n      )\n    && traceIfFalse\n      \"Minted value is invalid\"\n      ( V2.txInfoMint info\n          == Value.singleton cdpAssetCs iaName minted\n            <> Helpers.unitValue cdpAuthTk\n      )\n    && traceIfFalse\n      \"CDP output is invalid\"\n      ( Helpers.checkOutputFromOtherScriptsWithStakingCredential\n          info\n          cdpScriptHash\n          cdpDatum\n          cdpValue\n      )\n    && traceIfFalse\n      \"Undercollaterized CDP\"\n      (overCollaterized collateral minted iAssetPrice iaMinRatio)\n    && traceIfFalse \"Negative minted amount\" (minted >= 0)\n    && traceIfFalse\n      \"Must provide more than minCollateralInLovelace\"\n      (collateral >= minCollateralInLovelace)\n  where\n    info :: V2.TxInfo\n    info = V2.scriptContextTxInfo ctx\n\n    iAssetInput :: V2.TxOut\n    iAssetInput = Helpers.findUniqueReferenceInputWithToken iAssetAuthTk info\n\n    iAssetValHash :: Ledger.ValidatorHash\n    iAssetValHash = case Ledger.toValidatorHash (V2.txOutAddress iAssetInput) of\n      Just valHash -> valHash\n      Nothing -> traceError \"Could not get validator hash\"\n\n    iaName :: Value.TokenName\n    iaMinRatio :: OnChainDecimal\n    iaPrice :: Either OnChainDecimal OracleAssetNFT\n    (iaName, iaMinRatio, iaPrice) = getIAssetInfo iAssetInput\n\n    cdpValue :: Ledger.Value\n    cdpValue = Ada.lovelaceValueOf collateral <> Helpers.unitValue cdpAuthTk\n\n    cdpDatum :: CDPDatum\n    cdpDatum = CDP (Just pkh) iaName minted\n\n    iAssetPrice :: OnChainDecimal\n    iAssetPrice = case iaPrice of\n      Left _ -> traceError \"Cannot open a CDP of a delisted asset\"\n      Right oAssetNFT -> getPriceFromOracle $ getIAssetPrice oAssetNFT info\n\n    getPriceFromOracle :: (Bool, OnChainDecimal) -> OnChainDecimal\n    getPriceFromOracle (expired, price) =\n      if expired\n        then traceError \"Oracle cannot be expired\"\n        else price\n\n{-# INLINEABLE validateAdjustCDP #-}\nvalidateAdjustCDP ::\n  CDPScriptParams ->\n  Maybe Ledger.PaymentPubKeyHash ->\n  Value.TokenName ->\n  Integer ->\n  V2.ScriptContext ->\n  Bool\nvalidateAdjustCDP _ Nothing _ _ _ = traceError \"Cannot adjust frozen CDP\"\nvalidateAdjustCDP CDPScriptParams {..} (Just pk) asset ma ctx =\n  traceIfFalse \"Invalid input being validated\" (ownRef == cdpRef)\n    && traceIfFalse \"Mixed versions\" (iAssetValHash == Contexts.ownHash ctx)\n    && traceIfFalse\n      \"The transaction is not signed by cdp owner\"\n      (Contexts.txSignedBy info (Ledger.unPaymentPubKeyHash pk))\n    && traceIfFalse\n      \"Minted/Burnt value is invalid\"\n      ( V2.txInfoMint info\n          == Value.singleton cdpAssetSymbol asset mintedAmount\n      )\n    && traceIfFalse \"Incorrect iAsset input\" (iaName == asset)\n    && traceIfFalse\n      \"CDP output is incorrect\"\n      ( Helpers.checkOwnOutput @CDPDatum\n          ctx\n          (CDP (Just pk) asset (ma + mintedAmount))\n          ( Ada.lovelaceValueOf (collateralAmount cdpOutput)\n              <> Helpers.unitValue cdpAuthToken\n          )\n      )\n    -- We only need to check the collateralization of the CDP when\n    -- withdrawing collateral or minting iAssets.\n    && ( (mintedAmount <= 0 && inputCollateral <= outputCollateral)\n           || traceIfFalse\n             \"Undercollaterized CDP\"\n             ( overCollaterized\n                 (collateralAmount cdpOutput)\n                 (ma + mintedAmount)\n                 iAssetPrice\n                 iaMinRatio\n             )\n       )\n    && traceIfFalse \"Negative minted amount\" (ma + mintedAmount >= 0)\n    && traceIfFalse\n      \"Cannot mint delisted iAsset\"\n      (isRight iaPrice || mintedAmount <= 0)\n    && traceIfFalse\n      \"Must pay protocol fee correctly\"\n      (ContractHelpers.payProtocolFeeCorrectly collectorValHash info fee)\n    && traceIfFalse\n      \"Must provide more than minCollateralInLovelace\"\n      (outputCollateral >= minCollateralInLovelace)\n  where\n    info :: V2.TxInfo\n    info = V2.scriptContextTxInfo ctx\n\n    ownRef :: V2.TxOutRef\n    ownRef = case V2.scriptContextPurpose ctx of\n      Contexts.Spending ref -> ref\n      _ -> traceError \"Must spend UTxO\"\n\n    cdpRef :: V2.TxOutRef\n    cdpInput :: V2.TxOut\n    (cdpRef, cdpInput) = Helpers.findUniqueInputWithTokenRef cdpAuthToken info\n\n    cdpOutput :: V2.TxOut\n    cdpOutput = Helpers.findUniqueOutputFromCurrentScript cdpAuthToken ctx\n\n    outputCollateral :: Integer\n    outputCollateral = collateralAmount cdpOutput\n\n    inputCollateral :: Integer\n    inputCollateral = collateralAmount cdpInput\n\n    iAssetInput :: V2.TxOut\n    iAssetInput = Helpers.findUniqueReferenceInputWithToken iAssetAuthToken info\n\n    iAssetValHash :: Ledger.ValidatorHash\n    iAssetValHash = case Ledger.toValidatorHash (V2.txOutAddress iAssetInput) of\n      Just valHash -> valHash\n      Nothing -> traceError \"Could not get validator hash\"\n\n    iaName :: Value.TokenName\n    iaMinRatio :: OnChainDecimal\n    iaPrice :: Either OnChainDecimal OracleAssetNFT\n    (iaName, iaMinRatio, iaPrice) = getIAssetInfo iAssetInput\n\n    iAssetPrice :: OnChainDecimal\n    iAssetPrice = case iaPrice of\n      -- If delisted, pass the lastPrice.\n      Left lastPrice -> lastPrice\n      -- Additionally check if expired.\n      Right oAssetNFT -> getPriceFromOracle $ getIAssetPrice oAssetNFT info\n    getPriceFromOracle :: (Bool, OnChainDecimal) -> OnChainDecimal\n    getPriceFromOracle (expired, price) =\n      if expired\n        then traceError \"Oracle cannot be expired\"\n        else price\n\n    mintedAmount :: Integer\n    mintedAmount =\n      Value.assetClassValueOf\n        (V2.txInfoMint info)\n        (Value.assetClass cdpAssetSymbol asset)\n\n    protocolFeePercentage :: OnChainDecimal\n    protocolFeePercentage = getProtocolFeePercentage govNFT info\n\n    fee :: Integer\n    fee = protocolFee protocolFeePercentage inputCollateral outputCollateral\n\n{-# INLINEABLE validateCloseCDP #-}\nvalidateCloseCDP ::\n  CDPScriptParams ->\n  Maybe Ledger.PaymentPubKeyHash ->\n  Value.TokenName ->\n  Integer ->\n  V2.ScriptContext ->\n  Bool\nvalidateCloseCDP _ Nothing _ _ _ = traceError \"Cannot close frozen CDP\"\nvalidateCloseCDP CDPScriptParams {..} (Just pk) asset ma ctx =\n  traceIfFalse \"Invalid input being validated\" (ownRef == cdpRef)\n    && traceIfFalse \"Mixed versions\" (iAssetValHash == Contexts.ownHash ctx)\n    && traceIfFalse\n      \"The transaction is not signed by cdp owner\"\n      (Contexts.txSignedBy info (Ledger.unPaymentPubKeyHash pk))\n    && traceIfFalse\n      \"Burned value is invalid\"\n      ( V2.txInfoMint info\n          == negate (Helpers.unitValue cdpAuthToken)\n            <> Value.singleton cdpAssetSymbol asset (negate ma)\n      )\n    && traceIfFalse\n      \"Must pay protocol fee correctly\"\n      (ContractHelpers.payProtocolFeeCorrectly collectorValHash info fee)\n  where\n    info :: V2.TxInfo\n    info = V2.scriptContextTxInfo ctx\n\n    ownRef :: V2.TxOutRef\n    ownRef = case V2.scriptContextPurpose ctx of\n      Contexts.Spending ref -> ref\n      _ -> traceError \"Must spend UTxO\"\n\n    cdpRef :: V2.TxOutRef\n    cdpInput :: V2.TxOut\n    (cdpRef, cdpInput) = Helpers.findUniqueInputWithTokenRef cdpAuthToken info\n\n    protocolFeePercentage :: OnChainDecimal\n    protocolFeePercentage = getProtocolFeePercentage govNFT info\n\n    fee :: Integer\n    fee = protocolFee protocolFeePercentage (collateralAmount cdpInput) zero\n\n    iAssetInput :: V2.TxOut\n    iAssetInput = Helpers.findUniqueReferenceInputWithToken iAssetAuthToken info\n\n    iAssetValHash :: Ledger.ValidatorHash\n    iAssetValHash = case Ledger.toValidatorHash (V2.txOutAddress iAssetInput) of\n      Just valHash -> valHash\n      Nothing -> traceError \"Could not get validator hash\"\n\n{-# INLINEABLE validateLiquidateCDP #-}\nvalidateLiquidateCDP ::\n  CDPScriptParams ->\n  Maybe Ledger.PaymentPubKeyHash ->\n  Value.TokenName ->\n  Integer ->\n  V2.ScriptContext ->\n  Bool\nvalidateLiquidateCDP\n  CDPScriptParams\n    { stabilityPoolAuthToken,\n      cdpAuthToken,\n      cdpAssetSymbol,\n      spValHash\n    }\n  owner\n  asset\n  ma\n  ctx =\n    traceIfFalse \"Invalid input being validated\" (ownRef == cdpRef)\n      && traceIfFalse \"CDP needs to be frozen\" (isNothing owner)\n      && traceIfFalse \"More than one SP input\" (null $ tail spInputs)\n      && traceIfFalse\n        \"Wrong SP token\"\n        (Helpers.isAuthOutput stabilityPoolAuthToken spInput)\n      && ( if isPartialLiquidation\n             then\n               traceIfFalse\n                 \"CDP output is incorrect\"\n                 ( Helpers.checkOwnOutput @CDPDatum\n                     ctx\n                     (CDP owner asset (ma - burntIAsset))\n                     correctCdpContinuingValue\n                 )\n                 && traceIfFalse\n                   \"Stability pool output value is incorrect\"\n                   ( spOutputValue\n                       == spInputValue\n                         <> partialLiqSeizedValue\n                         <> burntIAssetVal\n                   )\n                 && traceIfFalse\n                   \"Expected burn all iAssets in SP\"\n                   ( txMint\n                       == negate\n                         ( Helpers.valueOfAssetCls'\n                             spInputValue\n                             cdpAssetSymbol\n                             asset\n                         )\n                   )\n             else\n               traceIfFalse\n                 \"Expected burn all cdp auth tokens in cdp input and all minted iAssets\"\n                 ( txMint\n                     == negate\n                       ( Helpers.valueOfAssetCls\n                           cdpInputValue\n                           cdpAuthToken\n                       )\n                       <> negate\n                         ( Value.singleton\n                             cdpAssetSymbol\n                             asset\n                             ma\n                         )\n                 )\n                 && traceIfFalse\n                   \"Stability pool output value is incorrect\"\n                   ( spOutputValue\n                       == spInputValue\n                         <> Value.adaOnlyValue cdpInputValue\n                         <> burntIAssetVal\n                   )\n         )\n    where\n      info :: V2.TxInfo\n      info = V2.scriptContextTxInfo ctx\n\n      ownRef :: V2.TxOutRef\n      ownRef = case V2.scriptContextPurpose ctx of\n        Contexts.Spending ref -> ref\n        _ -> traceError \"Must spend UTxO\"\n\n      cdpRef :: V2.TxOutRef\n      cdpInput :: V2.TxOut\n      (cdpRef, cdpInput) =\n        Helpers.findUniqueInputWithPositiveAmtOfTokensRef cdpAuthToken info\n\n      cdpInputValue :: Ledger.Value\n      cdpInputValue = V2.txOutValue cdpInput\n\n      spInputs :: [V2.TxOut]\n      spInputs = Helpers.findAllInputsFromScript spValHash info\n\n      spInput :: V2.TxOut\n      [spInput] = spInputs\n\n      spInputValue :: Ledger.Value\n      spInputValue = V2.txOutValue spInput\n\n      spOutput :: V2.TxOut\n      [spOutput] = Helpers.findAllOutputsToAddress spValHash info\n\n      spOutputValue :: Ledger.Value\n      spOutputValue = V2.txOutValue spOutput\n\n      txMint :: Ledger.Value\n      txMint = V2.txInfoMint info\n\n      mintedIAsset :: Integer\n      mintedIAsset = Value.valueOf txMint cdpAssetSymbol asset\n\n      burntIAsset :: Integer\n      burntIAsset = negate mintedIAsset\n\n      burntIAssetVal :: V2.Value\n      burntIAssetVal = Value.singleton cdpAssetSymbol asset mintedIAsset\n\n      isPartialLiquidation :: Bool\n      isPartialLiquidation = burntIAsset < ma\n\n      partialLiqSeizedValue :: V2.Value\n      partialLiqSeizedValue =\n        Ada.lovelaceValueOf $\n          (Helpers.lovelacesAmount cdpInputValue * burntIAsset) `divide` ma\n\n      correctCdpContinuingValue :: V2.Value\n      correctCdpContinuingValue = cdpInputValue <> negate partialLiqSeizedValue\n\n{-# INLINEABLE validateUpgradeIAsset #-}\nvalidateUpgradeIAsset :: Value.AssetClass -> V2.ScriptContext -> Bool\nvalidateUpgradeIAsset uToken ctx =\n  traceIfFalse\n    \"Spend exactly 1 Upgrade Token\"\n    (Helpers.isSpendingUnitValue info uToken)\n    && traceIfFalse\n      \"Burn the upgrade token and nothing else\"\n      (V2.txInfoMint info == inv (Helpers.unitValue uToken))\n  where\n    info :: V2.TxInfo\n    info = V2.scriptContextTxInfo ctx\n\n{-# INLINEABLE validateFreezeCDP #-}\nvalidateFreezeCDP ::\n  CDPScriptParams ->\n  Maybe Ledger.PaymentPubKeyHash ->\n  Ledger.TokenName ->\n  Integer ->\n  Contexts.ScriptContext ->\n  Bool\nvalidateFreezeCDP\n  CDPScriptParams {cdpAuthToken, iAssetAuthToken}\n  owner\n  asset\n  mintedAmount\n  ctx =\n    traceIfFalse \"Invalid input being validated\" (ownRef == cdpRef)\n      && traceIfFalse \"Mixed versions\" (iAssetValHash == Contexts.ownHash ctx)\n      && traceIfFalse \"CDP is already frozen\" (isJust owner)\n      && traceIfFalse \"Invalid iAsset input\" (iaName == asset)\n      && traceIfFalse \"Can not mint any token\" (V2.txInfoMint info == mempty)\n      && traceIfFalse\n        \"CDP still overcollaterized\"\n        ( not $\n            overCollaterized\n              (collateralAmount cdpInput)\n              mintedAmount\n              iAssetPrice\n              iaMinRatio\n        )\n      && traceIfFalse\n        \"CDP output is incorrect\"\n        ( Helpers.checkOwnOutputNoStaking @CDPDatum\n            ctx\n            CDP\n              { cdpOwner = Nothing,\n                cdpIAsset = asset,\n                cdpMintedAmount = mintedAmount\n              }\n            (V2.txOutValue cdpInput)\n        )\n    where\n      info :: V2.TxInfo\n      info = V2.scriptContextTxInfo ctx\n\n      iAssetInput :: V2.TxOut\n      iAssetInput =\n        Helpers.findUniqueReferenceInputWithToken iAssetAuthToken info\n\n      iAssetValHash :: Ledger.ValidatorHash\n      iAssetValHash =\n        case Ledger.toValidatorHash (V2.txOutAddress iAssetInput) of\n          Just valHash -> valHash\n          Nothing -> traceError \"Could not get validator hash\"\n\n      iaName :: Value.TokenName\n      iaMinRatio :: OnChainDecimal\n      iaPrice :: Either OnChainDecimal OracleAssetNFT\n      (iaName, iaMinRatio, iaPrice) = getIAssetInfo iAssetInput\n\n      ownRef :: V2.TxOutRef\n      ownRef = case V2.scriptContextPurpose ctx of\n        Contexts.Spending ref -> ref\n        _ -> traceError \"Must spend UTxO\"\n\n      iAssetPrice :: OnChainDecimal\n      iAssetPrice = case iaPrice of\n        -- iAsset is delisted, use the last oracle price.\n        Left p -> p\n        -- Oracle is active, we don't care if the Oracle is expired.\n        Right oAssetNFT -> snd $ getIAssetPrice oAssetNFT info\n\n      cdpRef :: V2.TxOutRef\n      cdpInput :: V2.TxOut\n      (cdpRef, cdpInput) = Helpers.findUniqueInputWithTokenRef cdpAuthToken info\n\n{-# INLINEABLE validateMergeCDPs #-}\nvalidateMergeCDPs ::\n  CDPScriptParams ->\n  V2.TokenName ->\n  Contexts.ScriptContext ->\n  Bool\nvalidateMergeCDPs CDPScriptParams {cdpAuthToken} asset ctx =\n  traceIfFalse \"Invalid input being validated\" (length currentCDPInput == 1)\n    && traceIfFalse\n      \"Needs at least 1 other CDP input\"\n      (not (null otherCDPInputs))\n    && traceIfFalse\n      \"All other CDP inputs are spent with MergeAuxiliary redeemer\"\n      ( all\n          ( \\input ->\n              Helpers.usesSpendRedeemer\n                info\n                (V2.txInInfoOutRef input)\n                (MergeAuxiliary ownRef)\n                && V2.txOutAddress (V2.txInInfoResolved input)\n                  == Ledger.scriptHashAddress ownValHash\n          )\n          otherCDPInputs\n      )\n    && traceIfFalse\n      \"All CDP inputs are frozen CDP positions with the same asset\"\n      ( all\n          (\\(owner, iAsset, _) -> isNothing owner && asset == iAsset)\n          cdpInputDatums\n      )\n    && traceIfFalse\n      \"A single output has total value from all input CDPs (inc. auth tokens)\"\n      (V2.txOutValue cdpOutput == totalCDPValue)\n    && traceIfFalse\n      \"Nothing minted/burnt\"\n      (V2.txInfoMint info == mempty)\n    && traceIfFalse\n      \"The merged CDP has correct datum\"\n      ( Helpers.hasExpectedInlinedDatum\n          cdpOutput\n          ( CDP\n              { cdpOwner = Nothing,\n                cdpIAsset = asset,\n                cdpMintedAmount = totalIAssetAmount\n              }\n          )\n      )\n  where\n    info :: V2.TxInfo\n    info = V2.scriptContextTxInfo ctx\n\n    ownRef :: V2.TxOutRef\n    ownRef = case V2.scriptContextPurpose ctx of\n      Contexts.Spending ref -> ref\n      _ -> traceError \"Must spend UTxO\"\n\n    ownValHash :: V2.ValidatorHash\n    ownValHash = Contexts.ownHash ctx\n\n    totalCDPValue :: Ledger.Value\n    totalCDPValue = foldMap V2.txOutValue allCDPInputs\n\n    totalIAssetAmount :: Integer\n    totalIAssetAmount =\n      foldr (\\(_, _, mintedAmount) !acc -> acc + mintedAmount) 0 cdpInputDatums\n\n    cdpInputDatums ::\n      [(Maybe Ledger.PaymentPubKeyHash, Value.TokenName, Integer)]\n    cdpInputDatums =\n      fmap\n        ( \\out -> case Helpers.findInlinedDatumFromOutput @CDPDatum out of\n            CDP {cdpOwner, cdpIAsset, cdpMintedAmount} ->\n              (cdpOwner, cdpIAsset, cdpMintedAmount)\n            _ -> traceError \"Wrong datum at CDP merge input\"\n        )\n        allCDPInputs\n\n    [cdpOutput] =\n      filter\n        (Helpers.hasPositiveValue cdpAuthToken . V2.txOutValue)\n        (Contexts.getContinuingOutputs ctx)\n\n    allCDPInputs :: [V2.TxOut]\n    allCDPInputs = V2.txInInfoResolved <$> allCDPInputs'\n\n    allCDPInputs' :: [V2.TxInInfo]\n    allCDPInputs' =\n      filter\n        ( Helpers.hasPositiveValue cdpAuthToken\n            . V2.txOutValue\n            . V2.txInInfoResolved\n        )\n        (V2.txInfoInputs info)\n\n    currentCDPInput :: [V2.TxInInfo]\n    otherCDPInputs :: [V2.TxInInfo]\n    (currentCDPInput, otherCDPInputs) =\n      partition (\\input -> V2.txInInfoOutRef input == ownRef) allCDPInputs'\n\n{-# INLINEABLE validateMergeAuxiliary #-}\nvalidateMergeAuxiliary :: V2.TxOutRef -> Contexts.ScriptContext -> Bool\nvalidateMergeAuxiliary mainMergeUtxo ctx =\n  traceIfFalse\n    \"The main merge UTXO is using MergeCDPs redeemer\"\n    (Helpers.usesSpendRedeemer info mainMergeUtxo MergeCDPs)\n    && traceIfFalse\n      \"merge UTXO comes from the same script\"\n      ( any\n          ( \\a ->\n              V2.txInInfoOutRef a == mainMergeUtxo\n                && (V2.txOutAddress . V2.txInInfoResolved) a\n                  == Ledger.scriptHashAddress ownValHash\n          )\n          (V2.txInfoInputs info)\n      )\n  where\n    info :: V2.TxInfo\n    info = V2.scriptContextTxInfo ctx\n\n    ownValHash :: V2.ValidatorHash\n    ownValHash = Contexts.ownHash ctx\n\n{-# INLINEABLE validateCDPScript #-}\nvalidateCDPScript ::\n  CDPScriptParams ->\n  CDPDatum ->\n  CDPRedeemer ->\n  V2.ScriptContext ->\n  Bool\nvalidateCDPScript param CDP {..} AdjustCDP ctx =\n  validateAdjustCDP param cdpOwner cdpIAsset cdpMintedAmount ctx\nvalidateCDPScript param CDP {..} CloseCDP ctx =\n  validateCloseCDP param cdpOwner cdpIAsset cdpMintedAmount ctx\nvalidateCDPScript param CDP {..} Liquidate ctx =\n  validateLiquidateCDP param cdpOwner cdpIAsset cdpMintedAmount ctx\nvalidateCDPScript param IAssetDatum {} UpgradeAsset ctx =\n  validateUpgradeIAsset (upgradeToken param) ctx\nvalidateCDPScript CDPScriptParams {versionRecordToken} _ UpgradeVersion ctx =\n  validateUpgradeVersion \"CDP\" ctx versionRecordToken\nvalidateCDPScript param CDP {..} FreezeCDP ctx =\n  validateFreezeCDP param cdpOwner cdpIAsset cdpMintedAmount ctx\nvalidateCDPScript param CDP {..} MergeCDPs ctx =\n  validateMergeCDPs param cdpIAsset ctx\nvalidateCDPScript _ CDP {} MergeAuxiliary {mainMergeUtxo} ctx =\n  validateMergeAuxiliary mainMergeUtxo ctx\nvalidateCDPScript _ _ _ _ = False\n\n{-# INLINEABLE validateCDPCreatorScript #-}\nvalidateCDPCreatorScript ::\n  CDPCreatorScriptParams ->\n  CDPCreatorDatum ->\n  CDPCreatorRedeemer ->\n  V2.ScriptContext ->\n  Bool\nvalidateCDPCreatorScript param _ (CreateCDP pkh minted collateral) ctx =\n  validateCreate param pkh minted collateral ctx\nvalidateCDPCreatorScript\n  CDPCreatorScriptParams {versionRecordToken}\n  _\n  UpgradeCreatorVersion\n  ctx =\n    validateUpgradeVersion \"CDPCreator\" ctx versionRecordToken\n\n-- | Minting Policy for minting/burning iAsset.\n{-# INLINEABLE mkIAssetPolicy #-}\nmkIAssetPolicy :: Spooky.AssetClass -> () -> Spooky.ScriptContext -> Bool\nmkIAssetPolicy cdpAuthToken _ ctx =\n  traceIfFalse\n    \"CDPToken missing\"\n    ( Spooky.Helpers.hasPositiveValue valueIn cdpAuthToken\n        || Spooky.Helpers.hasUnitValue valueOut cdpAuthToken\n    )\n  where\n    info = Spooky.scriptContextTxInfo ctx\n    valueIn = Spooky.valueSpent info\n    valueOut = Spooky.valueProduced info\n\ncdpScriptValidator :: CDPScriptParams -> V2.Validator\ncdpScriptValidator param =\n  V2.mkValidatorScript\n    (compiledValidateCDPScript `PlutusTx.applyCode` PlutusTx.liftCode param)\n\ncompiledValidateCDPScript ::\n  PlutusTx.CompiledCode (CDPScriptParams -> UntypedValidator)\ncompiledValidateCDPScript =\n  Helpers.optimizeUPLC\n    $$(PlutusTx.compile [||mkUntypedValidator . validateCDPScript||])\n\ncompiledUntypedValidateCDPScript ::\n  PlutusTx.CompiledCode (BuiltinData -> UntypedValidator)\ncompiledUntypedValidateCDPScript =\n  Helpers.optimizeUPLC\n    $$( PlutusTx.compile\n          [||\n          mkUntypedValidator\n            . validateCDPScript\n            . PlutusTx.unsafeFromBuiltinData\n          ||]\n      )\n\nuntypedCDPScriptValidator :: BuiltinData -> V2.Validator\nuntypedCDPScriptValidator params =\n  V2.mkValidatorScript\n    ( compiledUntypedValidateCDPScript\n        `PlutusTx.applyCode` PlutusTx.liftCode params\n    )\n\nuntypedCDPScriptHash :: BuiltinData -> V2.ValidatorHash\nuntypedCDPScriptHash = Scripts.validatorHash . untypedCDPScriptValidator\n\n-- serialised for use in CTL\ncdpScriptCTL :: V2.Script\ncdpScriptCTL = V2.fromCompiledCode compiledUntypedValidateCDPScript\n\ncdpScriptAddress :: CDPScriptParams -> Ledger.Address\ncdpScriptAddress = Address.mkValidatorAddress . cdpScriptValidator\n\ncdpCreatorScriptValidator :: CDPCreatorScriptParams -> V2.Validator\ncdpCreatorScriptValidator param =\n  V2.mkValidatorScript\n    ( compiledValidateCDPCreatorScript\n        `PlutusTx.applyCode` PlutusTx.liftCode param\n    )\n\ncompiledValidateCDPCreatorScript ::\n  PlutusTx.CompiledCode (CDPCreatorScriptParams -> UntypedValidator)\ncompiledValidateCDPCreatorScript =\n  Helpers.optimizeUPLC\n    $$( PlutusTx.compile\n          [||mkUntypedValidator . validateCDPCreatorScript||]\n      )\n\ncompiledUntypedValidateCDPCreatorScript ::\n  PlutusTx.CompiledCode (BuiltinData -> UntypedValidator)\ncompiledUntypedValidateCDPCreatorScript =\n  Helpers.optimizeUPLC\n    $$( PlutusTx.compile\n          [||\n          mkUntypedValidator\n            . validateCDPCreatorScript\n            . PlutusTx.unsafeFromBuiltinData\n          ||]\n      )\n\nuntypedCDPCreatorValidator :: BuiltinData -> V2.Validator\nuntypedCDPCreatorValidator params =\n  V2.mkValidatorScript\n    ( compiledUntypedValidateCDPCreatorScript\n        `PlutusTx.applyCode` PlutusTx.liftCode params\n    )\n\nuntypedCDPCreatorValidatorHash :: BuiltinData -> V2.ValidatorHash\nuntypedCDPCreatorValidatorHash = Scripts.validatorHash . untypedCDPCreatorValidator\n\n-- serialised for use in CTL\ncdpCreatorScriptCTL :: V2.Script\ncdpCreatorScriptCTL =\n  V2.fromCompiledCode compiledUntypedValidateCDPCreatorScript\n\ncdpCreatorScriptAddress :: CDPCreatorScriptParams -> Ledger.Address\ncdpCreatorScriptAddress = Address.mkValidatorAddress . cdpCreatorScriptValidator\n\niAssetPolicy :: Value.AssetClass -> V2.MintingPolicy\niAssetPolicy param =\n  V2.mkMintingPolicyScript\n    ( compiledMintIAsset\n        `PlutusTx.applyCode` PlutusTx.liftCode (Spooky.toSpookyAssetClass param)\n    )\n\ncompiledMintIAsset ::\n  PlutusTx.CompiledCode\n    (Spooky.AssetClass -> UntypedMintingPolicy)\ncompiledMintIAsset =\n  Helpers.optimizeUPLC\n    $$(PlutusTx.compile [||Spooky.mkUntypedMintingPolicy . mkIAssetPolicy||])\n\ncompiledUntypedMintIAsset ::\n  PlutusTx.CompiledCode (BuiltinData -> UntypedMintingPolicy)\ncompiledUntypedMintIAsset =\n  Helpers.optimizeUPLC\n    $$( PlutusTx.compile\n          [||\n          Spooky.mkUntypedMintingPolicy\n            . mkIAssetPolicy\n            . PlutusTx.unsafeFromBuiltinData\n          ||]\n      )\n\nuntypedIAssetMintPolicy :: BuiltinData -> V2.MintingPolicy\nuntypedIAssetMintPolicy params =\n  V2.mkMintingPolicyScript\n    ( compiledUntypedMintIAsset\n        `PlutusTx.applyCode` PlutusTx.liftCode params\n    )\n\nuntypedIAssetPolicyHash :: BuiltinData -> V2.MintingPolicyHash\nuntypedIAssetPolicyHash = Scripts.mintingPolicyHash . untypedIAssetMintPolicy\n\nuntypedIAssetPolicySymbol :: BuiltinData -> Value.CurrencySymbol\nuntypedIAssetPolicySymbol = Value.mpsSymbol . untypedIAssetPolicyHash\n\n-- serialised for use in CTL\niAssetPolicyScriptCTL :: V2.Script\niAssetPolicyScriptCTL = V2.fromCompiledCode compiledUntypedMintIAsset\n\niAssetPolicyHash :: Value.AssetClass -> Spooky.MintingPolicyHash\niAssetPolicyHash = Spooky.mintingPolicyHash . iAssetPolicy\n\niAssetSymbol :: Value.AssetClass -> Value.CurrencySymbol\niAssetSymbol =\n  Spooky.unSpookyCurrencySymbol . Spooky.mpsSymbol . iAssetPolicyHash\n", "output": "The provided code is a Haskell module for Cardano smart contracts, specifically for managing Collateralized Debt Positions (CDPs) within the Indigo protocol. This module defines various functions and scripts for validating and managing CDPs, creating and managing iAssets, and handling upgrades and liquidations. Let's break down the key components and functionality of this module:\n\n### Module and Imports\n\n- **Module Declaration**: The module is named `Indigo.Contracts.CDP.OnChain` and exports several functions and scripts related to CDPs and iAssets.\n- **Imports**: The module imports various utilities and helpers from the Indigo protocol, Plutus libraries, and Ledger libraries. These imports provide necessary functions and types for working with Cardano's extended UTXO model and Plutus smart contracts.\n\n### Key Functions and Scripts\n\n1. **`getIAssetPrice`**: This function retrieves the price of an iAsset from an oracle. It checks if the oracle data is expired and returns the price along with an expiration flag.\n\n2. **`getIAssetInfo`**: This function extracts information about an iAsset from a transaction output, including its name, minimum collateralization ratio, and price.\n\n3. **`collateralAmount`**: This function calculates the amount of collateral in a transaction output by extracting the Lovelace (ADA) value.\n\n4. **`validateCreate`**: This function validates the creation of a new CDP. It checks various conditions such as the transaction being signed by the CDP owner, the presence of necessary tokens, and the collateralization ratio.\n\n5. **`validateAdjustCDP`**: This function validates adjustments to an existing CDP, such as adding or removing collateral or minting/burning iAssets. It ensures the transaction maintains the required collateralization ratio and pays any necessary protocol fees.\n\n6. **`validateCloseCDP`**: This function validates the closure of a CDP, ensuring that the correct amount of iAssets is burned and protocol fees are paid.\n\n7. **`validateLiquidateCDP`**: This function handles the liquidation of undercollateralized CDPs. It checks conditions for partial or full liquidation and updates the stability pool accordingly.\n\n8. **`validateUpgradeIAsset`**: This function validates the upgrade of an iAsset, ensuring that the correct upgrade token is spent and burned.\n\n9. **`validateFreezeCDP`**: This function freezes a CDP, preventing further adjustments if it becomes undercollateralized.\n\n10. **`validateMergeCDPs`**: This function allows merging multiple CDPs into one, ensuring that all inputs are correctly validated and combined.\n\n11. **`validateMergeAuxiliary`**: This function supports the merging of CDPs by validating auxiliary inputs.\n\n12. **`validateCDPScript`**: This is the main validation function for CDP scripts, delegating to specific validation functions based on the redeemer provided.\n\n13. **`validateCDPCreatorScript`**: This function validates actions related to the creation of CDPs, such as minting new iAssets.\n\n14. **`mkIAssetPolicy`**: This function defines a minting policy for iAssets, ensuring that the necessary CDP tokens are present during minting or burning.\n\n15. **Script Compilation and Address Generation**: The module includes functions to compile the validator and minting scripts into Plutus scripts, generate their hashes, and derive their corresponding Cardano addresses.\n\n### Summary\n\nThis module is a comprehensive implementation of the on-chain logic for managing CDPs and iAssets within the Indigo protocol on Cardano. It includes functions for creating, adjusting, closing, liquidating, and merging CDPs, as well as handling iAsset minting and upgrades. The module ensures that all operations adhere to the protocol's rules, such as maintaining collateralization ratios and paying protocol fees. The use of Plutus and Ledger libraries allows these smart contracts to interact with Cardano's blockchain, leveraging its extended UTXO model for secure and efficient financial operations.", "file_path": "indigo-smart-contracts/src/Indigo/Contracts/CDP/OnChain.hs", "file": "OnChain.hs"}
{"instruction": "Explain the following smart contract code:", "input": "-- SPDX-License-Identifier: BUSL-1.1\n\n{-# LANGUAGE NamedFieldPuns #-}\n{-# LANGUAGE RecordWildCards #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Indigo.Contracts.StabilityPool.OnChain\n  ( validateStabilityPool,\n    stabilityPoolValidator,\n    stabilityPoolAddress,\n    stabilityPoolScriptCTL,\n    untypedStabilityPoolValidatorHash,\n  )\nwhere\n\nimport Indigo.Contracts.CDP.Common (CDPDatum (CDP), cdpIAsset, protocolFee)\nimport Indigo.Contracts.CDP.Common qualified as CDP\nimport Indigo.Contracts.Governance.VersionRegistry.Common\n  ( validateUpgradeVersion,\n  )\nimport Indigo.Contracts.Helpers as ContractHelpers\nimport Indigo.Contracts.StabilityPool.Common\nimport Indigo.Data.Decimal (OnChainDecimal)\nimport Indigo.Utils.Helpers qualified as Helpers\nimport Ledger qualified\nimport Ledger.Ada qualified as Ada\nimport Ledger.Value qualified as Value\nimport Plutus.Script.Utils.V2.Address qualified as Address\nimport Plutus.Script.Utils.V2.Scripts qualified as Scripts\nimport Plutus.Script.Utils.V2.Typed.Scripts.Validators\n  ( UntypedValidator,\n    mkUntypedValidator,\n  )\nimport Plutus.V2.Ledger.Api qualified as V2\nimport Plutus.V2.Ledger.Contexts qualified as Contexts\nimport PlutusTx qualified\nimport PlutusTx.AssocMap qualified as AssocMap\nimport PlutusTx.Prelude hiding (scale)\n\nstabilityPoolValidator :: StabilityPoolParams -> V2.Validator\nstabilityPoolValidator param =\n  V2.mkValidatorScript\n    (compiledValidateSP `PlutusTx.applyCode` PlutusTx.liftCode param)\n\ncompiledValidateSP ::\n  PlutusTx.CompiledCode (StabilityPoolParams -> UntypedValidator)\ncompiledValidateSP =\n  Helpers.optimizeUPLC\n    $$(PlutusTx.compile [||mkUntypedValidator . validateStabilityPool||])\n\ncompiledUntypedValidateSP ::\n  PlutusTx.CompiledCode (BuiltinData -> UntypedValidator)\ncompiledUntypedValidateSP =\n  Helpers.optimizeUPLC\n    $$( PlutusTx.compile\n          [||\n          mkUntypedValidator\n            . validateStabilityPool\n            . PlutusTx.unsafeFromBuiltinData\n          ||]\n      )\n\nuntypedStabilityPoolValidator :: BuiltinData -> V2.Validator\nuntypedStabilityPoolValidator params =\n  V2.mkValidatorScript\n    ( compiledUntypedValidateSP\n        `PlutusTx.applyCode` PlutusTx.liftCode params\n    )\n\nuntypedStabilityPoolValidatorHash :: BuiltinData -> V2.ValidatorHash\nuntypedStabilityPoolValidatorHash = Scripts.validatorHash . untypedStabilityPoolValidator\n\n-- serialised for use in CTL\nstabilityPoolScriptCTL :: V2.Script\nstabilityPoolScriptCTL = V2.fromCompiledCode compiledUntypedValidateSP\n\n{-# INLINEABLE validateStabilityPool #-}\nvalidateStabilityPool ::\n  StabilityPoolParams ->\n  StabilityDatum ->\n  StabilityPoolRedeemer ->\n  V2.ScriptContext ->\n  Bool\nvalidateStabilityPool params StabilityPoolDatum {..} CreateAccount {..} ctx =\n  validateCreateAccount\n    params\n    spIAsset\n    spSnapshot\n    epochToScaleToSum\n    caPkh\n    caAmount\n    ctx\nvalidateStabilityPool params StabilityPoolDatum {..} AdjustAccount {aaDepositChange} ctx =\n  validateAdjustAccount\n    params\n    spIAsset\n    spSnapshot\n    epochToScaleToSum\n    aaDepositChange\n    ctx\nvalidateStabilityPool params StabilityPoolDatum {..} LiquidateCDP ctx =\n  validateLiquidateCDP params spIAsset spSnapshot epochToScaleToSum ctx\nvalidateStabilityPool params StabilityPoolDatum {..} Close ctx =\n  validateClose params spIAsset spSnapshot epochToScaleToSum ctx\nvalidateStabilityPool\n  params\n  StabilityPoolDatum {..}\n  RecordEpochToScaleToSum\n  ctx =\n    validateRecordEpochToScaleToSum\n      params\n      spIAsset\n      spSnapshot\n      epochToScaleToSum\n      ctx\nvalidateStabilityPool params AccountDatum {} SpendAccount ctx =\n  validateSpendAccount (stabilityPoolToken params) ctx\nvalidateStabilityPool\n  StabilityPoolParams {versionRecordToken}\n  _\n  UpgradeVersion\n  ctx =\n    validateUpgradeVersion \"StabilityPool\" ctx versionRecordToken\nvalidateStabilityPool _ _ _ _ = False\n\n{-# INLINEABLE validateRecordEpochToScaleToSum #-}\nvalidateRecordEpochToScaleToSum ::\n  StabilityPoolParams ->\n  Ledger.TokenName ->\n  StabilityPoolSnapshot ->\n  EpochToScaleToSum ->\n  V2.ScriptContext ->\n  Bool\nvalidateRecordEpochToScaleToSum\n  StabilityPoolParams {stabilityPoolToken, snapshotEpochToScaleToSumToken}\n  asset\n  snapshot\n  epochToScaleToSum\n  ctx =\n    traceIfFalse \"Invalid input being validated\" (ownRef == poolRef)\n      && traceIfFalse\n        \"Correct SP output\"\n        ( Helpers.checkOwnOutput @StabilityDatum\n            ctx\n            ( StabilityPoolDatum\n                { spIAsset = asset,\n                  spSnapshot = snapshot,\n                  epochToScaleToSum = AssocMap.fromList [remainingMapItem]\n                }\n            )\n            (V2.txOutValue poolInput)\n        )\n      && traceIfFalse\n        \"Mints a single epochToScaleToSum token\"\n        ( V2.txInfoMint info\n            == Helpers.unitValue snapshotEpochToScaleToSumToken\n        )\n      && traceIfFalse\n        \"Correct snapshot epochToScaleToSum output\"\n        ( Helpers.checkOwnOutput @StabilityDatum\n            ctx\n            ( SnapshotEpochToScaleToSumDatum\n                { sessSnapshot = AssocMap.fromList snapshotMapItems,\n                  sessAsset = asset\n                }\n            )\n            (Helpers.unitValue snapshotEpochToScaleToSumToken)\n        )\n      && traceIfFalse \"snapshot map is not empty\" (not (null snapshotMapItems))\n    where\n      info :: V2.TxInfo\n      info = V2.scriptContextTxInfo ctx\n\n      ownRef :: V2.TxOutRef\n      ownRef = case V2.scriptContextPurpose ctx of\n        Contexts.Spending ref -> ref\n        _ -> traceError \"Must spend UTxO\"\n\n      (remainingMapItem, snapshotMapItems) =\n        partitionEpochToScaleToSumMap snapshot epochToScaleToSum\n\n      poolRef :: V2.TxOutRef\n      poolInput :: V2.TxOut\n      (poolRef, poolInput) =\n        Helpers.findUniqueInputWithTokenRef stabilityPoolToken info\n\n{-# INLINEABLE validateSpendAccount #-}\nvalidateSpendAccount :: Ledger.AssetClass -> V2.ScriptContext -> Bool\nvalidateSpendAccount spToken ctx =\n  traceIfFalse \"Mixed versions\" (spValHash == Contexts.ownHash ctx)\n    && traceIfFalse\n      \"Must consume Stability Pool correctly\"\n      ( case Helpers.spendRedeemer info spInputRef of\n          AdjustAccount _ -> True\n          Close -> True\n          _ -> False\n      )\n  where\n    info :: V2.TxInfo\n    info = V2.scriptContextTxInfo ctx\n\n    spInputRef :: V2.TxOutRef\n    spInput :: V2.TxOut\n    (spInputRef, spInput) = Helpers.findUniqueInputWithTokenRef spToken info\n\n    spValHash :: Ledger.ValidatorHash\n    spValHash = case Ledger.toValidatorHash (V2.txOutAddress spInput) of\n      Just valHash -> valHash\n      Nothing -> traceError \"Could not get validator hash\"\n\n{-# INLINEABLE validateLiquidateCDP #-}\nvalidateLiquidateCDP ::\n  StabilityPoolParams ->\n  Ledger.TokenName ->\n  StabilityPoolSnapshot ->\n  EpochToScaleToSum ->\n  V2.ScriptContext ->\n  Bool\nvalidateLiquidateCDP\n  StabilityPoolParams {..}\n  asset\n  snapshot\n  epochToScaleToSum\n  ctx =\n    -- This check prevents protocol blockade for SP actions.\n    -- EpochToScaleToSum snapshot needs to be created to process further.\n    traceIfFalse\n      \"EpochToScaleToSum map is too large, use RecordEpochToScaleToSum\"\n      (length (AssocMap.toList epochToScaleToSum) <= 5)\n      && traceIfFalse\n        \"iAsset of stability pool must match iAsset of cdp\"\n        (asset == cdpIAsset)\n      && traceIfFalse\n        \"CDP input must be liquidated\"\n        (Helpers.usesSpendRedeemer info cdpRef CDP.Liquidate)\n      && traceIfFalse\n        \"StabilityPool output missing\"\n        (Helpers.hasUnitValue spInputValue stabilityPoolToken)\n      && traceIfFalse\n        \"Incorrect Stability Pool Output\"\n        ( Helpers.checkOutputDatum\n            (StabilityPoolDatum asset poolSnapshot newEpochToScaleToSum)\n            spOutput\n        )\n    where\n      info :: V2.TxInfo\n      info = V2.scriptContextTxInfo ctx\n\n      spInputValue :: Ledger.Value\n      spInputValue = Helpers.valueWithin $ Helpers.findOwnInput' ctx\n\n      spOutput :: V2.TxOut\n      [spOutput] = Contexts.getContinuingOutputs ctx\n\n      spOutputValue :: Ledger.Value\n      spOutputValue = V2.txOutValue spOutput\n\n      cdpInput :: V2.TxOut\n      cdpRef :: V2.TxOutRef\n      (cdpRef, cdpInput) =\n        Helpers.findUniqueInputWithPositiveAmtOfTokensRef cdpToken info\n\n      CDP {cdpIAsset} = Helpers.findInlinedDatumFromOutput cdpInput\n\n      assetBurn :: Integer\n      assetBurn = negate $ Value.valueOf (V2.txInfoMint info) assetSymbol asset\n\n      collateralAmount :: Integer\n      collateralAmount =\n        Helpers.lovelacesAmount spOutputValue\n          - Helpers.lovelacesAmount spInputValue\n\n      poolSnapshot :: StabilityPoolSnapshot\n      newEpochToScaleToSum :: EpochToScaleToSum\n      (poolSnapshot, newEpochToScaleToSum) =\n        liquidateHelper snapshot epochToScaleToSum assetBurn collateralAmount\n\n{-# INLINEABLE validateClose #-}\nvalidateClose ::\n  StabilityPoolParams ->\n  Ledger.TokenName ->\n  StabilityPoolSnapshot ->\n  EpochToScaleToSum ->\n  V2.ScriptContext ->\n  Bool\nvalidateClose\n  params@StabilityPoolParams {..}\n  asset\n  snapshot\n  epochToScaleToSum\n  ctx =\n    traceIfFalse \"Invalid input being validated\" (ownRef == poolRef)\n      && traceIfFalse\n        \"Wrong signature\"\n        (Contexts.txSignedBy info (Ledger.unPaymentPubKeyHash pk))\n      && traceIfFalse \"The asset does not match\" (asset == aAsset)\n      && traceIfFalse\n        \"Must burn the account token\"\n        (V2.txInfoMint info == Value.assetClassValue accountToken (-1))\n      && traceIfFalse\n        \"Expected to consume exactly one Account output\"\n        (Helpers.isSpendingUnitValue info accountToken)\n      && traceIfFalse\n        \"Stability Pool output does not match\"\n        ( Helpers.checkOwnOutput\n            ctx\n            (StabilityPoolDatum asset poolSnapshot epochToScaleToSum)\n            $ poolValue\n              <> Ada.lovelaceValueOf (negate reward)\n              <> V2.singleton assetSymbol asset (negate . fromSPInteger $ fund)\n        )\n      && traceIfFalse\n        \"Must pay protocol fee correctly\"\n        (ContractHelpers.payProtocolFeeCorrectly collectorValHash info fee)\n    where\n      info :: V2.TxInfo\n      info = V2.scriptContextTxInfo ctx\n\n      StabilityPoolSnapshot p d s snapshotEpoch snapshotScale = snapshot\n\n      AccountDatum pk aAsset aSnapshot =\n        Helpers.findInlinedDatumFromOutput\n          (Helpers.findUniqueInputWithToken accountToken info)\n\n      reward :: Integer\n      fund :: SPInteger\n      (fund, reward) =\n        case fromAdjustHelper of\n          (adjustedSnap, Just rew) -> (snapshotD adjustedSnap, rew)\n          (_, Nothing) -> traceError \"EpochToScaleToSum map missing item\"\n        where\n          fromAdjustHelper =\n            adjustAccountHelper\n              snapshot\n              aSnapshot\n              ( accumulatedEpochToScaleToSum\n                  params\n                  asset\n                  epochToScaleToSum\n                  info\n              )\n\n      protocolFeePercentage :: OnChainDecimal\n      protocolFeePercentage = getProtocolFeePercentage govNFT info\n\n      fee :: Integer\n      fee = protocolFee protocolFeePercentage reward 0\n\n      poolSnapshot :: StabilityPoolSnapshot\n      poolSnapshot =\n        StabilityPoolSnapshot p (spTruncate (d |-| fund)) s snapshotEpoch snapshotScale\n\n      ownRef :: V2.TxOutRef\n      ownRef = case V2.scriptContextPurpose ctx of\n        Contexts.Spending ref -> ref\n        _ -> traceError \"Must spend UTxO\"\n\n      poolRef :: V2.TxOutRef\n      poolInput :: V2.TxOut\n      (poolRef, poolInput) =\n        Helpers.findUniqueInputWithTokenRef stabilityPoolToken info\n\n      poolValue :: Ledger.Value\n      poolValue = V2.txOutValue poolInput\n\n{-# INLINEABLE validateAdjustAccount #-}\nvalidateAdjustAccount ::\n  StabilityPoolParams ->\n  Ledger.TokenName ->\n  StabilityPoolSnapshot ->\n  EpochToScaleToSum ->\n  Integer ->\n  V2.ScriptContext ->\n  Bool\nvalidateAdjustAccount\n  params@StabilityPoolParams {..}\n  asset\n  snapshot\n  epochToScaleToSum\n  depositChange\n  ctx =\n    traceIfFalse \"Invalid input being validated\" (ownRef == poolRef)\n      && traceIfFalse\n        \"Wrong signature\"\n        (Contexts.txSignedBy info (Ledger.unPaymentPubKeyHash pk))\n      && traceIfFalse \"The asset does not match\" (asset == aAsset)\n      && traceIfFalse\n        \"User cannot have negative balance\"\n        (fromSPInteger (snapshotD newAccountSnapshot) >= 0)\n      && traceIfFalse \"Cannot mint any token\" (V2.txInfoMint info == mempty)\n      && traceIfFalse\n        \"Expected to consume exactly one Account output\"\n        (Helpers.isSpendingUnitValue info accountToken)\n      && traceIfFalse\n        \"Stability Pool output does not match\"\n        ( Helpers.checkOwnOutput\n            ctx\n            (StabilityPoolDatum asset newPoolSnapshot newEpochToScaleToSum)\n            $ poolValue\n              <> Ada.lovelaceValueOf (negate reward)\n              <> V2.singleton assetSymbol asset depositChange\n              <> Ada.lovelaceValueOf accountAdjustmentFeeLovelaces\n        )\n      && traceIfFalse\n        \"Account output does not match\"\n        ( Helpers.checkOwnOutputAdaGeq\n            ctx\n            (AccountDatum pk asset newAccountSnapshot)\n            (Helpers.unitValue accountToken)\n        )\n      && traceIfFalse\n        \"Must pay protocol fee correctly\"\n        (ContractHelpers.payProtocolFeeCorrectly collectorValHash info fee)\n    where\n      info :: V2.TxInfo\n      info = V2.scriptContextTxInfo ctx\n\n      AccountDatum pk aAsset accountSnapshot =\n        Helpers.findInlinedDatumFromOutput\n          (Helpers.findUniqueInputWithToken accountToken info)\n\n      reward :: Integer\n      adjustedAccount :: StabilityPoolSnapshot\n      (adjustedAccount, reward) =\n        case adjustAccountHelper\n          snapshot\n          accountSnapshot\n          ( accumulatedEpochToScaleToSum\n              params\n              asset\n              epochToScaleToSum\n              info\n          ) of\n          (adjustedSnap, Just rew) -> (adjustedSnap, rew)\n          (_, Nothing) -> traceError \"EpochToScaleToSum map missing item\"\n\n      protocolFeePercentage :: OnChainDecimal\n      protocolFeePercentage = getProtocolFeePercentage govNFT info\n\n      fee :: Integer\n      fee = protocolFee protocolFeePercentage reward 0\n\n      newEpochToScaleToSum :: EpochToScaleToSum\n      newEpochToScaleToSum =\n        AssocMap.insert\n          (snapshotEpoch snapshot, snapshotScale snapshot)\n          (snapshotS newPoolSnapshot)\n          epochToScaleToSum\n\n      newDeposit :: SPInteger\n      newDeposit = spTruncate (snapshotD snapshot |+| toSPInteger depositChange)\n\n      newPoolSnapshot :: StabilityPoolSnapshot\n      newPoolSnapshot =\n        snapshot\n          { snapshotD = newDeposit,\n            snapshotS =\n              snapshotS snapshot\n                |+| ( (toSPInteger accountAdjustmentFeeLovelaces |*| snapshotP snapshot)\n                        |/| newDeposit\n                    )\n          }\n\n      newAccountSnapshot :: StabilityPoolSnapshot\n      newAccountSnapshot =\n        adjustedAccount\n          { snapshotD = snapshotD adjustedAccount |+| toSPInteger depositChange\n          }\n\n      ownRef :: V2.TxOutRef\n      ownRef = case V2.scriptContextPurpose ctx of\n        Contexts.Spending ref -> ref\n        _ -> traceError \"Must spend UTxO\"\n\n      poolRef :: V2.TxOutRef\n      poolInput :: V2.TxOut\n      (poolRef, poolInput) =\n        Helpers.findUniqueInputWithTokenRef stabilityPoolToken info\n\n      poolValue :: Ledger.Value\n      poolValue = V2.txOutValue poolInput\n\n{-# INLINEABLE accumulatedEpochToScaleToSum #-}\naccumulatedEpochToScaleToSum ::\n  StabilityPoolParams ->\n  Value.TokenName ->\n  EpochToScaleToSum ->\n  V2.TxInfo ->\n  EpochToScaleToSum\naccumulatedEpochToScaleToSum\n  StabilityPoolParams {snapshotEpochToScaleToSumToken}\n  asset\n  epochToScaleToSum\n  info =\n    if all (\\a -> snd a == asset) snapshotEpochToScaleToSumInputDatums\n      then\n        let refInputsAllItems =\n              mconcat\n                ( map\n                    (AssocMap.toList . fst)\n                    snapshotEpochToScaleToSumInputDatums\n                )\n         in AssocMap.fromList\n              (refInputsAllItems ++ AssocMap.toList epochToScaleToSum)\n      else traceError \"EpochToScaleToSum ref inputs have wrong asset\"\n    where\n      snapshotEpochToScaleToSumInputDatums ::\n        [(EpochToScaleToSum, Value.TokenName)]\n      snapshotEpochToScaleToSumInputDatums =\n        map\n          extractSnapshotAndAssess\n          (filter predicate (V2.txInfoReferenceInputs info))\n        where\n          predicate =\n            Helpers.isAuthOutput snapshotEpochToScaleToSumToken\n              . V2.txInInfoResolved\n          extractSnapshotAndAssess inp =\n            let SnapshotEpochToScaleToSumDatum {sessSnapshot, sessAsset} =\n                  Helpers.findInlinedDatumFromOutput (V2.txInInfoResolved inp)\n             in (sessSnapshot, sessAsset)\n\n{-# INLINEABLE validateCreateAccount #-}\nvalidateCreateAccount ::\n  StabilityPoolParams ->\n  Ledger.TokenName ->\n  StabilityPoolSnapshot ->\n  EpochToScaleToSum ->\n  Ledger.PaymentPubKeyHash ->\n  Integer ->\n  V2.ScriptContext ->\n  Bool\nvalidateCreateAccount\n  StabilityPoolParams {..}\n  asset\n  snapshot\n  epochToScaleToSum\n  pk\n  amt\n  ctx =\n    traceIfFalse \"Invalid input being validated\" (ownRef == poolRef)\n      && traceIfFalse \"User cannnot have negative balance\" (amt >= 0)\n      && traceIfFalse\n        \"Expected to consume exactly one Stability Pool output\"\n        (Helpers.isSpendingUnitValue info stabilityPoolToken)\n      && traceIfFalse\n        \"Wrong signature\"\n        (Contexts.txSignedBy info (Ledger.unPaymentPubKeyHash pk))\n      && traceIfFalse\n        \"Must mint an account token\"\n        (V2.txInfoMint info == Helpers.unitValue accountToken)\n      && traceIfFalse\n        \"Stability Pool output does not match\"\n        ( Helpers.checkOwnOutput\n            ctx\n            (StabilityPoolDatum asset newPoolSnapshot newEpochToScaleToSum)\n            ( poolValue\n                <> V2.singleton assetSymbol asset amt\n                <> Ada.lovelaceValueOf accountCreateFeeLovelaces\n            )\n        )\n      && traceIfFalse\n        \"Account output does not match\"\n        ( Helpers.checkOwnOutputAdaGeq\n            ctx\n            (AccountDatum pk asset accountSnapshot)\n            (Helpers.unitValue accountToken)\n        )\n    where\n      info :: V2.TxInfo\n      info = V2.scriptContextTxInfo ctx\n\n      newEpochToScaleToSum :: EpochToScaleToSum\n      newEpochToScaleToSum =\n        AssocMap.insert\n          (snapshotEpoch snapshot, snapshotScale snapshot)\n          (snapshotS newPoolSnapshot)\n          epochToScaleToSum\n\n      newDeposit :: SPInteger\n      newDeposit = snapshotD snapshot |+| toSPInteger amt\n\n      newPoolSnapshot :: StabilityPoolSnapshot\n      newPoolSnapshot =\n        snapshot\n          { snapshotD = newDeposit,\n            snapshotS =\n              snapshotS snapshot\n                |+| ( (toSPInteger accountCreateFeeLovelaces |*| snapshotP snapshot)\n                        |/| newDeposit\n                    )\n          }\n\n      accountSnapshot :: StabilityPoolSnapshot\n      accountSnapshot =\n        snapshot\n          { snapshotD = toSPInteger amt\n          }\n\n      ownRef :: V2.TxOutRef\n      ownRef = case V2.scriptContextPurpose ctx of\n        Contexts.Spending ref -> ref\n        _ -> traceError \"Must spend UTxO\"\n\n      poolRef :: V2.TxOutRef\n      poolInput :: V2.TxOut\n      (poolRef, poolInput) =\n        Helpers.findUniqueInputWithTokenRef stabilityPoolToken info\n\n      poolValue :: Ledger.Value\n      poolValue = V2.txOutValue poolInput\n\nstabilityPoolAddress :: StabilityPoolParams -> Ledger.Address\nstabilityPoolAddress = Address.mkValidatorAddress . stabilityPoolValidator\n", "output": "This Cardano smart contract code is part of the Indigo protocol, specifically dealing with the Stability Pool. The Stability Pool is a component of the protocol that helps maintain the stability of the system by managing collateral and liquidations. Let's break down the code and its components:\n\n### Module and Imports\n\n- **Module Declaration**: The module is named `Indigo.Contracts.StabilityPool.OnChain`. It exports several functions related to the Stability Pool, including the validator and its address.\n- **Imports**: The code imports various modules, including those for handling CDP (Collateralized Debt Position), governance, helpers, and Plutus libraries for working with smart contracts.\n\n### Key Functions and Components\n\n1. **stabilityPoolValidator**: \n   - This function creates a Plutus `Validator` for the Stability Pool using the `compiledValidateSP` function. It applies the `StabilityPoolParams` to the compiled code to generate the validator script.\n\n2. **compiledValidateSP**:\n   - This is a compiled Plutus code that takes `StabilityPoolParams` and returns an `UntypedValidator`. It uses the `validateStabilityPool` function to perform the validation logic.\n\n3. **untypedStabilityPoolValidator**:\n   - Similar to `stabilityPoolValidator`, but it works with `BuiltinData` instead of `StabilityPoolParams`. This is useful for scenarios where the parameters are provided in a serialized form.\n\n4. **untypedStabilityPoolValidatorHash**:\n   - Computes the hash of the untyped validator, which is used to identify the validator script on the blockchain.\n\n5. **stabilityPoolScriptCTL**:\n   - Provides a serialized version of the compiled validator script for use in CTL (Cardano Transaction Layer).\n\n6. **validateStabilityPool**:\n   - This is the core validation function. It takes parameters, datum, redeemer, and script context to determine if a transaction is valid. It handles various actions like creating an account, adjusting an account, liquidating a CDP, closing an account, recording epoch data, spending an account, and upgrading the version.\n\n### Validation Logic\n\n- **validateCreateAccount**: Validates the creation of a new account in the Stability Pool. It checks for correct signatures, token minting, and ensures the user's balance is non-negative.\n\n- **validateAdjustAccount**: Validates adjustments to an existing account, ensuring the user cannot have a negative balance and that the protocol fees are paid correctly.\n\n- **validateLiquidateCDP**: Handles the liquidation of a CDP, ensuring that the iAsset matches and that the CDP input is correctly liquidated.\n\n- **validateClose**: Validates the closing of an account, ensuring the correct burning of tokens and payment of protocol fees.\n\n- **validateRecordEpochToScaleToSum**: Validates the recording of epoch data, ensuring the correct output and minting of tokens.\n\n- **validateSpendAccount**: Ensures that spending from an account is done correctly, checking for mixed versions and correct consumption of the Stability Pool.\n\n### Helper Functions\n\n- **accumulatedEpochToScaleToSum**: Accumulates epoch data from reference inputs, ensuring the correct asset is used.\n\n- **Helpers and ContractHelpers**: These modules provide utility functions for common tasks like checking outputs, finding inputs, and handling values.\n\n### Address and Script Generation\n\n- **stabilityPoolAddress**: Generates the on-chain address for the Stability Pool using the validator.\n\n### Conclusion\n\nThis code is a comprehensive implementation of a Stability Pool smart contract on Cardano, handling various operations related to account management, collateral liquidation, and protocol upgrades. It uses Plutus, Cardano's smart contract platform, to ensure that all operations are secure and adhere to the protocol's rules. The use of helper functions and modular design makes the code maintainable and extensible.", "file_path": "indigo-smart-contracts/src/Indigo/Contracts/StabilityPool/OnChain.hs", "file": "OnChain.hs"}
{"instruction": "Explain the following smart contract code:", "input": "from copy import copy\n\nfrom ast import *\n\nfrom ..util import CompilingNodeTransformer\n\n\"\"\"\nRewrites all occurences of conditions to an implicit cast to bool\n\"\"\"\n\nSPECIAL_BOOL = \"~bool\"\n\n\nclass RewriteConditions(CompilingNodeTransformer):\n    step = \"Rewriting conditions to bools\"\n\n    def visit_Module(self, node: Module) -> Module:\n        node.body.insert(0, Assign([Name(SPECIAL_BOOL, Store())], Name(\"bool\", Load())))\n        return self.generic_visit(node)\n\n    def visit_If(self, node: If) -> If:\n        if_cp = copy(node)\n        if_cp.test = Call(Name(SPECIAL_BOOL, Load()), [node.test], [])\n        return self.generic_visit(if_cp)\n\n    def visit_IfExp(self, node: IfExp) -> IfExp:\n        if_cp = copy(node)\n        if_cp.test = Call(Name(SPECIAL_BOOL, Load()), [node.test], [])\n        return self.generic_visit(if_cp)\n\n    def visit_While(self, node: While) -> While:\n        while_cp = copy(node)\n        while_cp.test = Call(Name(SPECIAL_BOOL, Load()), [node.test], [])\n        return self.generic_visit(while_cp)\n\n    def visit_BoolOp(self, node: BoolOp) -> BoolOp:\n        bo_cp = copy(node)\n        bo_cp.values = [\n            Call(Name(SPECIAL_BOOL, Load()), [self.visit(v)], []) for v in bo_cp.values\n        ]\n        return self.generic_visit(bo_cp)\n\n    def visit_Assert(self, node: Assert) -> Assert:\n        assert_cp = copy(node)\n        assert_cp.test = Call(Name(SPECIAL_BOOL, Load()), [node.test], [])\n        return self.generic_visit(assert_cp)\n", "output": "This Cardano smart contract code is a Python script that uses the Abstract Syntax Tree (AST) module to transform Python code. Specifically, it rewrites conditions in the code to ensure they are explicitly cast to boolean values. This is done by creating a custom AST node transformer class called `RewriteConditions`, which inherits from `CompilingNodeTransformer`.\n\nHere's a detailed breakdown of the code:\n\n### Imports\n\n- `copy`: This is used to create a shallow copy of AST nodes. This is important because AST nodes are mutable, and copying them ensures that the original nodes are not modified directly.\n- `ast`: This module provides classes and functions to interact with Python's abstract syntax trees. It allows the manipulation of Python code as data.\n- `CompilingNodeTransformer`: This is a custom class (presumably defined elsewhere in the project) that `RewriteConditions` inherits from. It likely provides some base functionality for transforming AST nodes.\n\n### Constants\n\n- `SPECIAL_BOOL = \"~bool\"`: This is a string constant used as a special identifier for the boolean casting function. It is prefixed with a tilde to avoid conflicts with other identifiers.\n\n### Class: `RewriteConditions`\n\nThis class is responsible for transforming the AST to ensure that all conditions are explicitly cast to boolean values.\n\n#### Method: `visit_Module`\n\n- **Purpose**: This method is called when the transformer visits a `Module` node, which represents the entire Python script.\n- **Functionality**: It inserts an assignment at the beginning of the module that assigns the `bool` function to the special identifier `~bool`. This allows the script to use `~bool` as a function to cast values to boolean.\n\n#### Method: `visit_If`\n\n- **Purpose**: This method is called when the transformer visits an `If` node, which represents an `if` statement.\n- **Functionality**: It creates a copy of the `If` node and modifies the `test` attribute (the condition) to be a call to the `~bool` function, ensuring the condition is explicitly cast to a boolean.\n\n#### Method: `visit_IfExp`\n\n- **Purpose**: This method is called when the transformer visits an `IfExp` node, which represents a conditional expression (ternary operator).\n- **Functionality**: Similar to `visit_If`, it casts the condition to a boolean using the `~bool` function.\n\n#### Method: `visit_While`\n\n- **Purpose**: This method is called when the transformer visits a `While` node, which represents a `while` loop.\n- **Functionality**: It ensures the loop condition is explicitly cast to a boolean by wrapping it in a call to `~bool`.\n\n#### Method: `visit_BoolOp`\n\n- **Purpose**: This method is called when the transformer visits a `BoolOp` node, which represents a boolean operation (like `and` or `or`).\n- **Functionality**: It iterates over each value in the boolean operation and casts each one to a boolean using the `~bool` function.\n\n#### Method: `visit_Assert`\n\n- **Purpose**: This method is called when the transformer visits an `Assert` node, which represents an `assert` statement.\n- **Functionality**: It ensures the assertion condition is explicitly cast to a boolean by wrapping it in a call to `~bool`.\n\n### Summary\n\nThe `RewriteConditions` class is designed to traverse a Python AST and modify it so that all conditions are explicitly cast to boolean values using a custom identifier `~bool`. This transformation is applied to `if` statements, conditional expressions, `while` loops, boolean operations, and assertions. The use of `~bool` helps avoid conflicts with existing identifiers and ensures that the transformation is applied consistently across the code.", "file_path": "opshin/opshin/rewrite/rewrite_cast_condition.py", "file": "rewrite_cast_condition.py"}
{"instruction": "Explain the following smart contract code:", "input": "module Spec.TestContract.LockSpendMint (lockThenSpend) where\n\nimport BotPlutusInterface.Constraints (submitBpiTxConstraintsWith)\nimport Control.Monad (void)\nimport Data.List.NonEmpty qualified as NonEmpty\nimport Data.Map qualified as Map\nimport Data.Text (Text)\nimport Data.Void (Void)\nimport Ledger (\n  Address,\n  CardanoTx,\n  ChainIndexTxOut,\n  CurrencySymbol,\n  PaymentPubKeyHash (PaymentPubKeyHash),\n  ScriptContext (scriptContextTxInfo),\n  TxId,\n  TxInfo (txInfoMint),\n  TxOutRef,\n  getCardanoTxId,\n  scriptHashAddress,\n )\nimport Ledger.Ada (adaValueOf)\nimport Ledger.Constraints qualified as Constraints\nimport Ledger.Scripts qualified as Scripts\nimport Ledger.Typed.Scripts (TypedValidator, Validator, ValidatorTypes, mkUntypedMintingPolicy)\nimport Ledger.Typed.Scripts qualified as TypedScripts\nimport Ledger.Value (flattenValue, tokenName)\nimport Plutus.Contract (Contract, awaitTxConfirmed)\nimport Plutus.Contract qualified as Contract\nimport Plutus.PAB.Effects.Contract.Builtin (EmptySchema)\nimport Plutus.Script.Utils.V1.Scripts qualified as ScriptUtils\nimport Plutus.V1.Ledger.Value qualified as Value\nimport PlutusTx qualified\nimport PlutusTx.Prelude qualified as PP\nimport Prelude\n\nlockThenSpend :: Contract () EmptySchema Text [(TxOutRef, ChainIndexTxOut)]\nlockThenSpend = do\n  _ <- lockAtScript\n  wait 1\n  _ <- spendFromScript\n  wait 1\n  addr <- NonEmpty.head <$> Contract.ownAddresses\n  Map.toList <$> Contract.utxosAt addr\n  where\n    wait = void . Contract.waitNSlots\n\nlockAtScript :: Contract () EmptySchema Text (TxId, CardanoTx)\nlockAtScript = do\n  let constr =\n        Constraints.mustPayToOtherScriptWithDatumInTx -- WARN: at the moment `mustPayToOtherScript` causes `DatumNotFound` error during constraints resolution\n          (ScriptUtils.validatorHash validator)\n          Scripts.unitDatum\n          (adaValueOf 10)\n  let constr2 =\n        Constraints.mustPayToOtherScriptWithDatumInTx -- WARN: at the moment `mustPayToOtherScript` causes `DatumNotFound` error during constraints resolution\n          (ScriptUtils.validatorHash $ validator2 2)\n          Scripts.unitDatum\n          (adaValueOf 10)\n  tx <- submitBpiTxConstraintsWith @Void mempty (constr <> constr2) []\n  awaitTxConfirmed $ getCardanoTxId tx\n  pure (getCardanoTxId tx, tx)\n\nspendFromScript :: Contract () EmptySchema Text (TxId, CardanoTx)\nspendFromScript = do\n  utxos1 <- Map.toList <$> Contract.utxosAt validatorAddr\n  utxos2 <- Map.toList <$> Contract.utxosAt (validatorAddr2 2)\n  case (utxos1, utxos2) of\n    ([], _) -> Contract.throwError \"No UTxOs at script address\"\n    (_, []) -> Contract.throwError \"No UTxOs at script address\"\n    ((oref1, _) : _, (oref2, _) : _) -> spendUtxo oref1 utxos1 oref2 utxos2\n  where\n    spendUtxo oref1 utxos1 oref2 utxos2 = do\n      let token = Value.singleton currencySymbol (tokenName \"ff\") 1\n          txc1 =\n            Constraints.mustSpendScriptOutput oref1 Scripts.unitRedeemer\n              <> Constraints.mustMintValueWithRedeemer Scripts.unitRedeemer token\n          lookups1 =\n            Constraints.unspentOutputs (Map.fromList utxos1)\n              <> Constraints.plutusV1OtherScript validator\n              <> Constraints.plutusV1MintingPolicy mintingPolicy\n\n      let txc2 =\n            Constraints.mustSpendScriptOutput oref2 Scripts.unitRedeemer\n              <> Constraints.mustPayToPubKey\n                (PaymentPubKeyHash \"72cae61f85ed97fb0e7703d9fec382e4973bf47ea2ac9335cab1e3fe\")\n                (adaValueOf 200)\n          lookups2 =\n            Constraints.unspentOutputs (Map.fromList utxos2)\n              <> Constraints.plutusV1OtherScript (validator2 2)\n\n      tx <- submitBpiTxConstraintsWith @TestLockSpend (lookups1 <> lookups2) (txc1 <> txc2) []\n      awaitTxConfirmed $ getCardanoTxId tx\n      pure (getCardanoTxId tx, tx)\n\n-- Always true Script and spending contract\n\n{-# INLINEABLE mkValidator #-}\nmkValidator :: () -> () -> ScriptContext -> Bool\nmkValidator _ _ _ = PP.traceIfFalse \"validator 1 error\" True\n\ndata TestLockSpend\n\ninstance ValidatorTypes TestLockSpend where\n  type DatumType TestLockSpend = ()\n  type RedeemerType TestLockSpend = ()\n\ntypedValidator :: TypedValidator TestLockSpend\ntypedValidator =\n  TypedScripts.mkTypedValidator @TestLockSpend\n    $$(PlutusTx.compile [||mkValidator||])\n    $$(PlutusTx.compile [||wrap||])\n  where\n    wrap = TypedScripts.mkUntypedValidator @() @()\n\nvalidator :: Validator\nvalidator = TypedScripts.validatorScript typedValidator\n\nvalidatorAddr :: Address\nvalidatorAddr = scriptHashAddress $ ScriptUtils.validatorHash validator\n\n{-# INLINEABLE mkValidator2 #-}\nmkValidator2 :: Integer -> () -> () -> ScriptContext -> Bool\nmkValidator2 i _ _ _ =\n  if i PP./= 1\n    then PP.traceIfFalse \"looooooooooooong\" check\n    else PP.traceIfFalse \"short\" check\n  where\n    someWork = PP.sort $ PP.reverse [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] :: [Integer]\n    check = PP.length someWork PP.== 10\n\ndata TestLockSpend2\n\ninstance ValidatorTypes TestLockSpend2 where\n  type DatumType TestLockSpend2 = ()\n  type RedeemerType TestLockSpend2 = ()\n\ntypedValidator2 :: Integer -> TypedValidator TestLockSpend\ntypedValidator2 uid =\n  TypedScripts.mkTypedValidator @TestLockSpend\n    ($$(PlutusTx.compile [||mkValidator2||]) `PlutusTx.applyCode` PlutusTx.liftCode uid)\n    $$(PlutusTx.compile [||wrap||])\n  where\n    wrap = TypedScripts.mkUntypedValidator @() @()\n\nvalidator2 :: Integer -> Validator\nvalidator2 = TypedScripts.validatorScript . typedValidator2\n\nvalidatorAddr2 :: Integer -> Address\nvalidatorAddr2 = scriptHashAddress . ScriptUtils.validatorHash . validator2\n\n-- minting policy\n{-# INLINEABLE mkPolicy #-}\nmkPolicy :: () -> ScriptContext -> Bool\nmkPolicy _ ctx =\n  PP.traceIfFalse \"Let me mint\" check\n  where\n    info = scriptContextTxInfo ctx\n    check =\n      PP.length (flattenValue PP.$ txInfoMint info) PP.== 1\n        PP.&& PP.length someWork PP.== 10\n\n    someWork = PP.sort [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] :: [Integer]\n\nmintingPolicy :: TypedScripts.MintingPolicy\nmintingPolicy =\n  Scripts.mkMintingPolicyScript\n    $$(PlutusTx.compile [||mkUntypedMintingPolicy mkPolicy||])\n\ncurrencySymbol :: CurrencySymbol\ncurrencySymbol = ScriptUtils.scriptCurrencySymbol mintingPolicy\n", "output": "This Cardano smart contract code is written in Haskell using the Plutus framework. It defines a contract that locks some ADA at a script address and then spends it, while also minting a token. Let's break down the code in detail:\n\n### Module and Imports\n\n- **Module Declaration**: The module is named `Spec.TestContract.LockSpendMint` and it exports a single function `lockThenSpend`.\n- **Imports**: The code imports various modules from the Plutus framework and Haskell standard libraries. These imports provide functionalities for handling transactions, scripts, constraints, and more.\n\n### Main Function: `lockThenSpend`\n\nThis is the main contract function that orchestrates the locking and spending of ADA:\n\n1. **Locking ADA**: It calls `lockAtScript` to lock ADA at a script address.\n2. **Waiting**: It waits for a certain number of slots (block time) using the `wait` function.\n3. **Spending ADA**: It calls `spendFromScript` to spend the locked ADA.\n4. **Fetching UTXOs**: It retrieves the UTXOs at the contract's own address.\n\n### Helper Functions\n\n#### `lockAtScript`\n\nThis function locks ADA at two different script addresses:\n\n- **Constraints**: It defines constraints to pay 10 ADA to two different script addresses using `mustPayToOtherScriptWithDatumInTx`.\n- **Transaction Submission**: It submits the transaction with these constraints and waits for confirmation.\n\n#### `spendFromScript`\n\nThis function spends the ADA locked at the script addresses:\n\n- **UTXO Retrieval**: It retrieves UTXOs from the two script addresses.\n- **Error Handling**: It throws an error if no UTXOs are found at either address.\n- **Spending UTXOs**: It defines constraints to spend the UTXOs and mint a token. It also pays 200 ADA to a specific public key hash.\n- **Transaction Submission**: It submits the transaction with these constraints and waits for confirmation.\n\n### Validators\n\nThe code defines two validators:\n\n1. **`mkValidator`**: A simple validator that always returns `True`, allowing any transaction.\n2. **`mkValidator2`**: A more complex validator that checks an integer parameter and performs some list operations. It returns `True` if the operations are successful.\n\n### Typed Validators\n\n- **`typedValidator` and `typedValidator2`**: These are typed versions of the validators, created using `mkTypedValidator`.\n- **`validator` and `validator2`**: These are the actual validator scripts derived from the typed validators.\n\n### Addresses\n\n- **`validatorAddr` and `validatorAddr2`**: These are the script addresses derived from the validators.\n\n### Minting Policy\n\n- **`mkPolicy`**: A minting policy that allows minting if certain conditions are met, such as the length of the minted value being 1.\n- **`mintingPolicy`**: The actual minting policy script created from `mkPolicy`.\n- **`currencySymbol`**: The currency symbol associated with the minting policy.\n\n### Key Points\n\n- **Constraints**: The contract uses constraints to specify how transactions should be constructed, such as spending from scripts and minting tokens.\n- **Error Handling**: The contract includes error handling to manage cases where expected UTXOs are not found.\n- **PlutusTx**: The code uses Template Haskell (`$$(PlutusTx.compile [||...||])`) to compile Plutus Core scripts from Haskell functions.\n\nOverall, this contract demonstrates a typical workflow in Plutus where ADA is locked at a script address and then spent, with additional logic for minting tokens. The use of validators and minting policies ensures that only valid transactions are processed.", "file_path": "plutip/test/Spec/TestContract/LockSpendMint.hs", "file": "LockSpendMint.hs"}
{"instruction": "Explain the following smart contract code:", "input": "from .db import (\n    Block,\n    Address,\n    Datum,\n    Token,\n    Transaction,\n    TransactionOutput,\n    TransactionOutputValue,\n    sqlite_db,\n)\nfrom .gov_state import GovState, GovParams, GovUpgrade, TrackedGovStates\nfrom .tally_state import (\n    TallyState,\n    TallyProposals,\n    TallyParams,\n    TallyWeights,\n    TallyVote,\n    TallyCreation,\n    TallyCreationParticipants,\n)\nfrom .treasury import (\n    TreasurerParams,\n    TreasurerState,\n    ValueStoreState,\n    TreasuryDelta,\n    TreasuryDeltaValue,\n    TrackedTreasuryStates,\n    TreasuryPayout,\n)\nfrom .staking import (\n    StakingState,\n    StakingParams,\n    StakingParticipation,\n    VotePermission,\n    StakingDeposit,\n    StakingParticipationInStaking,\n    VotePermissionMint,\n    StakingDepositDelta,\n    StakingDepositParticipationAdded,\n    StakingDepositParticipationRemoved,\n)\n\nsqlite_db.connect()\nsqlite_db.create_tables(\n    [\n        Block,\n        Address,\n        Datum,\n        Token,\n        Transaction,\n        TransactionOutput,\n        TransactionOutputValue,\n        GovParams,\n        GovState,\n        GovUpgrade,\n        TallyState,\n        TallyParams,\n        TallyProposals,\n        TallyWeights,\n        TallyCreation,\n        TallyCreationParticipants,\n        TallyVote,\n        TreasurerParams,\n        TreasurerState,\n        TreasuryDelta,\n        TreasuryDeltaValue,\n        TreasuryPayout,\n        ValueStoreState,\n        StakingParams,\n        StakingState,\n        StakingParticipation,\n        StakingDeposit,\n        StakingDepositDelta,\n        StakingDepositParticipationAdded,\n        StakingDepositParticipationRemoved,\n        StakingParticipationInStaking,\n        VotePermission,\n        VotePermissionMint,\n    ]\n)\n", "output": "The provided code is a Python module that is part of a larger system for on-chain governance on the Cardano blockchain, specifically for the MuesliSwap project. This module is responsible for setting up and managing the database models that represent various entities and states within the governance system. Let's break down the code in detail:\n\n### Imports\n\nThe code imports several classes from different modules within the same package. These classes represent different entities and states that are part of the governance system:\n\n1. **From `db`:**\n   - `Block`, `Address`, `Datum`, `Token`, `Transaction`, `TransactionOutput`, `TransactionOutputValue`: These classes likely represent fundamental blockchain entities and their attributes, such as blocks, addresses, tokens, and transactions.\n\n2. **From `gov_state`:**\n   - `GovState`, `GovParams`, `GovUpgrade`, `TrackedGovStates`: These classes are related to the governance state, parameters, upgrades, and tracking of governance states.\n\n3. **From `tally_state`:**\n   - `TallyState`, `TallyProposals`, `TallyParams`, `TallyWeights`, `TallyVote`, `TallyCreation`, `TallyCreationParticipants`: These classes are related to the tallying process in governance, including proposals, parameters, weights, votes, and the creation of tallying processes and participants.\n\n4. **From `treasury`:**\n   - `TreasurerParams`, `TreasurerState`, `ValueStoreState`, `TreasuryDelta`, `TreasuryDeltaValue`, `TrackedTreasuryStates`, `TreasuryPayout`: These classes manage the treasury aspect of governance, including parameters, state, value changes, and payouts.\n\n5. **From `staking`:**\n   - `StakingState`, `StakingParams`, `StakingParticipation`, `VotePermission`, `StakingDeposit`, `StakingParticipationInStaking`, `VotePermissionMint`, `StakingDepositDelta`, `StakingDepositParticipationAdded`, `StakingDepositParticipationRemoved`: These classes handle staking-related activities, including state, parameters, participation, permissions, deposits, and changes in staking participation.\n\n### Database Connection and Table Creation\n\n- **`sqlite_db.connect()`:** This line establishes a connection to the SQLite database. The `sqlite_db` object is likely an instance of a database connection or ORM (Object-Relational Mapping) manager that handles interactions with the SQLite database.\n\n- **`sqlite_db.create_tables([...])`:** This line creates tables in the database for each of the imported classes. The list passed to `create_tables` includes all the classes that represent different entities and states in the governance system. This step is crucial for setting up the database schema, ensuring that all necessary tables are available for storing data related to governance, tallying, treasury, and staking.\n\n### Summary\n\nThis module is part of the backend infrastructure for MuesliSwap's on-chain governance system. It sets up the database schema by defining tables for various entities and states involved in governance, tallying, treasury management, and staking. By organizing these components into separate modules and classes, the system can efficiently manage and track the complex interactions and data flows required for decentralized governance on the Cardano blockchain.", "file_path": "muesliswap-onchain-governance/muesliswap_onchain_governance/api/db_models/__init__.py", "file": "__init__.py"}
{"instruction": "Explain the following smart contract code:", "input": "from .keys import get_address, get_signing_info\nfrom .network import ogmios_url, network, kupo_url\n", "output": "The code snippet you've provided is from a Python module, specifically from the `__init__.py` file located in the `muesliswap-onchain-governance/muesliswap_onchain_governance/utils` directory. This file is part of a larger project related to MuesliSwap, which is a decentralized exchange (DEX) on the Cardano blockchain. The purpose of this file is to initialize the `utils` package and make certain functions and variables available for import when the package is used elsewhere in the project.\n\nLet's break down the code line by line:\n\n1. **Import Statements:**\n   ```python\n   from .keys import get_address, get_signing_info\n   from .network import ogmios_url, network, kupo_url\n   ```\n\n   These lines are importing specific functions and variables from other modules within the same package (`utils`). The dot (`.`) before the module names (`keys` and `network`) indicates a relative import, meaning these modules are located in the same directory as the `__init__.py` file.\n\n   - **`from .keys import get_address, get_signing_info`:**\n     - `get_address`: This function is likely responsible for generating or retrieving a blockchain address, which is a crucial part of interacting with the Cardano network.\n     - `get_signing_info`: This function probably deals with obtaining signing information, which is necessary for authorizing transactions on the blockchain. This could include retrieving private keys or other cryptographic data needed to sign transactions.\n\n   - **`from .network import ogmios_url, network, kupo_url`:**\n     - `ogmios_url`: This variable likely holds the URL for an Ogmios server. Ogmios is a lightweight bridge interface for Cardano, providing a way to interact with the blockchain using WebSockets.\n     - `network`: This variable might define the network environment being used, such as `mainnet` or `testnet`, which are different environments for deploying and testing blockchain applications.\n     - `kupo_url`: This variable probably contains the URL for a Kupo server. Kupo is a Cardano indexer that provides a way to query blockchain data efficiently.\n\n**Purpose of the `__init__.py` File:**\n\nThe `__init__.py` file in a Python package is used to initialize the package and can be used to define what is available for import when the package is imported. By including these import statements, the `utils` package is making the `get_address`, `get_signing_info`, `ogmios_url`, `network`, and `kupo_url` available to other parts of the project that import the `utils` package. This helps in organizing the code and making it modular, allowing for easier maintenance and reuse of code across the project.\n\nIn summary, this code snippet is setting up the `utils` package to provide essential functions and configuration variables related to blockchain addresses, signing information, and network connectivity, which are crucial for the operation of the MuesliSwap on-chain governance system on the Cardano blockchain.", "file_path": "muesliswap-onchain-governance/muesliswap_onchain_governance/utils/__init__.py", "file": "__init__.py"}
{"instruction": "Explain the following smart contract code:", "input": "from util import *\nfrom contract import PublishParams\nfrom time import time\n\n\nINFO = 7\nAMOUNT = 12500000\nVALIDITY_TIME = 300\nowner = oracle_vkey.hash().to_primitive()\ndeadline = int(time() + VALIDITY_TIME) * 1000\namount = Value(AMOUNT)\ndatum = PublishParams(owner, deadline, INFO)\n\nbuilder = TransactionBuilder(context)\nbuilder.add_input_address(oracle_address)\nbuilder.add_output(TransactionOutput(script_address, amount=amount, datum=datum))\nsigned_tx = builder.build_and_sign([oracle_skey], change_address=oracle_address)\n\nsave_transaction(signed_tx, \"transactions/tx_deposit.signed\")\ncontext.submit_tx(signed_tx.to_cbor())\n", "output": "This Cardano smart contract code is written in Python and is part of a script that interacts with the Cardano blockchain using the Opshin framework. The script is designed to publish a transaction that involves an oracle, which is a service that provides external data to the blockchain. Let's break down the code step by step:\n\n1. **Imports**:\n   - `from util import *`: This imports utility functions and classes that are likely used throughout the script.\n   - `from contract import PublishParams`: This imports the `PublishParams` class, which is used to create a datum for the transaction.\n   - `from time import time`: This imports the `time` function from Python's standard library, which is used to get the current time.\n\n2. **Constants and Variables**:\n   - `INFO = 7`: This is a constant that likely represents some information or identifier related to the oracle data.\n   - `AMOUNT = 12500000`: This is the amount of Lovelace (the smallest unit of ADA, Cardano's cryptocurrency) to be sent in the transaction.\n   - `VALIDITY_TIME = 300`: This represents the validity period for the transaction in seconds (5 minutes).\n   - `owner = oracle_vkey.hash().to_primitive()`: This line computes the hash of the oracle's verification key to get the owner's address in a primitive format.\n   - `deadline = int(time() + VALIDITY_TIME) * 1000`: This calculates the deadline for the transaction by adding the validity time to the current time and converting it to milliseconds.\n   - `amount = Value(AMOUNT)`: This creates a `Value` object representing the amount of Lovelace to be transferred.\n   - `datum = PublishParams(owner, deadline, INFO)`: This creates a datum using the `PublishParams` class, which includes the owner's address, the deadline, and the info constant.\n\n3. **Transaction Building**:\n   - `builder = TransactionBuilder(context)`: This initializes a `TransactionBuilder` object with the current blockchain context. This object is used to construct the transaction.\n   - `builder.add_input_address(oracle_address)`: This adds an input to the transaction from the oracle's address, indicating that the funds will be drawn from this address.\n   - `builder.add_output(TransactionOutput(script_address, amount=amount, datum=datum))`: This adds an output to the transaction, specifying the destination script address, the amount to be sent, and the datum to be included.\n\n4. **Signing and Submitting the Transaction**:\n   - `signed_tx = builder.build_and_sign([oracle_skey], change_address=oracle_address)`: This builds and signs the transaction using the oracle's signing key (`oracle_skey`). The change from the transaction, if any, will be sent back to the oracle's address.\n   - `save_transaction(signed_tx, \"transactions/tx_deposit.signed\")`: This saves the signed transaction to a file named `tx_deposit.signed` in the `transactions` directory.\n   - `context.submit_tx(signed_tx.to_cbor())`: This submits the transaction to the Cardano blockchain in CBOR (Concise Binary Object Representation) format.\n\nOverall, this script is designed to create and submit a transaction that involves an oracle. The transaction includes a specific amount of ADA, a datum with oracle-related information, and a validity period. The transaction is signed by the oracle's private key and submitted to the blockchain.", "file_path": "opshin-smart-contract-examples/vesting_oracle_fee/oracle/publish.py", "file": "publish.py"}
{"instruction": "Explain the following smart contract code:", "input": "#!opshin\n# This is an example of how to determine the structure of the datum files to use with you opshin custom datums.\n# The JSON file is usually required by third party tools like the cardano-cli\n\n# ExampleDatumStructure in opshin contract:\n\"\"\"\n@dataclass()\nclass Listing(PlutusData):\n    # Price of the listing in lovelace\n    price: int\n    # the owner of the listed object\n    vendor: Address\n    # whoever is allowed to withdraw the listing\n    owner: PubKeyHash\n\"\"\"\n# Import the dataclass from the opshin python file\n\nfrom examples.smart_contracts.marketplace import (\n    Listing,\n    Address,\n    PubKeyCredential,\n    NoStakingCredential,\n)\n\n# Create the datum structure in the correct order and print it to use in your transactions for locking unlocking in cardano-cli\ndatum = Listing(\n    5000000,  # This price is in lovelace = 5 ADA\n    Address(\n        PubKeyCredential(\n            bytes.fromhex(\"f5b84180b5a3cca20052258fe73328c69ff8e0d41709505668101db7\")\n        ),\n        NoStakingCredential(),\n    ),\n    bytes.fromhex(\"f5b84180b5a3cca20052258fe73328c69ff8e0d41709505668101db7\"),\n)\n\n# Export in JSON notation\nprint(datum.to_json(indent=2))\n\"\"\"\n{\n  \"constructor\": 0,\n  \"fields\": [\n    {\n      \"int\": 5000000\n    },\n    {\n      \"constructor\": 0,\n      \"fields\": [\n        {\n          \"constructor\": 0,\n          \"fields\": [\n            {\n              \"bytes\": \"f5b84180b5a3cca20052258fe73328c69ff8e0d41709505668101db7\"\n            }\n          ]\n        },\n        {\n          \"constructor\": 1,\n          \"fields\": []\n        }\n      ]\n    },\n    {\n      \"bytes\": \"f5b84180b5a3cca20052258fe73328c69ff8e0d41709505668101db7\"\n    }\n  ]\n}\n\"\"\"\n# Export as CBOR Hex\nprint(datum.to_cbor(encoding=\"hex\"))\n\"\"\"d8799f1a004c4b40d8799fd8799f581cf5b84180b5a3cca20052258fe73328c69ff8e0d41709505668101db7ffd87a80ff581cf5b84180b5a3cca20052258fe73328c69ff8e0d41709505668101db7ff\"\"\"\n", "output": "This Cardano smart contract code is written in Opshin, a Python-based language for writing Plutus smart contracts. The code demonstrates how to define and serialize a custom datum structure for use in Cardano transactions. Let's break down the code step by step:\n\n### 1. Datum Structure Definition\n\nThe code begins with a comment that describes the structure of a custom datum called `Listing`. This structure is defined using a Python `dataclass` and inherits from `PlutusData`, which is a base class for data types used in Plutus smart contracts.\n\n```python\n@dataclass()\nclass Listing(PlutusData):\n    # Price of the listing in lovelace\n    price: int\n    # the owner of the listed object\n    vendor: Address\n    # whoever is allowed to withdraw the listing\n    owner: PubKeyHash\n```\n\n- **`price`**: An integer representing the price of the listing in lovelace (1 ADA = 1,000,000 lovelace).\n- **`vendor`**: An `Address` type representing the owner of the listed object.\n- **`owner`**: A `PubKeyHash` type representing the entity allowed to withdraw the listing.\n\n### 2. Importing Required Classes\n\nThe code imports necessary classes from a module named `examples.smart_contracts.marketplace`. These classes are used to construct the `Listing` datum.\n\n```python\nfrom examples.smart_contracts.marketplace import (\n    Listing,\n    Address,\n    PubKeyCredential,\n    NoStakingCredential,\n)\n```\n\n- **`Listing`**: The custom datum class.\n- **`Address`**: Represents a Cardano address.\n- **`PubKeyCredential`**: Represents a public key credential.\n- **`NoStakingCredential`**: Represents the absence of a staking credential.\n\n### 3. Creating the Datum Instance\n\nAn instance of the `Listing` datum is created with specific values.\n\n```python\ndatum = Listing(\n    5000000,  # This price is in lovelace = 5 ADA\n    Address(\n        PubKeyCredential(\n            bytes.fromhex(\"f5b84180b5a3cca20052258fe73328c69ff8e0d41709505668101db7\")\n        ),\n        NoStakingCredential(),\n    ),\n    bytes.fromhex(\"f5b84180b5a3cca20052258fe73328c69ff8e0d41709505668101db7\"),\n)\n```\n\n- **`price`**: Set to 5,000,000 lovelace (5 ADA).\n- **`vendor`**: An `Address` object is created with a `PubKeyCredential` containing a public key hash and a `NoStakingCredential`.\n- **`owner`**: A public key hash, identical to the vendor's public key hash.\n\n### 4. Exporting the Datum\n\nThe datum is serialized into two formats: JSON and CBOR Hex.\n\n#### JSON Export\n\n```python\nprint(datum.to_json(indent=2))\n```\n\nThis outputs the datum in JSON format, which is human-readable and useful for integration with tools like `cardano-cli`. The JSON structure includes constructors and fields that represent the data in a structured way.\n\n#### CBOR Hex Export\n\n```python\nprint(datum.to_cbor(encoding=\"hex\"))\n```\n\nThis outputs the datum in CBOR (Concise Binary Object Representation) encoded as a hexadecimal string. CBOR is a binary format that is compact and efficient for on-chain storage and processing.\n\n### Summary\n\nThis code provides a clear example of how to define, instantiate, and serialize a custom datum for use in Cardano smart contracts. The `Listing` datum includes a price, a vendor address, and an owner public key hash, and it is serialized into both JSON and CBOR formats for use in transactions. This approach is essential for interacting with Cardano's extended UTXO model, where datums play a crucial role in smart contract logic.", "file_path": "opshin/examples/extract_datum.py", "file": "extract_datum.py"}
